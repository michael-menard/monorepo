perspective: platform
verdict: CONCERNS

scope:
  infrastructure_requirements_defined: true
  deployment_strategy_clear: true
  scalability_planned: true

mvp_blockers:
  - id: PLAT-001
    issue: Lambda concurrency and connection pooling strategy undefined for COGN-004 - impacts reliability at scale
    stories: [COGN-004]
    action: Define Lambda reserved concurrency, database connection pool sizing, and connection management before implementation

  - id: PLAT-002
    issue: Database migration strategy for COGN-001 lacks zero-downtime approach - risks production data integrity
    stories: [COGN-001]
    action: Define blue-green or phased migration plan with rollback capability before COGN-001 implementation

  - id: PLAT-003
    issue: CloudWatch monitoring and alerting strategy not detailed - COGN-022/023 needs upfront planning
    stories: [COGN-022, COGN-023]
    action: Define metrics, dashboards, alert thresholds before monitoring implementation starts

infrastructure_requirements:
  - component: AWS Lambda (COGN-004, COGN-025)
    requirements:
      memory: 512MB minimum (test and confirm)
      timeout: 30 seconds default (spec per operation)
      reserved_concurrency: TBD based on load testing
      layers: Node.js runtime, database driver

  - component: Amazon Aurora PostgreSQL (COGN-001)
    requirements:
      instance_class: db.t3.medium minimum (test)
      storage_autoscaling: enabled
      backups: daily, retention 7 days
      multi_az: recommended for production

  - component: AWS Cognito (COGN-003)
    requirements:
      user_pool: 1 pool for all tiers
      groups: 4 groups (admin, free, pro, power)
      mfa: optional for MVP, required for power tier Post-MVP
      token_expiration: 1 hour (spec in COGN-005)

  - component: API Gateway (all endpoint stories)
    requirements:
      authorization: Lambda authorizer using Cognito JWKS
      throttling: 10k RPS default, adjust based on load test
      logging: all API calls for audit

  - component: CloudWatch (COGN-022, COGN-023)
    requirements:
      log_retention: 30 days
      metrics: Lambda duration, errors, quota checks, auth failures
      dashboards: Executive, Operations, Debug
      alarms: Database CPU >80%, Lambda errors >1%, Auth failures >5%

deployment_strategy:
  - phase: Pre-launch (COGN-001 through COGN-026)
    approach: Feature flags per story; deploy to staging
    validation: COGN-025 test suite must pass

  - phase: Launch (COGN-027)
    approach: Canary deployment; 10% traffic first 1 hour, then 50%, then 100%
    monitoring: Real-time alarms on auth failures, quota overages, Lambda errors
    rollback: Database triggers can be disabled in <5 minutes

  - phase: Post-launch
    approach: Monitor for 24 hours; adjust thresholds based on real usage patterns
    operations: On-call for quota reconciliation, auth issues, scale-up

scalability_planning:
  - metric: Concurrent logins
    current_estimate: 100 req/s
    target_design: 1000 req/s (10x headroom)
    bottleneck: Lambda concurrency; mitigate with reserved concurrency

  - metric: Quota checks per second
    current_estimate: 500 req/s
    target_design: 5000 req/s (10x headroom)
    bottleneck: Database connection pool; mitigate with connection pooling

  - metric: Storage quota
    current_estimate: 1TB per user average
    target_design: 10TB per user (power tier)
    bottleneck: Aurora storage autoscaling; monitor IO

cost_estimation:
  component: Lambda
  usage: 10M invocations/month (auth + quota checks)
  cost: ~$200/month
  note: Dominated by duration; optimize cold starts

  component: Aurora PostgreSQL
  usage: db.t3.medium, 100GB storage
  cost: ~$150/month
  note: Auto-scaling may increase during peak

  component: Cognito
  usage: 10k monthly active users
  cost: Free (first 50k users included)
  note: Excellent value for MVP

  component: CloudWatch
  usage: ~1GB logs/day, 100 metrics
  cost: ~$30/month
  note: Plan log retention strategy early

ci_cd_requirements:
  - pipeline: Separate build for each story's Lambda/middleware code
  - testing: Unit + integration tests must pass before deploy
  - staging: Deploy to staging first; COGN-025 runs comprehensive tests
  - production: Canary deployment with monitoring

security_posture:
  - story: COGN-003
    requirement: Cognito user pool must enforce strong passwords
    config: Minimum 12 chars, uppercase, lowercase, numbers, symbols

  - story: COGN-005
    requirement: JWKS keys must be cached but not for >1 hour
    validation: Key rotation tested in COGN-025

  - story: COGN-015
    requirement: JWT stored in httpOnly cookies (CSRF protected)
    validation: No localStorage access; secure flag set

  - story: COGN-020
    requirement: Age verification must not store birthdate in JWT
    validation: Only is_minor flag included; birthdate stays in database

disaster_recovery:
  - scenario: Database corruption in quota tracking
    recovery_window: <24 hours (quota reconciliation in COGN-024)
    rto: 30 minutes (query backup, restore quota table)

  - scenario: Lambda code bug deployed to production
    recovery_window: <5 minutes (rollback via alias)
    rto: Immediate (previous alias version still live)

  - scenario: Cognito user pool deletion
    recovery_window: >7 days (backup restore required)
    rto: 1 hour (restore from backup)

future:
  deferred_infrastructure:
    - Multi-region deployment Post-MVP
    - Database read replicas for analytics Post-MVP
    - Caching layer (Redis) for scope lookups Post-MVP

  recommendations:
    - "Define Lambda concurrency budgets before COGN-004"
    - "Create database migration runbook before COGN-001"
    - "Set up CloudWatch alarms for baseline metrics before launch"
    - "Run load tests to validate scaling assumptions"
    - "Create disaster recovery runbooks before production"

metrics:
  infrastructure_components: 5
  deployment_phases: 3
  scalability_targets_defined: 3
  mvp_blockers: 3

PLATFORM REVIEW COMPLETE
