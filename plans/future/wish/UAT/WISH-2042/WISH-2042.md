---
doc_type: story
title: "WISH-2042: Purchase/Got It Flow"
story_id: WISH-2042
story_prefix: WISH
status: uat
split_from: WISH-2004
split_part: 2 of 2
phase: 3
created_at: "2026-01-27T00:00:00-07:00"
updated_at: "2026-01-28T14:45:00Z"
depends_on: [WISH-2001, WISH-2041]
estimated_points: 5
deferred_ac:
  - ac_9b: "Undo functionality intentionally deferred to WISH-2005 (UX Polish). Current implementation shows placeholder toast 'Undo feature coming soon' instead of full undo operation. Reason: Requires Sets DELETE endpoint integration and complex cache restoration logic. Not critical for MVP purchase flow."
---

# WISH-2042: Purchase/Got It Flow

## Split Context

This story is part of a split from WISH-2004.
- **Original Story:** WISH-2004 (Modals & Transitions)
- **Split Reason:** Original story bundled two independent user flows (Delete and Purchase) with 10 ACs, complex cross-domain transaction logic, multiple modal interfaces, and undo mechanics. Split required to separate concerns and reduce complexity.
- **This Part:** 2 of 2 (Purchase/"Got It" Flow)
- **Dependency:** Depends on WISH-2001 (Gallery MVP) and WISH-2041 (Delete Flow for undo pattern reuse)

## Context

When users purchase a wishlist item in real life, they need a way to transition that item from their wishlist to their Sets collection. This "Got It" flow captures purchase details (price paid, tax, shipping, purchase date) and creates a corresponding Set item. Users can optionally keep the item on their wishlist (for future purchases or reference).

This flow requires cross-domain coordination between the wishlist and sets domains, with atomic transaction semantics to prevent data loss. The complexity of this transaction logic is the primary reason this story was split from the simpler delete flow (WISH-2041).

## Goal

Enable users to transition purchased wishlist items to their Sets collection with purchase details, with optional wishlist retention and 5-second undo window.

## Non-goals

- Delete flow (handled in WISH-2041)
- Archive/restore functionality (deferred to WISH-201X)
- Email receipt generation (out of scope, requires email service)
- Analytics tracking of purchase actions (deferred to WISH-2009)
- Batch purchase of multiple items
- Purchase history or purchase tracking beyond Set creation
- Pre-filling all fields from wishlist (deferred to WISH-2005 for UX polish)
- Toast preview of new Set item (deferred to WISH-2005)

## Scope

### Backend (API)

**POST /api/wishlist/:id/purchased**
- Creates a Set item with purchase details
- Optionally deletes Wishlist item (based on `keepOnWishlist` flag)
- Returns `201 Created` with new Set item object
- Returns `404 Not Found` if wishlist item doesn't exist
- Returns `403 Forbidden` if user doesn't own item
- Uses `lego-api` hexagonal architecture:
  - Route: `apps/api/lego-api/domains/wishlist/routes.ts`
  - Service: `apps/api/lego-api/domains/wishlist/services.ts` (coordinates with sets service)
  - Repository: `apps/api/lego-api/domains/wishlist/repositories.ts`
  - Sets Service Dependency: Injected via dependency injection

**Request Body Schema:**
```typescript
{
  pricePaid?: number       // Optional, must be >= 0 if provided
  tax?: number             // Optional, must be >= 0 if provided
  shipping?: number        // Optional, must be >= 0 if provided
  quantity: number         // Default: 1, must be >= 1
  purchaseDate?: string    // ISO date, default: today, must be <= today
  keepOnWishlist: boolean  // Default: false
}
```

**Transaction Logic:**
1. Validate request body (Zod schema)
2. Fetch wishlist item (verify ownership)
3. **Create Set item** (with wishlist item reference for traceability)
4. **If `keepOnWishlist` is false**, delete Wishlist item
5. Return new Set item with 201 status
6. **Critical:** If Set creation fails, do NOT delete Wishlist item (prevent data loss)
7. **Rollback:** If Wishlist deletion fails after Set creation, log error but return success (Set already created)

**Image Handling Strategy:**
- **Approach:** Copy S3 object to new key scoped to Sets domain
- Wishlist image key: `wishlist/{userId}/{itemId}.jpg`
- Sets image key: `sets/{userId}/{setId}.jpg`
- Copy operation via S3 `copyObject` API
- Keep original wishlist image if `keepOnWishlist=true`
- Delete original wishlist image if `keepOnWishlist=false` (via S3 lifecycle or explicit delete)

### Frontend (React)

**GotItModal Component**
- Modal component from `@repo/app-component-library`
- Title: "Got It!"
- Form fields:
  - **Price Paid** (number input, optional, pre-filled from wishlist price if available)
  - **Tax** (number input, optional)
  - **Shipping** (number input, optional)
  - **Quantity** (number stepper, default: 1, min: 1)
  - **Purchase Date** (date picker, default: today, max: today)
  - **Keep on Wishlist** (checkbox, default: unchecked)
- Cancel button (secondary)
- "Got It!" button (primary, disabled during loading)
- Form validation: Zod schema matching backend
- Inline validation errors for invalid fields
- Loading states: "Creating set record...", "Moving from wishlist...", "Done!"
- Disable close button during operation (prevent accidental interruption)

**Quantity > 1 Enhancement:**
- If user sets quantity > 1, show option: "Re-add (quantity - 1) items to wishlist?"
- Example: User bought 3 sets → Create 1 Set with quantity=3, offer to re-add 2 items to wishlist
- Power user feature for collectors who buy multiples

**Toast Notifications**
- Success toast: "Item added to your collection"
- "Undo" action button (5-second window)
- Toast auto-dismisses after 5 seconds if no action
- Toast announced via `role="alert"` for screen readers
- Auto-focus undo button when toast appears
- ESC to dismiss toast

**Optional Navigation:**
- After successful purchase, optionally navigate to Sets Gallery
- User preference: "View in Sets" link in toast (non-intrusive)
- Default: Stay on wishlist page

**Undo Logic**
- Component-local state (not persisted)
- Restores wishlist item to RTK Query cache on undo
- Deletes Set item (via `DELETE /api/sets/:id`)
- Cleared on navigation away from page
- Prevents duplicate purchase requests during undo window

### RTK Query Integration

**Mutation:** `useMarkAsPurchasedMutation()`
- Maps to `POST /api/wishlist/:id/purchased`
- Optimistically updates cache (removes from wishlist if `keepOnWishlist=false`)
- Invalidates `useGetWishlistQuery` cache on success
- Invalidates `useGetSetsQuery` cache on success (new Set created)
- Keeps deleted wishlist item in cache for 5 seconds for undo
- Reverts optimistic update on undo action
- Shows error toast on failure

## Acceptance Criteria

- [ ] AC 2: POST `/api/wishlist/:id/purchased` endpoint creates Set and optionally deletes Wishlist item
- [ ] AC 4: "Got It" modal with form: price paid (pre-filled), tax, shipping, quantity, purchase date, "Keep on wishlist" checkbox
- [ ] AC 5: Purchase date defaults to today
- [ ] AC 6: "Got It" transaction is atomic: create Set first, then delete Wishlist (if checkbox unchecked)
- [ ] AC 7b: RTK Query mutation `useMarkAsPurchasedMutation` created
- [ ] AC 8b: Success toast displays "Item added to your collection" with 5-second undo button
- [ ] AC 9b: Undo button restores wishlist item and deletes set item
- [ ] AC 10: Optional navigation to Sets Gallery (non-intrusive "View in Sets" link in toast)
- [ ] AC 16: Form validation with Zod: price >= 0, tax >= 0, shipping >= 0, quantity >= 1, purchaseDate <= today
- [ ] AC 17: Loading states with progress messaging ("Creating set record...", etc.)
- [ ] AC 18: Modal is keyboard accessible (ESC to cancel, focus trap)
- [ ] AC 19: Toast announced via `role="alert"` for screen readers
- [ ] AC 20: Transaction rollback: If Set creation fails, Wishlist item NOT deleted
- [ ] AC 21: Image copied to Sets S3 key during purchase
- [ ] AC 22: Endpoint returns 403 if user doesn't own wishlist item
- [ ] AC 23: Endpoint returns 404 if wishlist item doesn't exist
- [ ] AC 24: Quantity > 1 offers to re-add surplus items to wishlist

## Reuse Plan

### From WISH-2041 (Delete Flow)
- Undo pattern with 5-second window
- Toast notification structure with action button
- Optimistic update patterns
- Modal keyboard accessibility patterns
- Authorization and error handling

### Existing Components
- `@repo/app-component-library` Modal for "Got It" form
- `@repo/app-component-library` Toast for notifications
- Form components: NumberInput, DatePicker, Checkbox, NumberStepper
- RTK Query mutation and cache invalidation patterns

### Services & Infrastructure
- `lego-api` hexagonal architecture (routes, services, repositories)
- Existing wishlist service (extend for purchase coordination)
- Sets service (dependency injection for cross-domain coordination)
- S3 service for image copying
- Database transaction patterns for atomic operations

## Architecture Notes

### Backend Architecture (`lego-api`)

```typescript
// apps/api/lego-api/domains/wishlist/services.ts
export interface WishlistService {
  // ... existing methods
  markAsPurchased(
    userId: string,
    itemId: string,
    purchaseData: MarkAsPurchasedInput
  ): Promise<SetItem>
}

export function createWishlistService(deps: WishlistServiceDeps): WishlistService {
  return {
    // ... existing methods
    async markAsPurchased(userId, itemId, purchaseData) {
      const item = await deps.wishlistRepository.getById(itemId)
      if (!item) throw new NotFoundError('Wishlist item not found')
      if (item.userId !== userId) throw new ForbiddenError('Not authorized')

      // Step 1: Create Set item (atomic)
      const setData = {
        userId,
        setNumber: item.setNumber,
        name: item.name,
        pricePaid: purchaseData.pricePaid,
        tax: purchaseData.tax,
        shipping: purchaseData.shipping,
        quantity: purchaseData.quantity,
        purchaseDate: purchaseData.purchaseDate || new Date().toISOString(),
        imageUrl: item.imageUrl, // Will be updated after S3 copy
        wishlistItemId: itemId // Reference for traceability
      }
      const newSet = await deps.setsService.createSet(setData)

      // Step 2: Copy image to Sets S3 key
      if (item.imageUrl) {
        const newImageUrl = await deps.s3Service.copyObject({
          sourceBucket: 'wishlist-images',
          sourceKey: item.imageUrl,
          destBucket: 'sets-images',
          destKey: `sets/${userId}/${newSet.id}.jpg`
        })
        await deps.setsRepository.updateImageUrl(newSet.id, newImageUrl)
      }

      // Step 3: Delete wishlist item if requested
      if (!purchaseData.keepOnWishlist) {
        try {
          await deps.wishlistRepository.delete(itemId)
          if (item.imageUrl) {
            await deps.s3Service.deleteObject({
              bucket: 'wishlist-images',
              key: item.imageUrl
            })
          }
        } catch (error) {
          // Log error but don't fail (Set already created)
          logger.error('Failed to delete wishlist item after purchase', { error, itemId })
        }
      }

      return newSet
    }
  }
}
```

```typescript
// apps/api/lego-api/domains/wishlist/routes.ts
app.post('/wishlist/:id/purchased', async (c) => {
  const userId = c.get('userId') // from auth middleware
  const itemId = c.req.param('id')
  const body = await c.req.json()
  const validated = MarkAsPurchasedInputSchema.parse(body)
  const newSet = await wishlistService.markAsPurchased(userId, itemId, validated)
  return c.json(newSet, 201)
})
```

### Frontend Architecture

```typescript
// RTK Query mutation
const [markAsPurchased, { isLoading }] = useMarkAsPurchasedMutation()

// Form submission with undo
const handleGotIt = async (formData: MarkAsPurchasedInput) => {
  const item = cache.getItem(itemId) // save for undo
  const newSet = await markAsPurchased({ itemId, ...formData }).unwrap()

  showToast({
    message: 'Item added to your collection',
    action: {
      label: 'Undo',
      onClick: () => undoPurchase(item, newSet.id)
    },
    links: [
      { label: 'View in Sets', href: '/sets' }
    ],
    duration: 5000
  })
}

const undoPurchase = async (item: WishlistItem, setId: string) => {
  await deleteSet(setId) // Delete the created Set
  restoreWishlistItem(item) // Restore to cache
}
```

### Error Handling
- 403 Forbidden → Toast: "You don't have permission to purchase this item"
- 404 Not Found → Toast: "Item not found or already purchased"
- 400 Bad Request (validation) → Inline form errors + Toast: "Please fix form errors"
- 500 Server Error → Toast: "Failed to process purchase. Please try again."
- Set creation fails → Wishlist item retained, error toast shown
- Wishlist deletion fails → Set created successfully, logged as warning (acceptable)

### Transaction Semantics

**Success Path:**
1. Create Set → Success
2. Copy S3 image → Success (best effort)
3. Delete Wishlist (if requested) → Success or Logged Warning

**Failure Paths:**
- Create Set fails → Return 500, Wishlist untouched
- Copy S3 image fails → Log warning, continue (Set has old URL)
- Delete Wishlist fails → Log warning, Set already created (acceptable)

**Data Loss Prevention:**
- **Never** delete Wishlist before Set creation succeeds
- Set creation is the critical operation (point of no return)
- Wishlist deletion is best-effort cleanup

## Test Plan

### Backend Tests (`apps/api/lego-api/domains/wishlist/__tests__/services.test.ts`)

**Happy Path:**
- ✓ Purchase creates Set with correct data
- ✓ Purchase with `keepOnWishlist=false` deletes Wishlist item
- ✓ Purchase with `keepOnWishlist=true` keeps Wishlist item
- ✓ POST endpoint returns 201 with Set item

**Transaction Logic:**
- ✓ Set creation failure does NOT delete Wishlist item (rollback)
- ✓ Wishlist deletion failure after Set creation logs warning (acceptable)
- ✓ Image copied to Sets S3 key during purchase
- ✓ Original image deleted if `keepOnWishlist=false`

**Authorization:**
- ✓ Purchase returns 403 if user doesn't own wishlist item
- ✓ Purchase verifies userId from auth token matches item owner

**Validation:**
- ✓ Price must be >= 0 (400 error if negative)
- ✓ Tax must be >= 0 (400 error if negative)
- ✓ Shipping must be >= 0 (400 error if negative)
- ✓ Quantity must be >= 1 (400 error if 0 or negative)
- ✓ Purchase date must be <= today (400 error if future date)

**Error Cases:**
- ✓ Purchase returns 404 if wishlist item doesn't exist
- ✓ Purchase handles Set service errors gracefully
- ✓ Purchase handles S3 errors gracefully (logs warning, continues)

**Edge Cases:**
- ✓ Purchase with quantity > 1 (verify Set quantity field)
- ✓ Purchase during concurrent operations (race condition)
- ✓ Purchase with invalid UUID format

### Frontend Tests (`apps/web/main-app/...`)

**Component Tests:**
- ✓ GotItModal renders with form fields
- ✓ Price pre-filled from wishlist item
- ✓ Purchase date defaults to today
- ✓ Quantity defaults to 1
- ✓ "Keep on wishlist" defaults to unchecked
- ✓ Cancel button closes modal without action
- ✓ "Got It!" button triggers mutation
- ✓ Form validation shows inline errors
- ✓ Modal is keyboard accessible (ESC, Tab, focus trap)
- ✓ Loading states display progress messages
- ✓ Close button disabled during operation

**Integration Tests:**
- ✓ Success toast appears after purchase
- ✓ Undo button restores wishlist item
- ✓ Undo button deletes Set item
- ✓ Item reappears in wishlist after undo (if deleted)
- ✓ Toast auto-dismisses after 5 seconds
- ✓ Undo window expires correctly
- ✓ Error toast shows on validation failure
- ✓ "View in Sets" link appears in toast

**Quantity > 1 Tests:**
- ✓ Quantity stepper increments/decrements
- ✓ If quantity > 1, "Re-add surplus" option appears
- ✓ Re-add option creates (quantity - 1) wishlist items

**Accessibility Tests:**
- ✓ Modal announced to screen readers
- ✓ Toast announced via live region
- ✓ Undo button keyboard accessible
- ✓ Form fields have proper labels and ARIA attributes
- ✓ ESC dismisses modal and toast

### E2E Tests (`apps/web/playwright/tests/wishlist-purchase.spec.ts`)

**User Flows:**
- ✓ User can open "Got It" modal from gallery
- ✓ User can open "Got It" modal from detail view
- ✓ Form fields pre-filled correctly
- ✓ User can fill in purchase details
- ✓ User can submit form
- ✓ Item disappears from wishlist (if "Keep on wishlist" unchecked)
- ✓ Item appears in Sets gallery
- ✓ User can undo purchase within 5 seconds
- ✓ Wishlist item reappears after undo
- ✓ Set item deleted after undo
- ✓ Item stays purchased after undo window expires
- ✓ "View in Sets" link navigates correctly

**Keep on Wishlist:**
- ✓ With checkbox checked, item stays in wishlist
- ✓ With checkbox unchecked, item removed from wishlist

**Validation Errors:**
- ✓ Negative price shows error
- ✓ Future date shows error
- ✓ Quantity < 1 shows error
- ✓ Form cannot submit with errors

**Error Scenarios:**
- ✓ 403 error shows appropriate message
- ✓ 404 error shows appropriate message
- ✓ Network error shows retry option

## Risks / Edge Cases

### Risk 1: Cross-Domain Transaction Failure
**Scenario:** Set creation succeeds but Wishlist deletion fails (database error, network issue).

**Mitigation:**
- Log error as warning (Set already created, data not lost)
- User sees success toast (Set created)
- Wishlist item remains (acceptable, user can manually delete)
- Consider background job to clean up orphaned wishlist items (future work)

### Risk 2: S3 Image Copy Failure
**Scenario:** Set creation succeeds but S3 image copy fails (permissions, quota, network).

**Mitigation:**
- Log error as warning (Set created without image)
- Set record contains old wishlist image URL (may work or may not)
- User can re-upload image to Set later
- Don't block purchase on image copy failure

### Risk 3: Undo Complexity
**Scenario:** User undoes purchase, but Set deletion fails (already shared, referenced elsewhere).

**Mitigation:**
- Show error toast: "Could not undo purchase. Please delete Set manually."
- Wishlist item still restored to cache (partial undo)
- Accept that undo is best-effort, not guaranteed

### Risk 4: Rapid Click During Flight
**Scenario:** User rapidly clicks "Got It!" button before first request completes.

**Mitigation:**
- Disable "Got It!" button during `isLoading` state
- Show loading spinner and progress messages
- Prevent modal from closing during flight

### Risk 5: Quantity > 1 Re-add Logic
**Scenario:** User bought 5 sets, wants to re-add 4 to wishlist, but re-add fails.

**Mitigation:**
- Re-add is optional enhancement, not critical
- If re-add fails, show error toast but purchase still succeeded
- User can manually re-add items if needed

### Risk 6: Concurrent Purchase
**Scenario:** User opens multiple tabs and purchases same item in both tabs simultaneously.

**Mitigation:**
- Backend idempotent: Second purchase returns 404 (item already deleted)
- Frontend shows "Item not found" toast (acceptable UX)
- Two Sets created (edge case, acceptable or de-duplicate in future)

### Risk 7: Browser Close During Transaction
**Scenario:** User closes browser during Set creation (before completion).

**Mitigation:**
- Backend transaction completes independently
- User may see partial state on next visit (Set exists, Wishlist may or may not)
- Acceptable edge case (data not lost, Set created)

## Definition of Done

- [ ] POST `/api/wishlist/:id/purchased` endpoint created using `lego-api` architecture
- [ ] Service method `markAsPurchased` implemented with cross-domain coordination
- [ ] Transaction logic atomic: Create Set before deleting Wishlist
- [ ] Rollback logic: Wishlist retained if Set creation fails
- [ ] Image copying to Sets S3 key implemented
- [ ] GotItModal component implemented with form validation
- [ ] Form validation with Zod schema matching backend
- [ ] Inline validation errors for invalid fields
- [ ] Loading states with progress messages
- [ ] Quantity > 1 re-add surplus option implemented
- [ ] Toast with undo action implemented
- [ ] Optional "View in Sets" link in toast
- [ ] RTK Query mutation `useMarkAsPurchasedMutation` created
- [ ] Undo logic: Restore wishlist item, delete Set item
- [ ] All backend tests passing (transaction, validation, authorization, rollback)
- [ ] All frontend tests passing (component, integration, a11y)
- [ ] E2E tests passing (purchase flow, undo flow, keep on wishlist)
- [ ] Keyboard navigation working (ESC, Tab, focus trap)
- [ ] Screen reader announcements working (`role="alert"`)
- [ ] Code reviewed and approved
- [ ] Ready for WISH-2005 (UX Polish)

## Dependencies

- **Depends On:**
  - WISH-2001 (Gallery MVP) - Provides gallery view and list display
  - WISH-2041 (Delete Flow) - Reuses undo pattern and modal structure
- **Unblocks:** WISH-2005a (Drag-and-drop) - Core purchase functionality required
- **Cross-Domain:** Sets service dependency (for Set creation)

## Token Budget

### Phase Summary

| Phase | Estimated | Actual | Delta | Notes |
|-------|-----------|--------|-------|-------|
| Story Gen | ~5k | — | — | Complex cross-domain logic |
| Elaboration | ~8k | — | — | Transaction semantics |
| Implementation | ~25k | — | — | Form + transaction + tests |
| Code Review | ~8k | — | — | Complex transaction review |
| **Total** | ~46k | — | — | Reduced from original ~70k |

### Actual Measurements

| Date | Phase | Before | After | Delta | Notes |
|------|-------|--------|-------|-------|-------|

## Agent Log

Append-only.

| Timestamp (America/Denver) | Agent | Action | Outputs |
|---|---|---|---|
| 2026-01-27 | pm-story-split-leader | Created split story from WISH-2004 | WISH-2042.md |
| 2026-01-27 | elab-completion-leader | Elaboration complete with 12 conditional ACs | ELAB-WISH-2042.md, updated story |

## QA Discovery Notes (for PM Review)

_Added by QA Elaboration on 2026-01-27_

### Gaps Identified - Converted to Acceptance Criteria

| # | Finding | User Decision | Notes |
|---|---------|---------------|-------|
| 1 | Architecture Mismatch: lego-api vs api-layer.md documentation conflict | Add as AC | **AC-25:** Team must clarify authoritative architecture before implementation - lego-api path pattern (domains/{domain}/application/services.ts) vs api-layer.md pattern (services/{domain}/) |
| 2 | Service Location Contradiction: Routes and services in wrong paths | Add as AC | **AC-26:** All path references in Architecture Notes (lines 194-270) must be verified against actual lego-api structure and corrected |
| 3 | Cross-Domain Coordination Anti-Pattern: Tight coupling between wishlist and sets services | Add as AC | **AC-27:** Implementation must use proper dependency injection or coordinator pattern, not direct service-to-service calls |
| 4 | S3 Service Abstraction Missing: Direct S3 operations bypass abstraction layer | Add as AC | **AC-28:** S3 service must be abstracted as port/adapter in wishlist domain, not called directly in services.ts |
| 5 | Transaction Semantics Unclear: Database transaction boundaries not defined | Add as AC | **AC-29:** Must specify: single DB transaction across both domains, or eventual consistency with compensation logic |
| 6 | Image Copy Strategy Incomplete: No handling for missing images | Add as AC | **AC-30:** Implementation must add conditional: if no imageUrl, create Set without image and skip S3 copy |
| 7 | Zod Schema Missing: MarkAsPurchasedInputSchema not defined | Add as AC | **AC-31:** Must define `MarkAsPurchasedInputSchema` in types with validation: pricePaid >= 0, tax >= 0, shipping >= 0, quantity >= 1, purchaseDate <= today |
| 8 | Architecture Notes Reference Wrong Paths: Incorrect service paths in examples | Add as AC | **AC-32:** All code examples (lines 194-270) must be verified and corrected to match actual implementation paths |
| 9 | Sets Service Type Mismatch: Parameter structure doesn't match actual Sets service | Add as AC | **AC-33:** Implementation must use correct Sets service signature: `createSet(userId: string, input: CreateSetInput)` - userId as first param, NOT embedded in data |
| 10 | DELETE /api/sets/:id Endpoint Missing: Undo functionality undefined | Add as AC | **AC-34:** Must verify Sets domain has DELETE endpoint and service method, or add to story scope before implementation |
| 11 | Frontend Architecture Missing Service Import: RTK Query endpoint location not specified | Add as AC | **AC-35:** Must specify: RTK Query endpoints defined in `packages/core/api-client/src/rtk/wishlist-gallery-api.ts` with proper imports |
| 12 | Decimal Handling Inconsistency: Number vs string type mismatch | Add as AC | **AC-36:** Must align types: either accept number inputs and convert to Decimal strings for Sets service, or document string format requirement |

### Enhancement Opportunities

None identified - story is feature-complete for MVP scope.

### Follow-up Stories Suggested

None - all requirements captured in this story with conditional ACs.

### Items Marked Out-of-Scope

None - all identified issues converted to ACs for this story.

## Conditional Pass Status

**Verdict: CONDITIONAL PASS** - Story approved for ready-to-work status pending team review of 12 architectural and type alignment acceptance criteria.

The story demonstrates strong requirements clarity and test coverage. However, 12 gaps identified during elaboration (primarily architectural and type mismatches) must be addressed during implementation to prevent code review rework. These gaps have been converted to acceptance criteria to ensure correctness.
