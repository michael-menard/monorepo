---
doc_type: story
title: "WISH-2032: Optimistic UI for Form Submission"
story_id: WISH-2032
story_prefix: WISH
status: in-progress
e2e_required: true
follow_up_from: WISH-2002
phase: 4
created_at: "2026-01-27T00:00:00-07:00"
updated_at: "2026-01-31T16:00:00-07:00"
depends_on: [WISH-2002]
estimated_points: 3
---

# WISH-2032: Optimistic UI for Form Submission

## Follow-up Context

**Parent Story:** WISH-2002: Add Item Flow
**Source:** QA Discovery Notes - Enhancements Integrated
**Original Finding:** Optimistic UI for form submission - show success toast and navigate immediately, with rollback if API call fails. Aligns with WISH-2005 patterns.
**Category:** Enhancement Opportunity
**Impact:** High - significantly improves perceived performance and user experience
**Effort:** Medium - requires careful state management and error recovery

## Context

In WISH-2002's implementation, users must wait for the API call to complete before receiving feedback or navigating to the detail page. For a typical POST request with image upload, this can take 2-5 seconds depending on network conditions.

Optimistic UI patterns assume the request will succeed and immediately:
- Show success feedback
- Update local cache
- Navigate to the detail page

If the request fails, the UI rolls back changes and shows an error. This creates a snappier, more responsive experience while maintaining correctness.

This pattern aligns with WISH-2005 (drag-and-drop reordering), which also uses optimistic updates for perceived performance improvements.

## Goal

Implement optimistic UI for wishlist item creation to provide immediate feedback and navigation, with graceful rollback on failure.

## Non-goals

- Not re-implementing the form validation from WISH-2002
- Not implementing optimistic updates for edit operations (edit is less latency-sensitive)
- Not implementing optimistic updates for delete operations (delete needs explicit confirmation)
- Not implementing offline support or request queuing
- Not implementing retry logic beyond RTK Query defaults

## Scope

**Components Affected:**
- `apps/web/app-wishlist-gallery/src/pages/AddItemPage.tsx`
- `apps/web/app-wishlist-gallery/src/components/WishlistForm.tsx`

**RTK Query Affected:**
- `packages/core/api-client/src/rtk/wishlist-api.ts` - `useAddToWishlistMutation`

**Packages Affected:**
- `apps/web/app-wishlist-gallery`
- `packages/core/api-client`

## Acceptance Criteria

- [ ] On form submit, immediately show success toast: "Item added to wishlist"
- [ ] Navigate to detail page immediately (before API response)
- [ ] Add temporary item to RTK Query cache with optimistic ID (e.g., `temp-${Date.now()}`)
- [ ] Detail page shows loading skeleton for temporary item
- [ ] When API responds with success, replace temporary item with real item (with real ID)
- [ ] When API responds with error, rollback: remove temporary item from cache, show error toast, return user to form
- [ ] Error toast includes "Retry" button to resubmit form
- [ ] Form state is preserved on rollback (user doesn't lose input)
- [ ] Cache invalidation triggers gallery refetch on success (same as WISH-2002)
- [ ] Optimistic update aligns with WISH-2005 reorder patterns for consistency

## Reuse Plan

- Builds on RTK Query mutation from WISH-2002
- Leverages existing cache invalidation logic from WISH-2002
- Aligns with optimistic update patterns from WISH-2005 (if implemented)
- Uses RTK Query's `onQueryStarted` hook for optimistic updates
- Reuses error handling and toast notifications from WISH-2002

## Architecture Notes

**Optimistic Update Flow:**
```typescript
// In wishlist-api.ts
async onQueryStarted(newItem, { dispatch, queryFulfilled, getState }) {
  // 1. Generate temporary ID
  const tempId = `temp-${Date.now()}`
  const optimisticItem = { ...newItem, id: tempId, createdAt: new Date().toISOString() }

  // 2. Optimistically add to cache
  const patchResult = dispatch(
    wishlistApi.util.updateQueryData('getWishlist', undefined, (draft) => {
      draft.items.unshift(optimisticItem)
    })
  )

  try {
    // 3. Wait for API response
    const { data: realItem } = await queryFulfilled

    // 4. Replace temporary item with real item
    dispatch(
      wishlistApi.util.updateQueryData('getWishlist', undefined, (draft) => {
        const index = draft.items.findIndex(item => item.id === tempId)
        if (index !== -1) draft.items[index] = realItem
      })
    )
  } catch (err) {
    // 5. Rollback on error
    patchResult.undo()
  }
}
```

**Navigation Strategy:**
```typescript
// In AddItemPage.tsx
const handleSubmit = async (formData) => {
  const tempId = `temp-${Date.now()}`

  // Navigate immediately with temp ID
  navigate(`/wishlist/${tempId}`)

  // Trigger mutation
  try {
    const result = await addToWishlist(formData).unwrap()
    // Replace temp ID in URL with real ID
    navigate(`/wishlist/${result.id}`, { replace: true })
  } catch (err) {
    // Rollback: return to form with error
    navigate('/wishlist/add', { state: { error: err.message, formData } })
  }
}
```

**Detail Page Loading Strategy:**
```typescript
// In ItemDetailPage.tsx
const { id } = useParams()
const isOptimisticId = id.startsWith('temp-')

if (isOptimisticId) {
  // Show loading skeleton while waiting for real ID
  return <DetailPageSkeleton />
}

const { data: item, isLoading } = useGetWishlistItemQuery(id)
```

## Test Plan

### Happy Path

1. User fills out add item form
2. User submits form
3. Success toast appears immediately: "Item added to wishlist"
4. User navigates to detail page with temp ID
5. Detail page shows loading skeleton
6. API responds with success (2s later)
7. Detail page updates with real item data
8. URL updates from temp ID to real ID
9. Gallery cache refreshes and shows new item

### Error Cases

1. **Network error**: API call fails, rollback removes temporary item, error toast shows "Failed to add item. Retry?"
2. **Validation error**: Server validation fails, rollback returns user to form with error message preserved
3. **Timeout**: API call times out (> 10s), rollback shows timeout error with retry button
4. **Duplicate item**: Server rejects duplicate, rollback shows specific error message

### Edge Cases

1. **User navigates away during optimistic update**: Rollback still occurs, user sees error toast on next visit
2. **Multiple rapid submissions**: Each submission gets unique temp ID; rollback only affects failed submission
3. **Concurrent gallery updates**: RTK Query cache merges optimistic update with real data correctly
4. **Offline mode**: Form submission shows immediate error (no offline support in this story)

## Risks / Edge Cases

1. **Race conditions**: If user edits temporary item before API responds, changes may be lost on rollback; mitigate by disabling edit until real ID received
2. **Cache consistency**: If gallery refetch happens before optimistic update, temporary item may appear twice; RTK Query should deduplicate
3. **Navigation history**: Using `replace: true` prevents back button from showing temp ID; verify in E2E tests
4. **Error recovery UX**: Users may not notice rollback if they've navigated away; ensure error toast is persistent

## Open Questions

None - all requirements are clear and non-blocking.
