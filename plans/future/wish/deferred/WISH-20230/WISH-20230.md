---
doc_type: story
title: "WISH-20230: Recurring schedules (cron-like syntax for automated recurring flag updates)"
story_id: WISH-20230
story_prefix: WISH
status: deferred
phase: 4
created_at: "2026-01-30T00:00:00Z"
updated_at: "2026-01-30T00:00:00Z"
depends_on: [WISH-2119]
follow_up_from: WISH-2119
estimated_points: 5
sizing_warning: false
---

# WISH-20230: Recurring schedules (cron-like syntax for automated recurring flag updates)

## Follow-up Context

**Parent Story:** WISH-2119 (Flag scheduling - one-time schedules)

**Source:** QA Discovery Notes - Enhancement Opportunity #1

**Original Finding:** "Recurring schedules (cron-like syntax) - Deferred to Phase 4+ follow-up story"

**Category:** Enhancement Opportunity

**Impact:** Medium (enables automated recurring flag operations without manual intervention)

**Effort:** Medium (cron expression parsing + recurring schedule generation + next execution calculation)

## Context

WISH-2119 implemented one-time flag scheduling (schedule a flag to enable/disable at a specific time). This was sufficient for MVP use cases like timed releases and single-event promotions.

However, many real-world scenarios require recurring schedules that repeat on a predictable cadence:
- **Weekly A/B tests**: Auto-enable experiment every Monday 9am, auto-disable Friday 5pm
- **Seasonal features**: Auto-enable winter theme Dec 1-Feb 28 every year
- **Maintenance windows**: Auto-disable features every Sunday 2am-4am for maintenance
- **Business hours restrictions**: Auto-enable features Monday-Friday 9am-5pm only
- **Monthly promotions**: Auto-enable discount features on 1st day of each month

Without recurring schedules, admins must manually create new schedules for each recurrence, leading to operational burden and risk of forgotten flag changes.

This story extends WISH-2119 with cron-like syntax for recurring schedules, automatic generation of next execution timestamps, and intelligent handling of missed executions.

## Goal

Enable recurring flag schedules with cron-like syntax to automate periodic flag updates without manual intervention, reducing operational burden and human error for recurring use cases.

## Non-goals

- **Custom DSL for schedules** (beyond cron syntax) - standard cron expressions only
- **Timezone-aware schedules** - UTC only in MVP, timezone support deferred to future story
- **Schedule dependencies** (run schedule B after schedule A completes) - defer to future story
- **Schedule templates** (pre-configured recurring patterns) - defer to future story
- **Schedule conflict detection** (warn if overlapping schedules exist) - defer to future story
- **Historical schedule execution logs** - CloudWatch logs only, no database persistence in MVP

## Scope

### Endpoints Affected

**Extended from WISH-2119:**
- `POST /api/admin/flags/:flagKey/schedule` - Add optional `recurrence` field with cron expression
- `GET /api/admin/flags/:flagKey/schedule` - Include `recurrence`, `nextExecutionAt` in response
- `DELETE /api/admin/flags/:flagKey/schedule/:scheduleId` - Cancel recurring schedule (stops future executions)

**New Endpoints:**
- `GET /api/admin/flags/:flagKey/schedule/:scheduleId/executions` - List past executions for recurring schedule

**Reused from WISH-2119:**
- Cron job (`process-flag-schedules.ts`) - Extended to generate next execution after recurring schedule applies
- Schedule repository - Extended to update `nextExecutionAt` after execution

### Packages Affected

1. **Backend - Config Domain**: `apps/api/lego-api/domains/config/`
   - `application/schedule-service.ts` - Add recurring schedule logic (extend existing)
   - `adapters/schedule-repository.ts` - Add `nextExecutionAt` updates (extend existing)
   - `routes.ts` - Add `recurrence` validation (extend existing)
   - `types.ts` - Add `RecurringScheduleSchema` (extend existing)
   - `utils/cron-parser.ts` - Cron expression parser (new)

2. **Backend - Cron Job**: `apps/api/lego-api/jobs/`
   - `process-flag-schedules.ts` - Generate next execution for recurring schedules (extend existing)

3. **Database Schema**: `packages/backend/database-schema/`
   - `src/schema/feature-flags.ts` - Add `recurrence`, `nextExecutionAt` columns (extend existing)
   - `src/migrations/app/` - Migration for recurring schedule columns (new)

4. **Shared Schemas**: `packages/core/api-client/src/schemas/`
   - `feature-flags.ts` - Add `RecurringScheduleSchema` (extend existing)

### Infrastructure Impact

**Database Schema Changes:**
```sql
ALTER TABLE feature_flag_schedules
  ADD COLUMN recurrence VARCHAR(100),  -- Cron expression (e.g., "0 9 * * 1" for every Monday 9am)
  ADD COLUMN nextExecutionAt TIMESTAMP WITH TIME ZONE;  -- Next scheduled execution time

CREATE INDEX idx_schedules_next_execution_at ON feature_flag_schedules(nextExecutionAt);
```

**Cron Expression Syntax (Standard 5-field):**
```
* * * * *
| | | | |
| | | | +-- Day of week (0-6, Sunday=0)
| | | +---- Month (1-12)
| | +------ Day of month (1-31)
| +-------- Hour (0-23)
+---------- Minute (0-59)
```

**Examples:**
- `0 9 * * 1` - Every Monday at 9:00 AM UTC
- `0 0 1 * *` - First day of every month at midnight UTC
- `0 2 * * 0` - Every Sunday at 2:00 AM UTC
- `0 9 * * 1-5` - Weekdays at 9:00 AM UTC
- `*/15 * * * *` - Every 15 minutes

**Cron Job Processing Logic:**
1. Query schedules WHERE `status = 'pending'` AND (`scheduledAt <= NOW()` OR `nextExecutionAt <= NOW()`)
2. For each schedule:
   - Apply flag update (same as WISH-2119)
   - If `recurrence` is NULL: Set status = 'applied' (one-time schedule)
   - If `recurrence` is NOT NULL: Calculate `nextExecutionAt` using cron parser, keep status = 'pending'
3. Row-level locking prevents concurrent processing (same as WISH-2119)

**npm Dependencies:**
- `cron-parser` (MIT license, 50KB) - Cron expression parsing and next execution calculation

## Acceptance Criteria

### Backend - Recurring Schedule Creation

**AC1**: Recurring schedule validation
- `POST /api/admin/flags/:flagKey/schedule` accepts optional `recurrence` field
- `recurrence` validated as valid cron expression (5 fields: `minute hour day month dayOfWeek`)
- Invalid cron expressions rejected with 400 Bad Request and error message
- Examples of valid expressions: `0 9 * * 1`, `0 0 1 * *`, `0 2 * * 0`
- Examples of invalid expressions: `invalid`, `0 0 0 0 0`, `60 25 32 13 8` (out of range)
- Zod schema: `RecurringScheduleRequestSchema` with custom cron validator

**AC2**: Recurring schedule database persistence
- Schedule with `recurrence` saved to database with `recurrence` and `nextExecutionAt` columns
- `nextExecutionAt` calculated from cron expression (next execution time after `scheduledAt`)
- One-time schedules (no `recurrence`) have `nextExecutionAt = NULL`
- Response includes `recurrence` and `nextExecutionAt` fields

**AC3**: List schedules includes recurring fields
- `GET /api/admin/flags/:flagKey/schedule` returns `recurrence` and `nextExecutionAt` for all schedules
- One-time schedules show `recurrence: null`, `nextExecutionAt: null`
- Recurring schedules show cron expression and calculated next execution time

### Backend - Cron Job Processing for Recurring Schedules

**AC4**: Cron job identifies recurring schedules
- Query selects schedules WHERE (`scheduledAt <= NOW()` OR `nextExecutionAt <= NOW()`) AND `status = 'pending'`
- Processes both one-time schedules (initial execution) and recurring schedules (next execution)
- Order by `nextExecutionAt` ASC (process earliest executions first)

**AC5**: Recurring schedule next execution calculation
- After applying flag update for recurring schedule:
  - Calculate `nextExecutionAt` using `cron-parser` library
  - Update schedule row with new `nextExecutionAt`
  - Keep `status = 'pending'` (do NOT set to 'applied')
  - Transaction ensures atomic flag update + nextExecutionAt update
- One-time schedules set `status = 'applied'` (existing WISH-2119 behavior)

**AC6**: Recurring schedule cancellation
- `DELETE /api/admin/flags/:flagKey/schedule/:scheduleId` cancels recurring schedule
- Status set to 'cancelled', future executions stopped
- Cannot cancel if schedule already cancelled (400 Bad Request)

**AC7**: Missed execution handling
- If cron job misses execution window (e.g., Lambda downtime), schedule executed on next cron run
- No duplicate executions - each recurrence executed at most once
- CloudWatch logs: "Missed execution window by X minutes" for late executions

### Cron Expression Parsing

**AC8**: Cron parser utility
- `utils/cron-parser.ts` wraps `cron-parser` library
- Function: `parseNextExecution(cronExpression: string, currentTime: Date): Date`
- Returns next execution timestamp after `currentTime`
- Throws error for invalid cron expressions (caught by validation layer)

**AC9**: Cron expression validation
- Validation function: `isCronExpressionValid(expression: string): boolean`
- Used by Zod schema custom validator
- Rejects malformed expressions, out-of-range values, unsupported syntax
- Edge case: Accepts `*` (wildcard), `/` (step values), `-` (ranges), `,` (lists)

### Schema & Types

**AC10**: Zod schemas for recurring schedules
- `RecurringScheduleRequestSchema`: Extends `CreateScheduleRequestSchema` with optional `recurrence` field
- `RecurringScheduleSchema`: Extends `ScheduleSchema` with `recurrence`, `nextExecutionAt` fields
- `RecurringScheduleResponseSchema`: API response format
- All types inferred from Zod: `type RecurringSchedule = z.infer<typeof RecurringScheduleSchema>`

**AC11**: Frontend/backend schema alignment
- Backend schemas defined in `apps/api/lego-api/domains/config/types.ts`
- Schemas re-exported in `packages/core/api-client/src/schemas/feature-flags.ts`
- Frontend imports from `@repo/api-client`
- Alignment test verifies schemas match

### Database & Migration

**AC12**: Database migration for recurring schedules
- Migration adds `recurrence` (VARCHAR 100) and `nextExecutionAt` (TIMESTAMP WITH TIME ZONE) columns
- Index on `nextExecutionAt` for fast cron job queries
- Existing one-time schedules have `recurrence = NULL`, `nextExecutionAt = NULL`
- Migration applied before deploying recurring schedule code

**AC13**: Retention policy for recurring schedules
- Recurring schedules remain `status = 'pending'` indefinitely (until cancelled)
- No automatic cleanup for recurring schedules (manual cancellation required)
- Cancelled recurring schedules retained for 90 days (audit trail)

### Testing

**AC14**: Backend unit tests (minimum 15 tests)
- Recurring schedule creation with valid cron expressions
- Invalid cron expression rejection
- Next execution calculation for various cron patterns (daily, weekly, monthly)
- Cron job processing: one-time vs recurring schedule handling
- Recurring schedule cancellation
- Missed execution handling
- Cron parser utility tests (edge cases: leap years, month boundaries, daylight saving time)

**AC15**: Backend integration tests (HTTP file)
- File: `__http__/feature-flag-recurring-schedules.http`
- Test: Create recurring schedule (assert 201, recurrence, nextExecutionAt)
- Test: List schedules includes recurring fields
- Test: Invoke cron job, assert nextExecutionAt updated after execution
- Test: Cancel recurring schedule (assert status = 'cancelled')
- Test: Invalid cron expression (assert 400 with error message)

**AC16**: Cron job integration tests
- Test: Create recurring schedule with past nextExecutionAt, invoke cron, assert flag updated and nextExecutionAt recalculated
- Test: Create one-time + recurring schedules, invoke cron, assert one-time marked 'applied', recurring remains 'pending'
- Test: Missed execution - create recurring schedule 5 minutes in past, invoke cron, assert executed and nextExecutionAt updated

## Reuse Plan

### Existing Components (Extended from WISH-2119)
- Schedule service (`application/schedule-service.ts`) - Add recurring schedule logic
- Schedule repository (`adapters/schedule-repository.ts`) - Add `nextExecutionAt` updates
- Cron job handler (`jobs/process-flag-schedules.ts`) - Extend to calculate next execution
- Auth middleware (`middleware/auth.ts`) - Reuse admin authorization checks
- Database client from `packages/backend/database-schema/`

### New Components
- `utils/cron-parser.ts` - Cron expression parser utility (wraps `cron-parser` library)

### Existing Patterns
- Hexagonal architecture (ports & adapters)
- Zod-first type definitions
- Hono routes with middleware
- CloudWatch structured logging
- PostgreSQL row-level locking

## Architecture Notes (Ports & Adapters)

### Hexagonal Architecture Compliance

**Domain Layer** (Business Logic):
- `application/schedule-service.ts` - Add recurring schedule validation and CRUD logic
  - Validate cron expressions using cron parser utility
  - Calculate initial `nextExecutionAt` on schedule creation
  - No HTTP or database coupling

**Adapter Layer** (Infrastructure):
- `adapters/schedule-repository.ts` - Add database operations for recurring schedules
  - Update `nextExecutionAt` after execution
  - Query schedules by `nextExecutionAt` for cron job

**Port Layer** (Contracts):
- `types.ts` - Define `RecurringSchedule` type and Zod schemas

**Utility Layer**:
- `utils/cron-parser.ts` - Pure function utility for cron parsing
  - No domain logic coupling
  - Wraps `cron-parser` library with type-safe interface

**No Architecture Violations:** Story extends existing config domain following WISH-2119 patterns.

## Test Plan

### Scope Summary
- **Endpoints:** 3 admin endpoints (extended from WISH-2119 with recurring fields)
- **UI Touched:** No (backend only)
- **Data/Storage:** Yes (feature_flag_schedules table: add recurrence, nextExecutionAt columns)
- **Infrastructure:** Cron job (extend existing), cron-parser library

### Happy Path Tests

1. **Create daily recurring schedule**: POST schedule with `recurrence: "0 9 * * *"`, assert 201, `nextExecutionAt` calculated
2. **Cron job processes recurring schedule**: Wait for cron execution, assert flag updated and `nextExecutionAt` recalculated to next day
3. **List schedules includes recurring fields**: GET schedules, assert `recurrence` and `nextExecutionAt` returned
4. **Cancel recurring schedule**: DELETE recurring schedule, assert `status = 'cancelled'`, future executions stopped

### Error Cases

1. **Invalid cron expression**: POST schedule with `recurrence: "invalid"`, assert 400 Bad Request with error message
2. **Out-of-range cron values**: POST schedule with `recurrence: "60 25 32 13 8"`, assert 400 Bad Request
3. **Cancel non-existent recurring schedule**: DELETE with invalid ID, assert 404 Not Found

### Edge Cases

1. **Weekly recurring schedule**: Create `recurrence: "0 9 * * 1"` (Monday 9am), assert nextExecutionAt is next Monday 9am UTC
2. **Monthly recurring schedule**: Create `recurrence: "0 0 1 * *"` (1st of month), assert nextExecutionAt is 1st of next month midnight UTC
3. **Missed execution window**: Create recurring schedule with nextExecutionAt 5 minutes in past, invoke cron, assert executed and nextExecutionAt updated
4. **One-time + recurring schedules**: Create both, invoke cron, assert one-time marked 'applied', recurring remains 'pending' with updated nextExecutionAt
5. **Cron expression with ranges**: Create `recurrence: "0 9 * * 1-5"` (weekdays), assert nextExecutionAt is next weekday 9am
6. **Cron expression with step values**: Create `recurrence: "*/15 * * * *"` (every 15 min), assert nextExecutionAt is 15 min from now

### Required Tooling Evidence

**Backend HTTP Tests (`__http__/feature-flag-recurring-schedules.http`):**
- Minimum 6 HTTP requests covering recurring schedule CRUD and error cases
- Assert status codes: 201, 200, 400, 404
- Assert recurring fields: `recurrence`, `nextExecutionAt`

**Backend Integration Tests:**
- Cron job recurring processing: Create recurring schedule, invoke cron, assert nextExecutionAt updated
- One-time vs recurring: Create both types, invoke cron, assert different status outcomes
- Missed executions: Create schedule in past, invoke cron, assert executed

**Frontend Tests:**
- N/A (no user-facing UI)

## UI/UX Notes

**Verdict:** SKIPPED - This story does not touch user-facing UI.

**Justification:** WISH-20230 extends backend infrastructure from WISH-2119 (admin API endpoints, cron job, database schema). No user-facing components or pages created. All endpoints require admin authentication.

**Future UI/UX:** Admin dashboard for recurring schedule management deferred to Phase 4+ (calendar view with recurring patterns, visual cron builder). Future UI may include recurring schedule templates and conflict warnings.

## Risks & Mitigations

### MVP-Critical Risks

1. **Cron expression parsing complexity**
   - Risk: Invalid cron expressions may crash cron job or produce incorrect next execution times
   - Mitigation: Use battle-tested `cron-parser` library (500k+ weekly downloads), comprehensive validation before persistence
   - Severity: Medium (validation layer prevents most issues)

2. **Daylight saving time edge cases**
   - Risk: DST transitions may cause missed executions or duplicate executions (UTC-only in MVP mitigates)
   - Mitigation: Use UTC timestamps only (no timezone conversion in MVP), document timezone support deferred
   - Severity: Low (UTC avoids DST issues)

3. **Infinite recurring schedules**
   - Risk: No end date for recurring schedules may lead to database bloat or forgotten schedules
   - Mitigation: Document admin best practice to cancel unused recurring schedules, defer automatic cleanup to future story
   - Severity: Low (admin coordination expected)

4. **Missed execution accumulation**
   - Risk: If cron job is down for extended period, backlog of missed executions may overwhelm system
   - Mitigation: Cron job processes next execution only (no backfill), log missed executions to CloudWatch
   - Severity: Medium (acceptable for MVP, defer backfill logic to future story)

5. **Cron expression validation gaps**
   - Risk: Some edge cases may not be caught by validation (e.g., Feb 30th in cron)
   - Mitigation: `cron-parser` library handles invalid dates gracefully (skips to next valid date)
   - Severity: Low (library handles edge cases)

## Open Questions

None - all decisions finalized for MVP scope.

## Definition of Done

- [ ] All 16 Acceptance Criteria pass
- [ ] Backend: 15+ unit tests pass (recurring schedule service, cron parser utility, cron job handler)
- [ ] Backend: HTTP integration tests pass (`.http` file with 6+ requests)
- [ ] Backend: Cron job integration tests pass (recurring processing, one-time vs recurring, missed executions)
- [ ] Database migration created and applied (add `recurrence`, `nextExecutionAt` columns)
- [ ] Cron job Lambda updated with recurring schedule logic
- [ ] npm dependency: `cron-parser` added to package.json
- [ ] Schema alignment test passes (frontend ↔ backend)
- [ ] TypeScript compilation passes
- [ ] ESLint passes
- [ ] Code review approved

## Follow-up Stories (Future)

### Phase 5+
- Timezone-aware recurring schedules (support non-UTC timezones)
- Schedule end dates (recurring schedules with expiration)
- Backfill missed executions (execute all missed occurrences when cron recovers)
- Recurring schedule templates (pre-configured patterns: daily, weekly, monthly)
- Schedule conflict detection (warn if overlapping schedules exist for same flag)

### Admin Dashboard
- Visual cron expression builder (UI to generate cron syntax)
- Recurring schedule calendar view (visualize recurring patterns)
- Historical execution logs (database persistence of past executions)

## Token Budget

### Phase Summary

| Phase | Estimated | Actual | Delta | Notes |
|-------|-----------|--------|-------|-------|
| Story Generation | ~15k | — | — | Follow-up story coordination + synthesis |
| Elaboration | ~12k | — | — | Cron parsing complexity + edge cases |
| Implementation | ~20k | — | — | Backend + cron logic + migration + tests |
| Code Review | ~6k | — | — | Infrastructure story |
| **Total** | ~53k | — | — | Medium-large story |

## Agent Log

| Timestamp (America/Denver) | Agent | Action | Outputs |
|---|---|---|---|
| 2026-01-30 00:00 | pm-story-followup-leader | Generated follow-up story from WISH-2119 finding #2 | WISH-20230.md |

---

## Source

Follow-up from QA Elaboration of WISH-2119 (Enhancement Opportunity #1)

**Original Finding:** "Recurring schedules (cron-like syntax) - Deferred to Phase 4+ follow-up story"

**Category:** Enhancement Opportunity

**Impact:** Medium (enables automated recurring flag operations without manual intervention)

**Effort:** Medium (cron expression parsing + recurring schedule generation + next execution calculation)

**Use Cases:**
- Weekly A/B tests (auto-enable every Monday 9am, auto-disable Friday 5pm)
- Seasonal features (auto-enable winter theme Dec 1-Feb 28 every year)
- Maintenance windows (auto-disable features every Sunday 2am-4am)
- Business hours restrictions (auto-enable features Monday-Friday 9am-5pm only)
- Monthly promotions (auto-enable discount features on 1st day of each month)

---
