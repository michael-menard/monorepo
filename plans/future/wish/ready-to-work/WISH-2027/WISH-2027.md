---
doc_type: story
title: "WISH-2027: Enum Modification Procedure for Wishlist Stores and Currencies"
story_id: WISH-2027
story_prefix: WISH
status: ready-to-work
phase: 1
follow_up_from: WISH-2007
created_at: "2026-01-28T15:00:00-07:00"
updated_at: "2026-01-29T10:35:00-07:00"
depends_on: [WISH-2007]
estimated_points: 2
---

# WISH-2027: Enum Modification Procedure for Wishlist Stores and Currencies

## Follow-up Context

**Parent Story:** WISH-2007
**Source:** QA Discovery Notes - Enhancement Opportunity #7
**Original Finding:** "Enum modification procedure documentation - PostgreSQL enums are immutable - document workaround for future stores/currencies"
**Category:** Enhancement Opportunity
**Impact:** High
**Effort:** Medium

This follow-up addresses a critical gap in the wishlist schema maintainability. PostgreSQL ENUMs (`wishlist_store`, `wishlist_currency`) are immutable once created. If we need to add new stores (e.g., "Amazon", "Target") or currencies (e.g., "JPY", "CNY") in the future, we cannot simply ALTER the enum. This story documents and validates the safe procedure for enum evolution.

## Context

WISH-2007 creates two PostgreSQL ENUMs for the wishlist feature:
- `wishlist_store`: LEGO, Barweer, Cata, BrickLink, Other
- `wishlist_currency`: USD, EUR, GBP, CAD, AUD

PostgreSQL ENUMs are **immutable by design** - you cannot remove values or reorder them after creation. While PostgreSQL 10+ allows adding values with `ALTER TYPE ... ADD VALUE`, this operation:
1. Cannot run inside a transaction (migration safety concern)
2. Cannot be rolled back (permanent schema change)
3. Requires table locks (downtime risk)

As the wishlist feature grows, we will inevitably need to:
- Add new stores (e.g., specialty LEGO retailers, marketplaces)
- Add new currencies (e.g., international expansion)
- Potentially deprecate or remove unused stores

Without a documented, tested procedure, future developers risk:
- Breaking production migrations
- Causing downtime with improper enum modifications
- Creating schema drift between environments
- Losing data during enum evolution

## Goal

Document, validate, and test a safe procedure for evolving PostgreSQL ENUMs in the wishlist schema. Provide runbooks for common enum modification scenarios (add store, add currency, deprecate store) with rollback plans and migration patterns.

## Non-goals

- Implementing automated enum migration tooling (future enhancement)
- Deciding which stores/currencies to add (product decision)
- Changing the current enum values in WISH-2007 (schema is correct as-is)
- Migrating to alternative enum storage strategies (e.g., lookup tables) - that's a separate architecture decision

## Scope

### Packages Affected
- `packages/backend/database-schema/` - Migration patterns and documentation
  - `docs/enum-evolution-guide.md` - New runbook
  - `docs/enum-migration-examples/` - Example migration scripts

### Deliverables

1. **Enum Evolution Runbook** (`docs/enum-evolution-guide.md`)
   - Safe procedure for adding enum values
   - Safe procedure for removing/deprecating enum values
   - Migration rollback strategies
   - Multi-environment coordination checklist
   - Known pitfalls and gotchas

2. **Example Migration Scripts** (`docs/enum-migration-examples/`)
   - `add-store-example.sql` - Add new store to enum
   - `add-currency-example.sql` - Add new currency to enum
   - `deprecate-store-example.sql` - Soft-delete approach (migrate to "Other")
   - `enum-to-table-migration.sql` - If we ever need to migrate away from enums

3. **Test Validation** (local environment only)
   - Verify example migrations run successfully
   - Verify rollback procedures work
   - Verify no data loss during enum evolution

## Acceptance Criteria

### Runbook Documentation (AC 1-5)
- [ ] AC 1: Enum Evolution Runbook exists at `packages/backend/database-schema/docs/enum-evolution-guide.md`
- [ ] AC 2: Runbook documents PostgreSQL enum immutability constraints and limitations
- [ ] AC 3: Runbook includes step-by-step procedure for adding enum values with `ALTER TYPE ... ADD VALUE`
- [ ] AC 4: Runbook documents rollback strategy for failed enum additions (spoiler: you can't, must plan alternative)
- [ ] AC 5: Runbook includes multi-environment coordination checklist (local → staging → production)

### Migration Examples (AC 6-9)
- [ ] AC 6: Example script `add-store-example.sql` demonstrates adding "Amazon" store to `wishlist_store` enum
- [ ] AC 7: Example script `add-currency-example.sql` demonstrates adding "JPY" currency to `wishlist_currency` enum
- [ ] AC 8: Example script `deprecate-store-example.sql` demonstrates migrating items from deprecated store to "Other"
- [ ] AC 9: Example script `enum-to-table-migration.sql` demonstrates fallback strategy if enums become unworkable

### Validation Testing (AC 10-13)
- [ ] AC 10: Test adding new store value in local dev environment (verify no errors, verify enum updated)
- [ ] AC 11: Test adding new currency value in local dev environment (verify no errors, verify enum updated)
- [ ] AC 12: Test deprecating store with data migration (move items to "Other", verify no data loss)
- [ ] AC 13: All example scripts execute successfully without manual intervention (copy-paste ready)

### Edge Case Coverage (AC 14-15)
- [ ] AC 14: Runbook documents behavior when adding enum value that already exists (idempotency)
- [ ] AC 15: Runbook documents transaction semantics (ALTER TYPE cannot run in transaction, but data migration can)

## Reuse Plan

### Existing Patterns
- **Migration structure**: Follow existing Drizzle migration patterns from migrations 0000-0007
- **Documentation format**: Use same markdown style as existing schema documentation
- **SQL dialect**: Aurora PostgreSQL 14+ (same as WISH-2007)

### PostgreSQL Native Features
- `ALTER TYPE ... ADD VALUE [BEFORE | AFTER]` - Add enum values (PostgreSQL 10+)
- `pg_enum` catalog table - Query existing enum values
- `CREATE TYPE ... AS ENUM` - Fallback for creating new enums if needed

### No New Packages Required
All documentation and examples use native PostgreSQL and existing Drizzle tooling.

## Architecture Notes

### PostgreSQL ENUM Limitations

**What You CAN Do:**
- Add new values to the end: `ALTER TYPE wishlist_store ADD VALUE 'Amazon'`
- Add values at specific positions: `ALTER TYPE wishlist_store ADD VALUE 'Amazon' AFTER 'BrickLink'`
- Query enum values: `SELECT enumlabel FROM pg_enum WHERE enumtypid = 'wishlist_store'::regtype`

**What You CANNOT Do:**
- Remove enum values (even if unused)
- Rename enum values
- Reorder existing values
- Run `ALTER TYPE ... ADD VALUE` inside a transaction
- Rollback an `ALTER TYPE ... ADD VALUE` operation

### Safe Enum Addition Pattern

```sql
-- Outside transaction: Add enum value
ALTER TYPE wishlist_store ADD VALUE IF NOT EXISTS 'Amazon';

-- Inside transaction: Migrate data if needed
BEGIN;
  UPDATE wishlist_items SET store = 'Amazon' WHERE source_url LIKE '%amazon.com%';
COMMIT;
```

### Enum Deprecation Pattern (Soft Delete)

```sql
-- Step 1: Migrate data from deprecated store to "Other"
BEGIN;
  UPDATE wishlist_items
  SET
    store = 'Other',
    notes = CONCAT(notes, '\n[Migrated from Barweer - store discontinued]')
  WHERE store = 'Barweer';
COMMIT;

-- Step 2: Document that 'Barweer' is deprecated (cannot remove from enum)
-- Add to schema documentation and code comments
```

### Fallback: Enum to Lookup Table Migration

If enums become unworkable (e.g., need to frequently add/remove stores), migrate to lookup tables:

```sql
-- Create lookup tables
CREATE TABLE wishlist_stores (
  code TEXT PRIMARY KEY,
  display_name TEXT NOT NULL,
  is_active BOOLEAN DEFAULT true,
  sort_order INTEGER
);

CREATE TABLE wishlist_currencies (
  code TEXT PRIMARY KEY,
  display_name TEXT NOT NULL,
  symbol TEXT,
  is_active BOOLEAN DEFAULT true
);

-- Migrate data
ALTER TABLE wishlist_items
  ALTER COLUMN store TYPE TEXT,
  ALTER COLUMN currency TYPE TEXT;

-- Drop old enums (requires no references)
DROP TYPE wishlist_store;
DROP TYPE wishlist_currency;
```

**Tradeoff**: Lookup tables are more flexible but lose database-level constraint enforcement.

## Test Plan

### Happy Path Tests

**Test 1: Add New Store Value**
- Start with WISH-2007 schema applied
- Run `add-store-example.sql` to add "Amazon"
- Query `pg_enum` to verify "Amazon" exists
- Insert test wishlist item with `store = 'Amazon'`
- Verify INSERT succeeds

**Test 2: Add New Currency Value**
- Start with WISH-2007 schema applied
- Run `add-currency-example.sql` to add "JPY"
- Query `pg_enum` to verify "JPY" exists
- Insert test wishlist item with `currency = 'JPY'`
- Verify INSERT succeeds

**Test 3: Idempotent Enum Addition**
- Run `add-store-example.sql` twice
- Verify second run does not fail (IF NOT EXISTS)
- Verify enum still has correct values

### Error Cases

**Error 1: Invalid Enum Value**
- Attempt to INSERT wishlist item with `store = 'InvalidStore'`
- Verify database rejects with enum constraint error
- Verify error message is clear

**Error 2: Adding Enum Value Inside Transaction**
- Wrap `ALTER TYPE ... ADD VALUE` in `BEGIN; ... COMMIT;`
- Verify PostgreSQL rejects operation with "cannot run inside a transaction" error

**Error 3: Removing Enum Value (Not Supported)**
- Attempt to run `ALTER TYPE wishlist_store DROP VALUE 'Other'`
- Verify PostgreSQL rejects with syntax error
- Verify runbook documents this limitation

### Edge Cases

**Edge 1: Deprecated Store with Existing Data**
- Insert 100 test items with `store = 'Barweer'`
- Run `deprecate-store-example.sql`
- Verify all 100 items migrated to `store = 'Other'`
- Verify no data loss (count unchanged)
- Verify notes column updated with migration message

**Edge 2: Enum Evolution Across Environments**
- Add "Amazon" store in local environment
- Export schema with `pg_dump`
- Verify schema includes "Amazon" in enum definition
- Document multi-environment sync procedure

### Manual Verification Queries

```sql
-- Verify enum values
SELECT enumlabel FROM pg_enum WHERE enumtypid = 'wishlist_store'::regtype ORDER BY enumsortorder;
SELECT enumlabel FROM pg_enum WHERE enumtypid = 'wishlist_currency'::regtype ORDER BY enumsortorder;

-- Count items by store (verify data migration)
SELECT store, COUNT(*) FROM wishlist_items GROUP BY store;

-- Verify no orphaned data
SELECT COUNT(*) FROM wishlist_items WHERE store NOT IN (
  SELECT enumlabel FROM pg_enum WHERE enumtypid = 'wishlist_store'::regtype
);
```

## Risk Notes

### MVP-Critical Risks

**Risk 1: Production Migration Cannot Be Rolled Back**
- Once `ALTER TYPE ... ADD VALUE` runs in production, it cannot be undone
- **Mitigation**: Require staging environment validation before production. Document in runbook.

**Risk 2: Multi-Environment Drift**
- If developer adds enum value locally but forgets to migrate staging/production, app code breaks
- **Mitigation**: Add enum value checks to migration pre-flight validation (future enhancement)

**Risk 3: Transaction Semantics Confusion**
- Developers may try to run enum addition in transaction and fail migration
- **Mitigation**: Clear documentation in runbook with examples

### Long-Term Risks (Non-MVP)

**Risk 4: Enum Bloat**
- Accumulating deprecated stores/currencies that cannot be removed
- **Mitigation**: Document when to consider migrating to lookup tables (e.g., > 20 enum values)

**Risk 5: Code Dependency Coupling**
- Frontend and backend both depend on enum values matching exactly
- **Mitigation**: Future story for shared enum validation (Zod schemas sync with database enums)

## Definition of Done

- [ ] Enum Evolution Runbook exists at `packages/backend/database-schema/docs/enum-evolution-guide.md`
- [ ] All 4 example migration scripts exist in `docs/enum-migration-examples/`
- [ ] All 15 Acceptance Criteria verified in local dev environment
- [ ] Example scripts tested and validated (no manual edits required)
- [ ] Runbook reviewed for clarity and completeness
- [ ] TypeScript compilation passes (no code changes, documentation only)
- [ ] Code review completed
- [ ] Story marked complete and linked from WISH-2007

## Open Questions

*None - all scenarios documented with fallback strategies*

## Token Budget

### Phase Summary

| Phase | Estimated | Actual | Delta | Notes |
|-------|-----------|--------|-------|-------|
| Follow-up Gen | ~3k | — | — | — |
| Documentation | ~4k | — | — | — |
| Validation | ~2k | — | — | — |
| Code Review | ~1k | — | — | — |
| **Total** | ~10k | — | — | — |

### Actual Measurements

| Date | Phase | Before | After | Delta | Notes |
|------|-------|--------|-------|-------|-------|

## Agent Log

Append-only.

| Timestamp (America/Denver) | Agent | Action | Outputs |
|---|---|---|---|
| 2026-01-28 15:00 | pm-story-followup-leader | Created follow-up story from WISH-2007 finding #2 | WISH-2027.md |
| 2026-01-29 10:30 | elab-completion-leader | Elaboration completed with PASS verdict | ELAB-WISH-2027.md |

---

## QA Discovery Notes (for PM Review)

_Added by QA Elaboration on 2026-01-29_

### Gaps Identified

| # | Finding | User Decision | Notes |
|---|---------|---------------|-------|
| — | None identified | — | Story comprehensively addresses enum evolution scenarios with fallback strategies. |

### Enhancement Opportunities

| # | Finding | User Decision | Notes |
|---|---------|---------------|-------|
| — | None required for MVP | — | Long-term enhancements (automated tooling, shared validation) documented as non-MVP. |

### Follow-up Stories Suggested

- [ ] Future: Automated enum migration validation tooling
- [ ] Future: Shared Zod schema validation between frontend/backend enums

### Items Marked Out-of-Scope

- Implementing automated enum migration tooling (future enhancement)
- Deciding which stores/currencies to add (product decision for future stories)
- Changing current enum values in WISH-2007 (schema correct as-is)
- Migrating to alternative enum storage strategies (separate architecture decision)
