---
doc_type: story
title: "WISH-2068: Browser Compatibility & Fallback for WebP"
story_id: WISH-2068
story_prefix: WISH
status: ready-to-work
split_from: WISH-2048
split_part: 2 of 2
phase: 4
created_at: "2026-01-31T10:00:00-07:00"
updated_at: "2026-01-31T17:00:00-07:00"
depends_on: [WISH-2058]
estimated_points: 1
---

# WISH-2068: Browser Compatibility & Fallback for WebP

## Split Context

This story is part of a split from WISH-2048 (WebP Format Conversion).

- **Original Story:** WISH-2048
- **Split Reason:** Story too large (14 ACs) with overlapping concerns between core WebP conversion and browser fallback logic
- **This Part:** 2 of 2 (Y=6) - Browser Compatibility & Fallback
- **Dependency:** Depends on WISH-2058 (Core WebP Conversion)
- **Sibling Story:** WISH-2058 (Core WebP Conversion) - must be completed first

## Follow-up Context

**Parent Story:** WISH-2022: Client-side Image Compression
**Source:** QA Discovery Notes - Enhancement Opportunities
**Category:** Enhancement Opportunity - Edge Case Handling
**Impact:** Low - covers edge case for Safari < 14 and IE11 (< 3% of users)
**Effort:** Low - browser detection and fallback logic

## Context

WISH-2058 implements core WebP conversion for modern browsers (Chrome, Firefox, Safari 14+, Edge). However, a small percentage of users may be on older browsers that don't support WebP format:
- Safari < 14 (macOS < Big Sur)
- Internet Explorer 11
- Some older mobile browsers

While these browsers represent less than 3% of users, we should provide a graceful fallback to JPEG compression (from WISH-2022) to ensure all users can upload images successfully.

**Split Scope:** This story focuses ONLY on browser compatibility detection and fallback logic. Core WebP conversion is handled by WISH-2058.

## Goal

Detect browsers without WebP support and provide graceful fallback to JPEG compression with clear user messaging.

## Non-goals

- Not re-implementing core WebP conversion (handled by WISH-2058)
- Not implementing lossless WebP compression (lossy is sufficient)
- Not implementing server-side browser detection (client-side only)
- Not implementing polyfills or shims for WebP support

## Scope

**Components Affected:**
- `apps/web/app-wishlist-gallery/src/utils/imageCompression.ts` - Add browser detection
- `apps/web/app-wishlist-gallery/src/utils/browserSupport.ts` - New utility for WebP detection

**Packages Affected:**
- `apps/web/app-wishlist-gallery`

**New Functions:**
- `detectWebPSupport()` - Check if browser supports WebP via canvas.toDataURL('image/webp')
- `getCompressionOptions()` - Return WebP or JPEG options based on browser support

## Acceptance Criteria

- [ ] AC9: Browser compatibility check: Warn users on browsers without WebP support (Safari < 14, IE11)
- [ ] AC10: Compression fallback: If WebP compression fails or browser doesn't support WebP, fall back to JPEG compression with distinct toast notification

**Implementation Details from ELAB:**

**AC9 (Preventive Check):**
- Run `detectWebPSupport()` before compression starts
- If unsupported: Show warning toast: "Your browser doesn't support WebP. Using JPEG instead."
- Use JPEG compression options from WISH-2022

**AC10 (Reactive Fallback):**
- If WebP compression throws error, catch and retry with JPEG options
- Show distinct toast: "Image compressed to JPEG: X MB → Y MB (WebP not supported)"
- Filename extension matches actual output format (.webp or .jpeg)

## Reuse Plan

- Builds on `imageCompression.ts` utility from WISH-2022 and WISH-2058
- Reuses JPEG compression options from WISH-2022 for fallback
- Reuses error handling and toast notification system from WISH-2022
- Leverages `canvas.toDataURL('image/webp')` for browser detection (standard approach)

## Architecture Notes

**Browser Detection:**
```typescript
// New utility function
export function detectWebPSupport(): boolean {
  const canvas = document.createElement('canvas')
  canvas.width = 1
  canvas.height = 1
  const dataURL = canvas.toDataURL('image/webp')
  return dataURL.startsWith('data:image/webp')
}
```

**Compression Options Selection:**
```typescript
// Updated imageCompression logic
export async function compressImage(file: File): Promise<File> {
  const supportsWebP = detectWebPSupport()

  const options = {
    maxSizeMB: 1,
    maxWidthOrHeight: 1920,
    useWebWorker: true,
    fileType: supportsWebP ? 'image/webp' : 'image/jpeg',
    initialQuality: 0.8
  }

  try {
    return await imageCompression(file, options)
  } catch (error) {
    // Fallback to JPEG if WebP compression fails
    if (supportsWebP) {
      return await imageCompression(file, { ...options, fileType: 'image/jpeg' })
    }
    throw error
  }
}
```

**Toast Notifications:**
- WebP success: "Image compressed to WebP: X MB → Y MB"
- JPEG fallback (preventive): "Your browser doesn't support WebP. Using JPEG instead."
- JPEG fallback (reactive): "Image compressed to JPEG: X MB → Y MB (WebP not supported)"

## Test Plan

### Happy Path

1. User on Safari 13 (no WebP support) selects high-resolution image (5MB)
2. `detectWebPSupport()` returns false
3. Warning toast shows: "Your browser doesn't support WebP. Using JPEG instead."
4. Compression starts with JPEG options
5. Compression completes: "Image compressed to JPEG: 5.2 MB → 0.8 MB (WebP not supported)"
6. Preview updates with JPEG image
7. User submits form
8. JPEG image uploads to S3 with `image/jpeg` MIME type

### Error Cases

1. **WebP compression fails**: If browser-image-compression throws error during WebP compression, catch and retry with JPEG options
2. **Detection fails**: If `detectWebPSupport()` throws error, assume no support and use JPEG

### Edge Cases

1. **False positive detection**: If browser reports WebP support but compression fails, fallback to JPEG
2. **User agent spoofing**: If browser user agent is spoofed, rely on runtime detection via canvas API
3. **Partial WebP support**: Some browsers support WebP for display but not encoding; handle via try/catch fallback

## Risks / Edge Cases

1. **Detection accuracy**: Canvas API detection is 99%+ accurate for WebP support
2. **User confusion**: Two different toast messages (preventive vs reactive) may confuse users; mitigate with clear messaging
3. **Performance**: Running browser detection on every compression adds ~1ms overhead; negligible

## Open Questions

None - all requirements are clear and non-blocking.

## QA Discovery Notes (for PM Review)

_Added by QA Elaboration on 2026-01-31_

### Gaps Identified

| # | Finding | User Decision | Notes |
|---|---------|---------------|-------|
| — | None identified | Not Reviewed | Story satisfies all core requirements with no MVP-blocking gaps. |

### Enhancement Opportunities

| # | Finding | User Decision | Notes |
|---|---------|---------------|-------|
| 1 | Test execution strategy | Skipped | Medium-severity finding. Deferred to post-MVP refinement. Implementer should explore mocking strategies during implementation. |
| 2 | Filename extension handling | Skipped | Medium-severity finding. Deferred to post-MVP refinement. Implementer should clarify with PM if filename must match output format. |

### Follow-up Stories Suggested

None at this time. Both deferred issues are implementation-time clarifications, not new stories.

### Items Marked Out-of-Scope

- WebP core conversion: Handled by WISH-2058 (dependency)
- Lossless WebP compression: Not required; lossy suffices
- Server-side browser detection: Client-side only per story scope
- WebP polyfills/shims: Not in scope; graceful degradation via fallback
