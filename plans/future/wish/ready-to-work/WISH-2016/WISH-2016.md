---
status: ready-to-work
follow_up_from: WISH-2013
created: 2026-01-28
updated_at: 2026-01-28
story_id: WISH-2016
title: Image Optimization - Automatic Resizing, Compression, and Watermarking
epic: Wishlist Feature
phase: 4 - Performance & UX Polish
priority: P2
depends_on: [WISH-2013]
complexity: Medium
effort: 3-5 points
---

# WISH-2016: Image Optimization - Automatic Resizing, Compression, and Watermarking

## Follow-up Context

**Parent Story:** WISH-2013 (File Upload Security Hardening)

**Source:** QA Discovery Notes - Follow-up Stories Suggested

**Original Finding:** "WISH-2016: Image Optimization - Automatic resizing, compression, watermarking (deferred to future story)"

**Category:** Enhancement Opportunity

**Impact:** Medium (Performance optimization, user experience improvement, storage cost reduction)

**Effort:** Medium (Image processing pipeline + Lambda layer + S3 events)

---

## Context

The wishlist feature's Add Item Flow (WISH-2002) and File Upload Security (WISH-2013) provide basic image upload functionality with security controls. However, uploaded images are stored and served at their original resolution and file size, which creates several challenges:

1. **Storage Costs:** High-resolution images (e.g., 10MB JPEG from modern phones) consume excessive S3 storage
2. **Bandwidth Costs:** Serving full-resolution images to frontend increases CloudFront egress costs
3. **Page Load Performance:** Large images slow down gallery view page load times
4. **Mobile Experience:** Mobile users pay data costs and experience slow loading for oversized images
5. **Image Attribution:** User-uploaded images lack watermarking for copyright protection

This story implements automatic image optimization to address these challenges:

1. **Automatic Resizing:** Generate multiple sizes (thumbnail, medium, large) for responsive display
2. **Compression:** Apply lossy compression (85% quality JPEG) to reduce file size without visible quality loss
3. **Format Conversion:** Convert uploaded images to optimized WebP format with JPEG fallback
4. **Watermarking:** Apply subtle watermark to large images for copyright protection
5. **Lazy Processing:** Image optimization happens asynchronously post-upload via S3 event triggers

### Background

**Current State (WISH-2013):**
- Images uploaded in original format and resolution
- No compression or optimization
- Single size stored and served
- No watermarking

**Performance Impact Without This Story:**
- 10MB image upload → 10MB stored in S3 → 10MB served to frontend
- Gallery view with 20 images → 200MB page load
- Mobile users on 4G → 30-60 second page load times
- S3 storage costs: ~$0.023/GB/month for original files
- CloudFront egress costs: ~$0.085/GB for first 10TB

**Cost Savings Estimate:**
- Thumbnail (200x200, 85% quality): ~20KB (99.8% reduction)
- Medium (800x800, 85% quality): ~100KB (99% reduction)
- Large (1600x1600, 85% quality): ~300KB (97% reduction)
- **Total storage reduction:** ~97% (from 10MB to 300KB per image)
- **Monthly cost savings:** ~$20-50/month for 1000 images (storage + egress)

**UX Improvement Estimate:**
- Gallery view page load: From 200MB → 2MB (100x faster on mobile)
- Image detail view: From 10MB → 300KB (33x faster)
- Thumbnail grid: From 20MB → 400KB (50x faster)

---

## Goal

Automatically optimize uploaded images to reduce storage costs, improve page load performance, and enhance mobile user experience. Provide multiple image sizes for responsive display and apply subtle watermarking for copyright protection.

---

## Non-goals

- **CDN Integration:** CloudFront or image CDN setup is out of scope (defer to WISH-2018)
- **Advanced Image Processing:** AI-based upscaling, background removal, or smart cropping is out of scope
- **Video Processing:** Video thumbnail generation or video optimization is out of scope
- **Real-time Processing:** Synchronous image optimization during upload is out of scope (async only)
- **Custom Watermark Upload:** User-uploaded watermark images is out of scope (use default logo)
- **Image Editing UI:** User-facing image editing tools (crop, rotate, filters) is out of scope

---

## Scope

### Packages Affected

- `apps/api/lego-api/domains/wishlist/` - Update image metadata with optimized URLs
- `apps/api/lego-api/core/image-processing/` - Image optimization service (new)
- `apps/api/lego-api/core/storage/` - S3 event trigger Lambda (new)
- `apps/web/app-wishlist-gallery/src/components/WishlistCard/` - Use responsive images
- `apps/web/app-wishlist-gallery/src/pages/` - Use optimized image sizes in detail view
- `packages/backend/database-schema/` - Add image_variants column to wishlist_items table
- Infrastructure: S3 event triggers, Lambda layer for Sharp image library

### Files to Create

1. **Image Processing Service:**
   - `apps/api/lego-api/core/image-processing/optimizer.ts` - Sharp integration for resize/compress
   - `apps/api/lego-api/core/image-processing/watermark.ts` - Watermark overlay logic
   - `apps/api/lego-api/core/image-processing/__tests__/optimizer.test.ts` - Unit tests
   - `apps/api/lego-api/core/image-processing/__tests__/watermark.test.ts` - Watermark tests

2. **S3 Event Handler:**
   - `apps/api/lego-api/functions/image-processor/handler.ts` - S3 event Lambda handler
   - `apps/api/lego-api/functions/image-processor/__tests__/handler.test.ts` - Integration tests

3. **Database Migration:**
   - `packages/backend/database-schema/src/migrations/app/000X_add_image_variants.sql` - Add image_variants column

4. **Infrastructure:**
   - Lambda layer configuration for Sharp library (~50MB)
   - S3 event trigger configuration (PUT events on `uploads/wishlist/*`)

### Files to Modify

1. **API Layer:**
   - `apps/api/lego-api/domains/wishlist/application/wishlist-service.ts` - Update image metadata after optimization
   - `apps/api/lego-api/domains/wishlist/repositories/wishlist-repository.ts` - Store image_variants JSON

2. **Database Schema:**
   - `packages/backend/database-schema/src/schema/index.ts` - Add image_variants column (JSONB type)

3. **Frontend Components:**
   - `apps/web/app-wishlist-gallery/src/components/WishlistCard/index.tsx` - Use srcset for responsive images
   - `apps/web/app-wishlist-gallery/src/pages/DetailPage.tsx` - Display optimized large image
   - `apps/web/app-wishlist-gallery/src/hooks/useWishlistItem.ts` - Handle image_variants metadata

4. **Test Infrastructure:**
   - `apps/web/app-wishlist-gallery/src/test/mocks/handlers.ts` - Add image_variants to mock responses

---

## Acceptance Criteria

### AC1: Automatic Image Resizing (Three Sizes)
**Given** a user uploads an image to the wishlist
**When** the upload completes and S3 triggers the image processor Lambda
**Then** the Lambda generates three resized versions:
  - Thumbnail: 200x200px (for gallery grid view)
  - Medium: 800x800px (for gallery card hover preview)
  - Large: 1600x1600px (for detail page view)
**And** all resized images maintain aspect ratio (no distortion)
**And** resized images are stored in S3 with key pattern: `uploads/wishlist/{userId}/{imageId}-{size}.webp`

### AC2: Image Compression (85% Quality)
**Given** the image processor generates resized images
**When** Sharp library encodes the images
**Then** all images are compressed at 85% quality (lossy compression)
**And** visual quality is indistinguishable from original for typical LEGO images
**And** file size is reduced by ~90-95% for typical uploads

### AC3: WebP Format Conversion with JPEG Fallback
**Given** the image processor generates optimized images
**When** Sharp library encodes the images
**Then** all images are saved in WebP format (better compression than JPEG)
**And** original JPEG is retained as fallback for browsers without WebP support
**And** frontend serves WebP with `<picture>` element fallback to JPEG

### AC4: Watermark Application (Large Size Only)
**Given** the image processor generates the large (1600x1600) version
**When** Sharp applies watermark overlay
**Then** a subtle watermark is applied to the bottom-right corner
**And** watermark uses default LEGO MOC platform logo (PNG with transparency)
**And** watermark is 10% opacity and 100px width
**And** watermark does not obscure LEGO set content (positioned with 20px margin)
**And** thumbnail and medium sizes do NOT have watermark (performance optimization)

### AC5: Database Schema Update (image_variants Column)
**Given** the wishlist_items table exists
**When** the migration runs
**Then** a new `image_variants` column is added (JSONB type, nullable)
**And** column stores JSON structure:
```json
{
  "original": {
    "url": "https://s3.../original.jpg",
    "width": 4032,
    "height": 3024,
    "sizeBytes": 10485760,
    "format": "jpeg"
  },
  "thumbnail": {
    "url": "https://s3.../thumb.webp",
    "width": 200,
    "height": 150,
    "sizeBytes": 18432,
    "format": "webp"
  },
  "medium": {
    "url": "https://s3.../medium.webp",
    "width": 800,
    "height": 600,
    "sizeBytes": 102400,
    "format": "webp"
  },
  "large": {
    "url": "https://s3.../large.webp",
    "width": 1600,
    "height": 1200,
    "sizeBytes": 307200,
    "format": "webp",
    "watermarked": true
  }
}
```

### AC6: S3 Event Trigger Configuration
**Given** S3 bucket is configured for wishlist uploads
**When** a file is uploaded to `uploads/wishlist/*` prefix
**Then** S3 triggers the image processor Lambda asynchronously
**And** event payload includes S3 bucket, object key, and file size
**And** Lambda processes the image within 30 seconds of upload

### AC7: Image Processor Lambda Performance
**Given** the image processor Lambda is invoked
**When** Sharp processes a typical 10MB JPEG image
**Then** processing completes within 10 seconds (including S3 download + upload)
**And** Lambda memory allocation is 1024MB (sufficient for Sharp operations)
**And** Lambda timeout is 30 seconds (handles worst-case large images)

### AC8: Frontend Responsive Image Display (Gallery Card)
**Given** the gallery view displays wishlist items
**When** the WishlistCard component renders
**Then** the component uses `<picture>` element with srcset:
```html
<picture>
  <source type="image/webp" srcset="thumbnail.webp" />
  <img src="thumbnail.jpg" alt="..." loading="lazy" />
</picture>
```
**And** browser loads WebP if supported, JPEG fallback otherwise
**And** lazy loading defers off-screen images

### AC9: Frontend Optimized Image Display (Detail Page)
**Given** the detail page displays a wishlist item
**When** the DetailPage component renders
**Then** the component uses large image variant (1600x1600)
**And** displays WebP with JPEG fallback via `<picture>` element
**And** watermark is visible in bottom-right corner

### AC10: Fallback for Legacy Items (No image_variants)
**Given** a wishlist item was created before WISH-2016 (no image_variants)
**When** the frontend fetches the item
**Then** the component falls back to original image URL
**And** displays warning in browser console: "Image variants not available for item {id}"
**And** user experience is not broken (shows original image)

### AC11: Image Processing Failure Handling
**Given** the image processor Lambda fails (e.g., Sharp error, out of memory)
**When** the failure is logged to CloudWatch
**Then** the error includes structured metadata: {userId, imageId, errorType, s3Key}
**And** original image remains accessible (no data loss)
**And** retry mechanism attempts processing 3 times with exponential backoff
**And** if all retries fail, alert is triggered for manual investigation

### AC12: Image Processing Test Coverage (Unit Tests)
**Given** Sharp image optimization logic exists
**When** unit tests run for optimizer.ts
**Then** tests verify:
  - Resizing to exact dimensions (200x200, 800x800, 1600x1600)
  - Aspect ratio preservation (no distortion)
  - Compression quality (85% setting applied)
  - WebP format output
  - Watermark overlay positioning and transparency
**And** 20+ unit tests cover all edge cases (portrait, landscape, square)

### AC13: Image Processing Test Coverage (Integration Tests)
**Given** S3 event handler Lambda exists
**When** integration tests run for handler.ts
**Then** tests verify:
  - S3 event parsing and file download
  - Sharp processing for all three sizes
  - S3 upload of optimized images
  - Database update with image_variants JSON
  - Error handling and retry logic
**And** 15+ integration tests use MSW mocks for S3 operations

### AC14: Storage Cost Monitoring (CloudWatch Metrics)
**Given** image optimization is running in production
**When** images are processed
**Then** custom CloudWatch metrics are emitted:
  - `ImageProcessing.OriginalSizeBytes` (histogram)
  - `ImageProcessing.OptimizedSizeBytes` (histogram)
  - `ImageProcessing.CompressionRatio` (percentage)
  - `ImageProcessing.ProcessingDuration` (milliseconds)
**And** metrics are tagged by {size: thumbnail/medium/large}
**And** CloudWatch dashboard displays cost savings trends

### AC15: Documentation Updates
**Given** new image optimization infrastructure is implemented
**When** developers need to understand image processing
**Then** documentation includes:
  - Image size specifications (200x200, 800x800, 1600x1600)
  - Sharp library usage and configuration
  - Watermark positioning and opacity settings
  - S3 event trigger architecture diagram
  - Frontend responsive image usage examples
  - Cost savings analysis and monitoring guide

---

## Test Plan

*Comprehensive test coverage for image processing pipeline.*

### Happy Path Tests:

1. **Portrait Image (3024x4032 JPEG):**
   - Upload portrait LEGO set photo
   - Verify thumbnail: 150x200 (aspect ratio preserved)
   - Verify medium: 600x800 (aspect ratio preserved)
   - Verify large: 1200x1600 (aspect ratio preserved)
   - Verify watermark on large version only
   - Verify all variants are WebP format

2. **Landscape Image (4032x3024 JPEG):**
   - Upload landscape LEGO set photo
   - Verify thumbnail: 200x150
   - Verify medium: 800x600
   - Verify large: 1600x1200
   - Verify aspect ratio preservation

3. **Square Image (3024x3024 JPEG):**
   - Upload square LEGO set photo
   - Verify thumbnail: 200x200
   - Verify medium: 800x800
   - Verify large: 1600x1600
   - Verify no distortion

4. **Small Image (640x480 JPEG):**
   - Upload small image (already below large size)
   - Verify thumbnail: 200x150 (downscaled)
   - Verify medium: 640x480 (original size, no upscaling)
   - Verify large: 640x480 (original size, no upscaling)

### Error Cases:

1. **Sharp Processing Failure (Out of Memory):**
   - Simulate 50MB image upload
   - Lambda runs out of memory during processing
   - Verify error logged to CloudWatch
   - Verify retry mechanism triggers (3 attempts)
   - Verify alert sent to operations team

2. **S3 Upload Failure (Network Error):**
   - Simulate S3 upload timeout for optimized images
   - Verify retry with exponential backoff
   - Verify original image remains accessible

3. **Invalid Image Format (Corrupt File):**
   - Upload corrupt JPEG (passes MIME validation but Sharp cannot decode)
   - Verify Sharp error is caught
   - Verify original image remains in S3
   - Verify error logged with structured metadata

4. **Watermark File Missing:**
   - Simulate missing watermark logo file
   - Verify graceful degradation (large image generated without watermark)
   - Verify warning logged to CloudWatch

### Edge Cases:

1. **Very Large Image (50MB JPEG, 12000x9000):**
   - Upload high-resolution DSLR photo
   - Verify Lambda completes within 30-second timeout
   - Verify 1024MB memory allocation is sufficient
   - If processing exceeds limits, verify retry with 2048MB memory

2. **Already-Optimized Image (1KB PNG):**
   - Upload tiny image (e.g., icon)
   - Verify processing completes successfully
   - Verify file size does not increase after compression

3. **Monochrome Image (Grayscale JPEG):**
   - Upload black-and-white LEGO instructions scan
   - Verify compression works correctly
   - Verify watermark is visible on grayscale background

4. **Transparent PNG:**
   - Upload PNG with transparency (e.g., LEGO brick on transparent background)
   - Verify WebP conversion preserves transparency
   - Verify watermark overlay works with transparent background

5. **Concurrent Processing (10 Images Uploaded Simultaneously):**
   - Upload 10 images in rapid succession
   - Verify all S3 events trigger Lambda invocations
   - Verify no race conditions or database conflicts
   - Verify all 10 images are processed successfully

### Required Evidence:

- 20+ unit tests for image optimization logic (Sharp operations)
- 15+ integration tests for S3 event handler Lambda
- Manual testing in staging environment with real LEGO images
- CloudWatch metrics verify 90%+ compression ratio
- Frontend displays responsive images correctly in gallery and detail views
- Watermark is visible and correctly positioned in large images
- Cost savings dashboard shows storage reduction trends

---

## Reuse Plan

### Reuse from WISH-2013 (File Upload Security)

1. **S3 Infrastructure:**
   - Reuse S3 bucket and IAM policies from WISH-2013
   - Add S3 event trigger configuration to existing bucket
   - No changes to presigned URL flow

2. **Test Infrastructure:**
   - Extend MSW handlers for S3 operations (download optimized images)
   - Reuse test fixtures for sample images

### Reuse from WISH-2002 (Add Item Flow)

1. **Upload Flow:**
   - No changes to client-side upload logic (optimization is post-upload)
   - Extend database schema with image_variants column
   - Update API response to include image_variants metadata

### Reusable Components for Future Stories

1. **Image Optimization Service:**
   - `optimizer.ts` can be reused for gallery image uploads (WISH-2018)
   - `watermark.ts` can be reused for MOC instructions cover images
   - Sharp utilities can be reused for any image processing feature

2. **S3 Event Handler Pattern:**
   - Lambda event handler pattern can be reused for other S3 triggers (e.g., virus scanning result processing)
   - Retry logic and error handling can be reused for other async workflows

3. **Responsive Image Component Pattern:**
   - `<picture>` element with srcset can be reused across all image displays in platform
   - WebP with JPEG fallback pattern is best practice for all images

---

## Architecture Notes

### Hexagonal Architecture (Ports & Adapters)

**Ports (Interfaces):**

1. **Image Optimizer Port:**
   ```typescript
   export interface ImageOptimizer {
     resize(input: Buffer, width: number, height: number): Promise<Buffer>
     compress(input: Buffer, quality: number): Promise<Buffer>
     convertToWebP(input: Buffer): Promise<Buffer>
     applyWatermark(input: Buffer, watermark: Buffer, options: WatermarkOptions): Promise<Buffer>
   }

   export interface WatermarkOptions {
     position: 'bottom-right' | 'bottom-left' | 'top-right' | 'top-left'
     opacity: number // 0.0 to 1.0
     margin: number // pixels
     width: number // pixels
   }
   ```

2. **Image Variants Storage Port:**
   ```typescript
   export interface ImageVariantsStorage {
     storeVariant(variant: ImageVariant): Promise<string> // returns S3 URL
     getVariants(imageId: string): Promise<ImageVariants>
   }

   export interface ImageVariant {
     size: 'thumbnail' | 'medium' | 'large'
     buffer: Buffer
     format: 'webp' | 'jpeg'
     width: number
     height: number
   }

   export interface ImageVariants {
     original: ImageMetadata
     thumbnail: ImageMetadata
     medium: ImageMetadata
     large: ImageMetadata
   }
   ```

**Adapters (Implementations):**

1. **Sharp Image Optimizer Adapter:**
   - Integrates with Sharp library (Node.js image processing)
   - Implements `ImageOptimizer` port
   - Handles resize, compress, format conversion, watermark overlay

2. **S3 Image Variants Storage Adapter:**
   - Implements `ImageVariantsStorage` port
   - Uploads optimized images to S3 with key pattern: `uploads/wishlist/{userId}/{imageId}-{size}.webp`
   - Generates pre-signed URLs for frontend consumption

### Image Processing Flow

```
1. User uploads image (WISH-2002 flow)
   ↓
2. Image stored in S3 as original (WISH-2013 flow with security)
   ↓
3. S3 triggers image processor Lambda (S3 event: s3:ObjectCreated:Put)
   ↓
4. Lambda downloads original image from S3
   ↓
5. Sharp generates three resized versions (thumbnail, medium, large)
   ↓
6. Sharp compresses all versions at 85% quality
   ↓
7. Sharp converts all versions to WebP format
   ↓
8. Sharp applies watermark to large version only
   ↓
9. Lambda uploads optimized images to S3 (3 files)
   ↓
10. Lambda updates database with image_variants JSON
   ↓
11. Frontend fetches wishlist item with image_variants
   ↓
12. Frontend displays responsive images using <picture> element
```

### Sharp Library Integration

**Why Sharp?**
- **Performance:** 5-10x faster than ImageMagick or GraphicsMagick (uses libvips)
- **Memory Efficiency:** Streaming-based processing, low memory footprint
- **Format Support:** JPEG, PNG, WebP, AVIF, SVG, TIFF, GIF
- **Lambda Compatible:** Works in AWS Lambda with Node.js runtime
- **Battle-Tested:** Used by Vercel, Cloudflare, and many high-scale image services

**Sharp Lambda Layer:**
- Layer size: ~50MB (Sharp binary + libvips dependencies)
- Node.js 18.x or later required
- Precompiled for Lambda Amazon Linux 2 runtime

**Alternative Considered (ImageMagick):**
- Pros: More feature-rich, widely known
- Cons: Slower performance, larger memory footprint, harder to deploy on Lambda
- Decision: Sharp chosen for performance and Lambda compatibility

---

## Infrastructure Notes

### S3 Event Trigger Configuration

```yaml
# S3 Bucket Event Notification
Bucket: lego-moc-wishlist-uploads
Events:
  - s3:ObjectCreated:Put
Filter:
  Prefix: uploads/wishlist/
  Suffix: "" # All file types (JPEG, PNG, WebP)
Destination:
  Type: Lambda
  FunctionArn: arn:aws:lambda:us-east-1:ACCOUNT_ID:function:wishlist-image-processor
```

### Lambda Function Configuration

```yaml
FunctionName: wishlist-image-processor
Runtime: nodejs18.x
Handler: handler.processImage
MemorySize: 1024 # MB (sufficient for Sharp processing)
Timeout: 30 # seconds
Layers:
  - arn:aws:lambda:us-east-1:ACCOUNT_ID:layer:sharp:1 # Sharp library (~50MB)
Environment:
  S3_BUCKET: lego-moc-wishlist-uploads
  WATERMARK_S3_KEY: assets/watermark-logo.png
  COMPRESSION_QUALITY: 85
  THUMBNAIL_SIZE: 200
  MEDIUM_SIZE: 800
  LARGE_SIZE: 1600
ReservedConcurrentExecutions: 10 # Limit concurrent invocations to control costs
```

### IAM Policy (Image Processor Lambda)

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "ImageProcessorS3Access",
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject"
      ],
      "Resource": "arn:aws:s3:::lego-moc-wishlist-uploads/uploads/wishlist/*"
    },
    {
      "Sid": "WatermarkAccess",
      "Effect": "Allow",
      "Action": "s3:GetObject",
      "Resource": "arn:aws:s3:::lego-moc-wishlist-uploads/assets/watermark-logo.png"
    }
  ]
}
```

### Database Migration (image_variants Column)

```sql
-- Migration: Add image_variants column to wishlist_items table
ALTER TABLE wishlist_items
  ADD COLUMN image_variants JSONB;

-- Index for querying image variants (optional, for analytics)
CREATE INDEX idx_wishlist_items_image_variants
  ON wishlist_items USING GIN (image_variants);

-- Add comment for documentation
COMMENT ON COLUMN wishlist_items.image_variants IS
  'JSON structure storing original and optimized image URLs with metadata (thumbnail, medium, large)';
```

---

## HTTP Contract Plan

### No New Endpoints Created

This story enhances existing wishlist endpoints with image_variants metadata. No new HTTP routes.

### Enhanced GET /api/wishlist Endpoint

**Response Changes:**

```json
// Before (WISH-2002)
{
  "items": [
    {
      "id": "abc123",
      "title": "LEGO Technic Bugatti",
      "imageUrl": "https://s3.../original.jpg",
      ...
    }
  ]
}

// After (WISH-2016)
{
  "items": [
    {
      "id": "abc123",
      "title": "LEGO Technic Bugatti",
      "imageUrl": "https://s3.../original.jpg", // DEPRECATED but kept for backward compatibility
      "imageVariants": {
        "original": {
          "url": "https://s3.../original.jpg",
          "width": 4032,
          "height": 3024,
          "sizeBytes": 10485760,
          "format": "jpeg"
        },
        "thumbnail": {
          "url": "https://s3.../thumb.webp",
          "width": 200,
          "height": 150,
          "sizeBytes": 18432,
          "format": "webp"
        },
        "medium": {
          "url": "https://s3.../medium.webp",
          "width": 800,
          "height": 600,
          "sizeBytes": 102400,
          "format": "webp"
        },
        "large": {
          "url": "https://s3.../large.webp",
          "width": 1600,
          "height": 1200,
          "sizeBytes": 307200,
          "format": "webp",
          "watermarked": true
        }
      },
      ...
    }
  ]
}
```

**Contract Compatibility:**
- Fully backward compatible
- Legacy clients can continue using `imageUrl` (original image)
- New clients should prefer `imageVariants.thumbnail` for gallery view
- `imageVariants` will be `null` for items created before WISH-2016 (graceful degradation)

---

## Seed Requirements

**Not applicable.** Image optimization does not require database seeds.

**Watermark Asset:**
- Default watermark logo: `assets/watermark-logo.png` (stored in S3)
- Logo: LEGO MOC platform logo (PNG with transparency)
- Size: 100px width, variable height (maintains aspect ratio)
- Format: PNG with alpha channel

---

## UI/UX Notes

### User-Facing Changes

1. **Gallery View (WishlistCard):**
   - Use thumbnail image variant (200x200, ~20KB) for grid display
   - Implement lazy loading for off-screen images
   - Display loading placeholder (skeleton) while image loads
   - WebP format with JPEG fallback for browser compatibility

2. **Detail Page:**
   - Use large image variant (1600x1600, ~300KB) for main display
   - Display watermark in bottom-right corner (visible but subtle)
   - Provide "View Original" link to download full-resolution image

3. **Upload Success Message:**
   - Toast notification: "Image uploaded successfully. Optimizing in background..."
   - Show original image immediately (before optimization completes)
   - Update with optimized images when processing finishes (no page reload)

4. **Loading States:**
   - Gallery: Skeleton placeholder while thumbnail loads
   - Detail page: Blur-up effect (load thumbnail first, then large image)
   - Progress indicator if optimization takes > 10 seconds

### Accessibility Considerations

- Alt text for all images (user-provided title or description)
- Lazy loading does not break keyboard navigation
- Screen reader announcements for image loading states via `aria-live="polite"`
- Focus management maintained during image load/update

### No Design System Changes

This story uses existing image components from `@repo/ui`. Enhance `<picture>` element with srcset support for responsive images.

---

## Dependencies

### Blocked By:

- **WISH-2013** (File Upload Security Hardening) - Required for S3 infrastructure and upload flow to exist
  - S3 bucket and IAM policies must be in place before event triggers can be added

### Blocks:

- **WISH-2018** (CDN Integration) - CDN will serve optimized images generated by this story
- Future image-heavy features (MOC instructions cover images, gallery uploads)

### Internal Package Dependencies:

- `@repo/api-client` - Zod schemas for image_variants metadata
- `@repo/logger` - CloudWatch logging for processing events
- `packages/backend/database-schema` - Migration for image_variants column

### External Dependencies:

- **Sharp Lambda Layer:** Required for image processing
  - Source: Build custom layer or use community layer (https://github.com/Umkus/lambda-layer-sharp)
  - Size: ~50MB
  - Node.js 18.x or later required

---

## Risks & Mitigations

### Risk 1: Sharp Lambda Layer Increases Cold Start Time

**Description:** Sharp Lambda layer adds ~50MB to deployment package, potentially increasing Lambda cold start time from ~1s to ~2s.

**Likelihood:** High
**Impact:** Low (User does not see cold start impact, processing is async)

**Mitigation:**
- Processing happens asynchronously post-upload (no user-facing latency)
- Use provisioned concurrency (1 instance) if cold start monitoring shows degradation
- Monitor cold start metrics in CloudWatch

---

### Risk 2: Lambda Timeout for Very Large Images

**Description:** Processing 50MB images may exceed 30-second Lambda timeout, causing incomplete optimization.

**Likelihood:** Medium
**Impact:** Medium (Original image remains accessible, but no optimization)

**Mitigation:**
- Set Lambda timeout to 30 seconds (handles most images < 20MB)
- Implement retry with increased memory (2048MB) if first attempt fails
- Log timeout events for analysis
- If timeout rate > 5%, increase timeout to 60 seconds or split processing into separate Lambda invocations

---

### Risk 3: Storage Costs Increase Temporarily

**Description:** Storing 4 image variants (original + thumbnail + medium + large) increases storage costs during transition period.

**Likelihood:** High
**Impact:** Low (Net cost reduction after original images are deleted)

**Mitigation:**
- Implement S3 lifecycle policy to delete original images after 90 days (once optimization is proven stable)
- Monitor storage costs in CloudWatch
- Net storage reduction is ~97% after original images are deleted
- Temporary cost increase: ~$5-10/month for 1000 images (acceptable)

---

### Risk 4: Watermark Positioning Obscures LEGO Content

**Description:** Watermark overlay may cover important LEGO set details in bottom-right corner.

**Likelihood:** Low
**Impact:** Medium (User frustration)

**Mitigation:**
- Use 10% opacity (subtle watermark, minimal visual impact)
- Position with 20px margin from edge (avoids most content)
- Manual testing with real LEGO images before production deployment
- If positioning is problematic, make watermark position configurable (top-right, center, etc.)

---

### Risk 5: Browser Compatibility (WebP Not Supported)

**Description:** Older browsers (e.g., IE11) do not support WebP format, causing images to fail to load.

**Likelihood:** Low
**Impact:** Medium (User sees broken images)

**Mitigation:**
- Use `<picture>` element with JPEG fallback (AC3, AC8, AC9)
- Browsers without WebP support automatically load JPEG variant
- Retain original JPEG in S3 for fallback
- Test in multiple browsers (Chrome, Firefox, Safari, Edge, IE11) before production

---

## Definition of Done

- [ ] Automatic image resizing implemented (thumbnail, medium, large) (AC1)
- [ ] Image compression implemented (85% quality) (AC2)
- [ ] WebP format conversion with JPEG fallback implemented (AC3)
- [ ] Watermark application implemented (large size only) (AC4)
- [ ] Database migration adds image_variants column (AC5)
- [ ] S3 event trigger configured (AC6)
- [ ] Image processor Lambda performance meets requirements (< 10s) (AC7)
- [ ] Frontend responsive image display implemented (gallery card) (AC8)
- [ ] Frontend optimized image display implemented (detail page) (AC9)
- [ ] Fallback for legacy items without image_variants (AC10)
- [ ] Image processing failure handling implemented (AC11)
- [ ] Unit tests pass (20+ for optimizer) (AC12)
- [ ] Integration tests pass (15+ for Lambda handler) (AC13)
- [ ] Storage cost monitoring implemented (CloudWatch metrics) (AC14)
- [ ] Documentation updated (AC15)
- [ ] All unit tests pass
- [ ] All integration tests pass
- [ ] No TypeScript errors
- [ ] No ESLint errors
- [ ] Code reviewed and approved
- [ ] Infrastructure changes deployed (S3 event trigger, Lambda, Sharp layer)
- [ ] Database migration applied
- [ ] Staging environment validation complete
- [ ] Manual testing with real LEGO images (portrait, landscape, square)
- [ ] CloudWatch dashboard shows cost savings trends

---

## Out of Scope (Future Work)

- **CDN Integration:** CloudFront or image CDN setup → Defer to WISH-2018 (CDN Integration)
- **Advanced Image Processing:** AI-based upscaling, background removal, smart cropping → Future enhancement
- **Video Processing:** Video thumbnail generation or video optimization → Separate story
- **Real-time Processing:** Synchronous image optimization during upload → Performance tradeoff not justified
- **Custom Watermark Upload:** User-uploaded watermark images → Future premium feature
- **Image Editing UI:** User-facing image editing tools (crop, rotate, filters) → Future enhancement

---

## Notes

### Implementation Approach (Recommended):

1. **Start with Database Migration:**
   - Add `image_variants` column to wishlist_items table
   - Deploy migration to staging environment
   - Verify column exists and accepts JSONB data

2. **Build Image Optimization Service:**
   - Implement Sharp integration (resize, compress, convert to WebP)
   - Implement watermark overlay logic
   - Write unit tests (20+ tests for all edge cases)

3. **Create S3 Event Handler Lambda:**
   - Implement Lambda handler for S3 events
   - Integrate with image optimization service
   - Write integration tests (15+ tests with MSW mocks)

4. **Deploy Sharp Lambda Layer:**
   - Build or download Sharp Lambda layer for Node.js 18.x
   - Deploy layer to AWS account
   - Attach layer to image processor Lambda

5. **Configure S3 Event Trigger:**
   - Add event notification to S3 bucket
   - Test with manual image upload
   - Verify Lambda is invoked and images are optimized

6. **Update Frontend Components:**
   - Modify WishlistCard to use thumbnail variant
   - Modify DetailPage to use large variant
   - Implement `<picture>` element with srcset
   - Add fallback logic for legacy items

7. **Add CloudWatch Monitoring:**
   - Emit custom metrics for storage savings
   - Create CloudWatch dashboard
   - Set up alarms for processing failures

8. **Staging Validation:**
   - Upload 20+ real LEGO images (portrait, landscape, square)
   - Verify all variants are generated correctly
   - Verify watermark is positioned correctly
   - Verify frontend displays responsive images
   - Verify cost savings metrics in CloudWatch

### Quality Gates:

- All unit and integration tests pass without errors
- Lambda processing time < 10 seconds for typical 10MB images
- Storage compression ratio > 90% (from 10MB to < 1MB total)
- Frontend displays responsive images with WebP/JPEG fallback
- Watermark is subtle and does not obscure LEGO content
- CloudWatch dashboard shows cost savings trends

---

## QA Discovery Notes (for PM Review)

_Placeholder for QA Elaboration findings._

### Gaps Identified & Resolved

_To be filled during QA Elaboration phase._

### Enhancement Opportunities

_To be filled during QA Elaboration phase._

### Follow-up Stories Suggested

_To be filled during QA Elaboration phase._

### Items Marked Out-of-Scope

_To be filled during QA Elaboration phase._

---
