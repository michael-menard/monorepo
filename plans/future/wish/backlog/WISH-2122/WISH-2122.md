---
status: pending
follow_up_from: WISH-2013
created: 2026-01-28
updated_at: 2026-01-28
story_id: WISH-2122
title: Usage Quotas - Per-User Storage Quotas and Upload Rate Limits
epic: Wishlist Feature
phase: 4 - Resource Management
priority: P2
depends_on: [WISH-2013]
complexity: Medium
effort: 3-5 points
---

# WISH-2122: Usage Quotas - Per-User Storage Quotas and Upload Rate Limits

## Follow-up Context

**Parent Story:** WISH-2013 (File Upload Security Hardening)

**Source:** QA Discovery Notes - Follow-up Stories Suggested

**Original Finding:** "User Quota Management: Per-user storage quotas or upload rate limits (deferred to future story)"

**Category:** Enhancement Opportunity

**Impact:** Medium (Cost control and abuse prevention)

**Effort:** Medium (Database tracking + enforcement logic + rate limiting)

---

## Context

The wishlist feature's file upload functionality (WISH-2002) allows users to upload images to S3 with security hardening from WISH-2013 (file type validation, virus scanning, 10MB max file size). However, there are currently no per-user limits on:

1. **Total Storage Quota:** Users can upload unlimited images, consuming unbounded S3 storage and costs
2. **Upload Rate Limits:** Users can upload files rapidly in succession, potentially abusing the system or causing performance degradation

This story implements resource management policies to control costs and prevent abuse:

1. **Per-User Storage Quotas:** Limit total storage per user (e.g., 100MB default, configurable by user tier)
2. **Upload Rate Limits:** Throttle uploads to prevent rapid-fire abuse (e.g., max 10 uploads per hour)
3. **Quota Tracking:** Real-time tracking of user storage consumption in database
4. **Enforcement:** Reject presign requests when quota exceeded or rate limit hit
5. **User Visibility:** Display current usage and remaining quota in UI

### Background

**Current State (WISH-2013):**
- Per-file size limit: 10MB (client + server validation)
- No total storage quota per user
- No rate limiting on upload requests
- S3 costs scale unbounded with user uploads

**Cost/Abuse Risks Without This Story:**
- Single user could upload 1000+ images (10GB+ storage at $0.23/GB = $2.30/user/month)
- Malicious user could flood S3 with uploads (DDoS-style attack)
- No mechanism to enforce tier-based storage limits (free tier vs paid tier)
- No visibility into user storage consumption for cost monitoring

**Relationship to WISH-2013:**
- Builds on security validation infrastructure (presign endpoint, file validation)
- Adds resource management layer on top of security layer
- Reuses error handling patterns and audit logging from WISH-2013

---

## Goal

Implement per-user storage quotas and upload rate limits to control S3 costs, prevent abuse, and enable tier-based resource allocation. Ensure users have visibility into their usage and are notified when approaching limits.

---

## Non-goals

- **Quota Overrides UI:** Admin interface for manually adjusting user quotas (defer to future admin story)
- **Tier Management:** User upgrade/downgrade flows for changing quota tiers (defer to billing feature)
- **Storage Cleanup:** Automated deletion of old images to free quota (defer to retention policy story)
- **Cross-Service Quotas:** Quotas for gallery, MOC instructions, or other upload features (scope: wishlist only)
- **Bandwidth Quotas:** Limits on download bandwidth (scope: upload quotas only)

---

## Scope

### Packages Affected

- `apps/api/lego-api/domains/wishlist/` - Presign endpoint quota enforcement
- `apps/api/lego-api/core/quotas/` - Quota service (new)
- `apps/api/lego-api/core/rate-limit/` - Upload rate limiter (new or extend existing)
- `packages/backend/database-schema/` - User quotas table (new)
- `apps/web/app-wishlist-gallery/src/components/` - Quota usage UI component (new)
- `packages/core/api-client/src/schemas/` - Quota schemas

### Database Schema Changes

**New Table: `user_storage_quotas`**

```sql
CREATE TABLE user_storage_quotas (
  user_id UUID PRIMARY KEY REFERENCES users(id),
  quota_tier VARCHAR(50) NOT NULL DEFAULT 'free',
  total_quota_bytes BIGINT NOT NULL DEFAULT 104857600, -- 100MB
  used_bytes BIGINT NOT NULL DEFAULT 0,
  file_count INT NOT NULL DEFAULT 0,
  last_upload_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_user_storage_quotas_tier ON user_storage_quotas(quota_tier);
CREATE INDEX idx_user_storage_quotas_usage ON user_storage_quotas(used_bytes, total_quota_bytes);
```

**New Table: `upload_rate_limits`**

```sql
CREATE TABLE upload_rate_limits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id),
  window_start TIMESTAMP WITH TIME ZONE NOT NULL,
  upload_count INT NOT NULL DEFAULT 1,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_upload_rate_limits_user_window ON upload_rate_limits(user_id, window_start);
```

### Files to Create

1. **Quota Service:**
   - `apps/api/lego-api/core/quotas/quota-service.ts` - Quota tracking and enforcement
   - `apps/api/lego-api/core/quotas/__tests__/quota-service.test.ts` - Unit tests

2. **Rate Limiter:**
   - `apps/api/lego-api/core/rate-limit/upload-rate-limiter.ts` - Upload rate limiting
   - `apps/api/lego-api/core/rate-limit/__tests__/upload-rate-limiter.test.ts` - Unit tests

3. **Quota UI Component:**
   - `apps/web/app-wishlist-gallery/src/components/QuotaUsageWidget/index.tsx` - Display usage
   - `apps/web/app-wishlist-gallery/src/components/QuotaUsageWidget/__tests__/QuotaUsageWidget.test.tsx` - Component tests

4. **Database Migrations:**
   - `packages/backend/database-schema/src/migrations/app/XXXX_add_user_storage_quotas.sql`
   - `packages/backend/database-schema/src/migrations/app/XXXX_add_upload_rate_limits.sql`

5. **Zod Schemas:**
   - `packages/core/api-client/src/schemas/quotas.ts` - QuotaUsageSchema, QuotaTierSchema

### Files to Modify

1. **API Layer:**
   - `apps/api/lego-api/domains/wishlist/application/wishlist-service.ts` - Add quota checks to presign flow
   - `apps/api/lego-api/domains/wishlist/routes.ts` - Add rate limit middleware
   - `apps/api/lego-api/domains/wishlist/adapters/wishlist-repository.ts` - Update quota on upload

2. **Client Layer:**
   - `apps/web/app-wishlist-gallery/src/pages/AddItemPage.tsx` - Display QuotaUsageWidget
   - `apps/web/app-wishlist-gallery/src/hooks/useS3Upload.ts` - Handle quota error responses

3. **Test Infrastructure:**
   - `apps/web/app-wishlist-gallery/src/test/mocks/handlers.ts` - Mock quota endpoints

---

## Acceptance Criteria

### AC1: Per-User Storage Quota Default (Free Tier)
**Given** a new user signs up
**When** the user account is created
**Then** a quota record is created with tier='free' and total_quota_bytes=104857600 (100MB)
**And** used_bytes=0 and file_count=0
**And** quota tier is configurable via environment variable

### AC2: Quota Enforcement on Presign Request
**Given** a user has uploaded 95MB of files (quota: 100MB)
**When** the user requests presign URL for 10MB file (total would be 105MB)
**Then** the presign endpoint rejects the request with 429 Too Many Requests
**And** returns error message "Storage quota exceeded. Used: 95MB / 100MB. Cannot upload 10MB file."
**And** response includes quotaUsed, quotaTotal, fileSize fields

### AC3: Quota Update on Successful Upload
**Given** a user successfully uploads a 5MB file
**When** the upload is registered in the backend
**Then** the user's quota record is updated: used_bytes += 5MB, file_count += 1
**And** last_upload_at is set to current timestamp
**And** update is atomic (transaction)

### AC4: Quota Recalculation on File Deletion
**Given** a user deletes a 5MB file from wishlist
**When** the delete operation completes
**Then** the user's quota record is updated: used_bytes -= 5MB, file_count -= 1
**And** quota is freed for future uploads

### AC5: Upload Rate Limit Enforcement (10 uploads per hour)
**Given** a user has uploaded 9 files in the past 60 minutes
**When** the user attempts a 10th upload within the same hour
**Then** the presign request succeeds (within limit)
**When** the user attempts an 11th upload within the same hour
**Then** the presign request is rejected with 429 Too Many Requests
**And** returns error message "Upload rate limit exceeded. Max 10 uploads per hour. Try again in X minutes."
**And** response includes retryAfter field (seconds until next window)

### AC6: Rate Limit Window Sliding
**Given** a user uploaded 10 files at 1:00 PM (rate limit hit)
**When** the user attempts upload at 2:05 PM (65 minutes later)
**Then** the rate limit check uses a 60-minute sliding window
**And** uploads older than 1:05 PM are excluded from count
**And** presign request succeeds

### AC7: Quota Usage API Endpoint
**Given** a user is authenticated
**When** the user requests `GET /api/wishlist/quota`
**Then** the endpoint returns:
```json
{
  "tier": "free",
  "totalQuotaBytes": 104857600,
  "usedBytes": 52428800,
  "fileCount": 5,
  "remainingBytes": 52428800,
  "percentUsed": 50,
  "uploadRateLimit": {
    "maxUploadsPerHour": 10,
    "uploadsInCurrentWindow": 3,
    "remainingUploads": 7,
    "windowResetAt": "2026-01-28T15:00:00Z"
  }
}
```

### AC8: Quota Usage Widget in UI
**Given** a user is on the Add Item page
**When** the page renders
**Then** a QuotaUsageWidget displays:
  - Progress bar showing used/total quota
  - Text: "Storage: 50MB / 100MB (50% used)"
  - Text: "Files: 5 / ∞"
  - Text: "Uploads this hour: 3 / 10"
**And** widget updates after successful upload
**And** widget shows warning when > 80% quota used (orange color)
**And** widget shows error when quota full (red color)

### AC9: Quota Exceeded Client-Side Handling
**Given** a user attempts upload but quota is exceeded
**When** the presign request returns 429 with quota error
**Then** the client displays toast notification: "Storage quota exceeded. Please delete some images or upgrade your plan."
**And** the upload form is disabled
**And** the QuotaUsageWidget highlights the quota limit

### AC10: Rate Limit Exceeded Client-Side Handling
**Given** a user attempts upload but rate limit is exceeded
**When** the presign request returns 429 with rate limit error
**Then** the client displays toast notification: "Upload rate limit exceeded. Please wait X minutes and try again."
**And** the upload form is disabled temporarily
**And** a countdown timer displays time until next upload allowed

### AC11: Quota Tier Configuration
**Given** different quota tiers are configured (free, pro, enterprise)
**When** a user's tier is set in the database
**Then** the quota service applies tier-specific limits:
  - Free: 100MB, 10 uploads/hour
  - Pro: 1GB, 50 uploads/hour
  - Enterprise: 10GB, 200 uploads/hour
**And** tier limits are configurable via environment variables

### AC12: Concurrent Upload Quota Safety
**Given** a user with 95MB used quota attempts two concurrent 5MB uploads
**When** both presign requests are processed simultaneously
**Then** only one request succeeds (first to acquire lock)
**And** the second request is rejected (quota would be exceeded)
**And** quota updates use database row-level locking (FOR UPDATE)

### AC13: Quota Audit Logging
**Given** quota enforcement events occur
**When** quota exceeded or rate limit hit
**Then** events are logged to CloudWatch with structured metadata:
  - userId, tier, quotaUsed, quotaTotal, fileSize, rejectionReason, timestamp
**And** logs use @repo/logger with 'quota' namespace
**And** logs are queryable for cost analysis

### AC14: Quota Tracking Accuracy Test
**Given** a user uploads 5 files (2MB, 3MB, 1MB, 4MB, 5MB)
**When** all uploads complete
**Then** the quota record shows used_bytes=15MB, file_count=5
**When** the user deletes the 4MB file
**Then** the quota record shows used_bytes=11MB, file_count=4
**And** quota tracking is accurate across operations

### AC15: Rate Limit Window Boundary Test
**Given** a user uploads 10 files at 1:00 PM (rate limit hit)
**When** the user attempts upload at 1:59 PM (59 minutes later)
**Then** the presign request is rejected (still within 60-minute window)
**When** the user attempts upload at 2:01 PM (61 minutes later)
**Then** the presign request succeeds (outside 60-minute window)

### AC16: Quota Migration for Existing Users
**Given** existing users with uploaded files (before WISH-2122)
**When** the migration runs
**Then** quota records are created for all existing users
**And** used_bytes is calculated from existing wishlist_items.image_size
**And** file_count is calculated from COUNT(wishlist_items) per user
**And** tier defaults to 'free' for all existing users

### AC17: Documentation Updates
**Given** new quota infrastructure is implemented
**When** developers need to understand quota management
**Then** documentation includes:
  - Quota tier definitions and limits
  - Rate limiting algorithm (sliding window)
  - Quota tracking accuracy guarantees
  - Migration strategy for existing users
  - Testing guide for quota scenarios

---

## Test Plan

*Comprehensive test coverage for quota enforcement and rate limiting.*

### Happy Path Tests:

1. **Upload Within Quota:**
   - User has 50MB used, 100MB total quota
   - Upload 10MB file succeeds
   - Quota updated to 60MB used, file_count incremented

2. **Upload Within Rate Limit:**
   - User has uploaded 5 files in past hour
   - Upload 6th file succeeds (within 10/hour limit)
   - Rate limit window tracks correctly

3. **Quota Display:**
   - User views Add Item page
   - QuotaUsageWidget displays accurate usage
   - Progress bar and text match backend quota

### Error Cases:

1. **Quota Exceeded (Total):**
   - User has 95MB used, 100MB quota
   - Attempt to upload 10MB file
   - Presign rejected with 429 error
   - Error message displays quota details

2. **Rate Limit Exceeded (Hourly):**
   - User has uploaded 10 files in past hour
   - Attempt 11th upload
   - Presign rejected with 429 error
   - Retry countdown displayed

3. **Concurrent Upload Race Condition:**
   - User with 95MB used attempts two 5MB uploads concurrently
   - First upload succeeds, second fails
   - No quota overcommitment

4. **File Deletion Quota Recovery:**
   - User deletes 10MB file
   - Quota freed correctly (used_bytes -= 10MB)
   - New uploads allowed up to freed space

### Edge Cases:

1. **Exact Quota Boundary:**
   - User has 90MB used, 100MB quota
   - Upload 10MB file (exact remaining quota)
   - Upload succeeds

2. **Quota Boundary + 1 Byte:**
   - User has 90MB used, 100MB quota
   - Upload 10MB + 1 byte file
   - Upload fails

3. **Rate Limit Window Rollover:**
   - User uploads 10 files at 1:00 PM
   - Attempt upload at 2:00:01 PM (60 minutes + 1 second)
   - Upload succeeds (window rolled over)

4. **New User Quota Initialization:**
   - User signs up and immediately uploads
   - Quota record created with defaults
   - Upload succeeds

5. **Quota Migration Accuracy:**
   - Existing user with 3 files (2MB, 5MB, 3MB)
   - Migration calculates 10MB used, 3 files
   - Quota tracking accurate post-migration

### Required Evidence:

- 30+ unit tests for quota service and rate limiter
- 20+ integration tests for quota enforcement in presign flow
- 15+ component tests for QuotaUsageWidget
- Migration validation script (checksum verification)
- CloudWatch logs verified for quota events

---

## Reuse Plan

### Reuse from WISH-2013 (Security Hardening)

1. **Presign Endpoint:**
   - Add quota checks to existing validation middleware chain
   - Reuse error response patterns (400 Bad Request, 429 Too Many Requests)
   - Extend audit logging to include quota events

2. **Client Upload Hook:**
   - Extend `useS3Upload` to handle quota error states
   - Reuse error toast notification patterns
   - Add quota polling after successful upload

### Reuse from Existing Infrastructure

1. **Rate Limiting:**
   - Check if `apps/api/lego-api/core/rate-limit/` exists from other features
   - Reuse PostgreSQL-based rate limiter if available
   - Extend for upload-specific rate limits

2. **Database Schema Patterns:**
   - Follow existing migration patterns from WISH-2000 (database schema)
   - Reuse Drizzle schema conventions
   - Follow Zod schema patterns from @repo/api-client

### Reusable Components for Future Stories

1. **Quota Service:**
   - Abstract quota tracking for reuse with gallery, MOC instructions uploads
   - Support quota types: storage, upload count, bandwidth (extensible)

2. **Rate Limiter:**
   - Generic sliding window rate limiter reusable for any API endpoint
   - Configurable window size and limits

3. **QuotaUsageWidget:**
   - Reusable UI component for any feature with quotas
   - Customizable labels and thresholds

---

## Architecture Notes

### Hexagonal Architecture (Ports & Adapters)

**Ports (Interfaces):**

1. **Quota Service Port:**
   ```typescript
   export interface QuotaService {
     checkQuota(userId: string, fileSize: number): Promise<QuotaCheckResult>
     incrementUsage(userId: string, fileSize: number): Promise<void>
     decrementUsage(userId: string, fileSize: number): Promise<void>
     getUsage(userId: string): Promise<QuotaUsage>
   }

   export type QuotaCheckResult =
     | { allowed: true }
     | { allowed: false; reason: string; quotaUsed: number; quotaTotal: number }
   ```

2. **Rate Limiter Port:**
   ```typescript
   export interface RateLimiter {
     checkLimit(userId: string, action: string): Promise<RateLimitCheckResult>
     recordAction(userId: string, action: string): Promise<void>
   }

   export type RateLimitCheckResult =
     | { allowed: true }
     | { allowed: false; retryAfter: number }
   ```

**Adapters (Implementations):**

1. **PostgreSQL Quota Adapter:**
   - Implements `QuotaService` port
   - Uses `user_storage_quotas` table
   - Handles concurrent updates with row-level locking

2. **Sliding Window Rate Limiter Adapter:**
   - Implements `RateLimiter` port
   - Uses `upload_rate_limits` table
   - 60-minute sliding window algorithm

### Quota Enforcement Flow

```
1. User selects file in UI
   ↓
2. Client validates file size (< 10MB per WISH-2013)
   ↓
3. Client requests presign URL (POST /api/wishlist/images/presign)
   ↓
4. Server checks rate limit (10 uploads/hour)
   ↓ (if within limit)
5. Server checks storage quota (used + fileSize <= total)
   ↓ (if within quota)
6. Server generates presigned URL (WISH-2013 security)
   ↓
7. Client uploads to S3
   ↓
8. Client notifies backend of completion
   ↓
9. Server increments quota (used_bytes, file_count)
   ↓
10. Server records upload in rate limit window
```

### Rate Limiting Algorithm (Sliding Window)

```
Window Size: 60 minutes (3600 seconds)
Max Uploads: 10 per window

Example:
- Upload 1-10: 1:00 PM - 1:30 PM (allowed)
- Upload 11: 1:35 PM (rejected - 10 uploads in past 60 min)
- Upload 12: 2:05 PM (allowed - uploads before 1:05 PM excluded)

SQL Query:
SELECT COUNT(*) FROM upload_rate_limits
WHERE user_id = $1
AND window_start >= NOW() - INTERVAL '60 minutes'
```

---

## Infrastructure Notes

### Database Performance Considerations

**Indexing:**
- `idx_user_storage_quotas_tier` - Fast tier-based queries
- `idx_user_storage_quotas_usage` - Fast quota utilization queries
- `idx_upload_rate_limits_user_window` - Fast rate limit window queries

**Locking Strategy:**
```sql
-- Quota update with row-level lock
BEGIN;
SELECT * FROM user_storage_quotas
WHERE user_id = $1
FOR UPDATE;

UPDATE user_storage_quotas
SET used_bytes = used_bytes + $2,
    file_count = file_count + 1,
    last_upload_at = NOW()
WHERE user_id = $1;

COMMIT;
```

**Migration Strategy for Existing Users:**

```sql
-- Calculate existing usage and create quota records
INSERT INTO user_storage_quotas (user_id, used_bytes, file_count)
SELECT
  wi.user_id,
  COALESCE(SUM(wi.image_size), 0) AS used_bytes,
  COUNT(*) AS file_count
FROM wishlist_items wi
WHERE wi.image_url IS NOT NULL
GROUP BY wi.user_id
ON CONFLICT (user_id) DO NOTHING;
```

### Environment Configuration

```env
# Quota Tier Configuration
QUOTA_FREE_STORAGE_BYTES=104857600  # 100MB
QUOTA_PRO_STORAGE_BYTES=1073741824   # 1GB
QUOTA_ENTERPRISE_STORAGE_BYTES=10737418240  # 10GB

QUOTA_FREE_UPLOAD_RATE_PER_HOUR=10
QUOTA_PRO_UPLOAD_RATE_PER_HOUR=50
QUOTA_ENTERPRISE_UPLOAD_RATE_PER_HOUR=200

# Rate Limit Window
UPLOAD_RATE_LIMIT_WINDOW_SECONDS=3600  # 60 minutes
```

---

## HTTP Contract Plan

### New Endpoints

#### GET /api/wishlist/quota

**Description:** Retrieve current quota usage for authenticated user

**Request:**
- Headers: `Authorization: Bearer <token>`

**Response - Success (200 OK):**
```json
{
  "tier": "free",
  "totalQuotaBytes": 104857600,
  "usedBytes": 52428800,
  "fileCount": 5,
  "remainingBytes": 52428800,
  "percentUsed": 50,
  "uploadRateLimit": {
    "maxUploadsPerHour": 10,
    "uploadsInCurrentWindow": 3,
    "remainingUploads": 7,
    "windowResetAt": "2026-01-28T15:00:00Z"
  }
}
```

**Response - Unauthorized (401):**
```json
{
  "error": "Unauthorized"
}
```

### Enhanced Endpoints (Existing)

#### POST /api/wishlist/images/presign

**Enhanced Error Responses:**

```json
// Quota Exceeded (429 Too Many Requests)
{
  "error": "Storage quota exceeded",
  "message": "Used: 95MB / 100MB. Cannot upload 10MB file.",
  "quotaUsed": 99614720,
  "quotaTotal": 104857600,
  "fileSize": 10485760
}

// Rate Limit Exceeded (429 Too Many Requests)
{
  "error": "Upload rate limit exceeded",
  "message": "Max 10 uploads per hour. Try again in 15 minutes.",
  "retryAfter": 900,
  "uploadsInWindow": 10,
  "maxUploadsPerHour": 10
}
```

**Contract Compatibility:** Fully backward compatible. Existing clients receive new error types (429) but success response unchanged.

---

## Seed Requirements

**Migration Seed Required:** Yes - backfill quota records for existing users

**Seed Script:**
- `packages/backend/database-schema/src/seeds/quota-migration.ts`
- Calculate existing usage from `wishlist_items` table
- Create quota records with accurate used_bytes and file_count
- Validation: Verify SUM(image_size) matches quota used_bytes

**Test Seeds:**
- User with 0% quota used (new user)
- User with 50% quota used (5 files, 50MB)
- User with 95% quota used (near limit)
- User with 100% quota used (at limit)

---

## UI/UX Notes

### User-Facing Changes

1. **Quota Usage Widget (Add Item Page):**
   - Progress bar: Visual representation of storage quota
   - Text: "Storage: 50MB / 100MB (50% used)"
   - Text: "Files: 5"
   - Text: "Uploads this hour: 3 / 10"
   - Warning state (> 80% used): Orange progress bar
   - Error state (100% used): Red progress bar, upload disabled

2. **Error Messages:**
   - Quota exceeded: "Storage quota exceeded. Please delete some images or upgrade your plan."
   - Rate limit exceeded: "Upload rate limit exceeded. Please wait 15 minutes and try again."
   - Countdown timer for rate limit: "Next upload in: 14:32"

3. **Toast Notifications:**
   - Quota warning (> 80% used): "You've used 85% of your storage quota. Consider deleting old items."
   - Quota full: "Storage quota full. Delete items or upgrade to continue uploading."

### Accessibility Considerations

- Progress bar has `aria-label="Storage quota usage"`
- Error messages announced via `aria-live="polite"` region
- Countdown timer has `role="timer"` and `aria-live="polite"`
- Disabled upload form has `aria-disabled="true"` with explanation

### Design System Integration

- Reuse Progress component from `@repo/ui`
- Reuse Badge component for quota tier display
- Reuse Toast component for notifications

---

## Dependencies

### Blocked By:

- **WISH-2013** (File Upload Security Hardening) - Required for presign endpoint validation infrastructure
  - Quota checks build on existing validation middleware
  - Audit logging patterns reused for quota events

### Blocks:

- Tier-based feature gating (pro features require quota tier infrastructure)
- Billing integration (quota tier upgrades/downgrades)

### Internal Package Dependencies:

- `@repo/api-client` - Zod schemas for quota types
- `@repo/logger` - Quota audit logging
- `packages/backend/database-schema` - New quota tables

### External Dependencies:

- None (pure application logic + database)

---

## Risks & Mitigations

### Risk 1: Quota Migration Accuracy for Existing Users

**Description:** Migration script may miscalculate existing user storage if `wishlist_items.image_size` is missing or inaccurate.

**Likelihood:** Medium
**Impact:** High (Incorrect quota limits users unfairly)

**Mitigation:**
- Validation query: Compare SUM(image_size) to actual S3 object sizes (sampling)
- Manual review of quota records with used_bytes > 0
- Rollback plan: Recalculate quotas from S3 API if discrepancies found
- Add `image_size` field to wishlist_items if missing (prerequisite)

---

### Risk 2: Concurrent Upload Race Conditions

**Description:** Two concurrent presign requests for user near quota limit may both succeed, causing quota overcommitment.

**Likelihood:** Low
**Impact:** Medium (User exceeds quota by small margin)

**Mitigation:**
- Use database row-level locking (`FOR UPDATE`) in quota check
- Atomic transaction: check + reserve quota in single DB operation
- Integration test simulates concurrent requests
- If race occurs, background job reconciles quota and notifies user

---

### Risk 3: Rate Limit Window Cleanup Performance

**Description:** `upload_rate_limits` table grows unbounded, slowing rate limit queries over time.

**Likelihood:** High
**Impact:** Medium (Performance degradation)

**Mitigation:**
- Background cleanup job deletes records older than 60 minutes (runs hourly)
- Partition table by window_start date (PostgreSQL partitioning)
- Index on `(user_id, window_start)` ensures fast queries
- Monitor query performance in CloudWatch

---

### Risk 4: User Confusion About Quota Limits

**Description:** Users may not understand why uploads are blocked, leading to support tickets.

**Likelihood:** Medium
**Impact:** Low (Support overhead)

**Mitigation:**
- Clear error messages with actionable guidance ("Delete items or upgrade")
- QuotaUsageWidget always visible on Add Item page
- Warning notifications at 80% quota usage
- Link to help documentation explaining quotas

---

## Definition of Done

- [ ] Database tables created: `user_storage_quotas`, `upload_rate_limits` (AC1)
- [ ] Quota enforcement implemented in presign endpoint (AC2)
- [ ] Quota updates on upload completion (AC3)
- [ ] Quota recalculation on file deletion (AC4)
- [ ] Rate limit enforcement implemented (AC5)
- [ ] Sliding window rate limit logic (AC6)
- [ ] Quota usage API endpoint created (AC7)
- [ ] QuotaUsageWidget component implemented (AC8)
- [ ] Client-side quota error handling (AC9)
- [ ] Client-side rate limit error handling (AC10)
- [ ] Quota tier configuration support (AC11)
- [ ] Concurrent upload safety (row-level locking) (AC12)
- [ ] Quota audit logging (AC13)
- [ ] Quota tracking accuracy tests (AC14)
- [ ] Rate limit window boundary tests (AC15)
- [ ] Quota migration for existing users (AC16)
- [ ] Documentation updated (AC17)
- [ ] All unit tests pass (30+ for quota service)
- [ ] All integration tests pass (20+ for enforcement)
- [ ] All component tests pass (15+ for QuotaUsageWidget)
- [ ] Migration validation script passes
- [ ] No TypeScript errors
- [ ] No ESLint errors
- [ ] Code reviewed and approved
- [ ] Staging environment validation complete
- [ ] Performance review approved (quota query < 50ms)

---

## Out of Scope (Future Work)

- **Quota Overrides UI:** Admin interface for manually adjusting user quotas → Defer to admin feature
- **Tier Management:** User upgrade/downgrade flows → Defer to billing feature
- **Storage Cleanup:** Automated deletion of old images → Defer to retention policy story
- **Cross-Service Quotas:** Gallery, MOC instructions quotas → Defer to respective features
- **Bandwidth Quotas:** Download bandwidth limits → Defer to future story
- **Advanced Quota Types:** Time-based quotas (daily/weekly) → Defer to future enhancement

---

## Notes

### Implementation Approach (Recommended):

1. **Database Schema First:**
   - Create migration for `user_storage_quotas` table
   - Create migration for `upload_rate_limits` table
   - Add indexes for performance
   - Validate schema in staging

2. **Quota Service Implementation:**
   - Implement quota service port + adapter
   - Add quota check logic with row-level locking
   - Add quota increment/decrement operations
   - Write unit tests (30+ tests)

3. **Rate Limiter Implementation:**
   - Implement sliding window rate limiter
   - Add rate limit check and record logic
   - Write unit tests (15+ tests)

4. **API Integration:**
   - Add quota middleware to presign endpoint
   - Add quota usage GET endpoint
   - Update quota on upload completion
   - Update quota on file deletion
   - Write integration tests (20+ tests)

5. **Client Implementation:**
   - Create QuotaUsageWidget component
   - Add quota polling to Add Item page
   - Handle quota/rate limit errors
   - Write component tests (15+ tests)

6. **Migration & Validation:**
   - Write quota migration script for existing users
   - Run validation query (SUM vs actual S3 sizes)
   - Deploy migration to staging
   - Verify quota accuracy

7. **Staging Validation:**
   - Test quota enforcement end-to-end
   - Test rate limiting with rapid uploads
   - Test quota display in UI
   - Test migration on staging data

### Quality Gates:

- Quota check query < 50ms (p95)
- Rate limit check query < 30ms (p95)
- Migration completes in < 5 minutes for 10k users
- No quota overcommitment in concurrent upload tests
- QuotaUsageWidget updates within 2 seconds of upload

---
