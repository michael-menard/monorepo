---
story_id: wrkf-1041
title: pm_generate_graph Subgraph - Core Infrastructure
status: backlog
split_from: wrkf-1040
split_part: 1 of 2
created: 2026-01-27
updated: 2026-01-27
epic: wrkf
feature: LangGraph Orchestrator - Story Generation Workflow
depends_on: []
related_stories:
  - wrkf-1010 # GraphState Schema
  - wrkf-1020 # Node Runner Infrastructure
  - wrkf-1030 # bootstrap_graph Subgraph (reference implementation)
---

# WRKF-1041: pm_generate_graph Subgraph - Core Infrastructure

## Split Context

This story is part of a split from WRKF-1040.
- **Original Story:** WRKF-1040 (pm_generate_graph Subgraph)
- **Split Reason:** Elaboration identified 15 additional gaps and enhancements (from 8 to 23 ACs), exceeding sustainable scope for single story
- **This Part:** 1 of 2 (Core infrastructure and critical quality gates)
- **Dependency:** No dependencies (can start immediately)
- **Follow-up:** WRKF-1042 (Advanced features: batch generation, quality scoring, refinement)

This split focuses on implementing the foundational pm_generate_graph subgraph with all essential nodes and critical quality gates to ensure story generation is production-ready.

## Context

The LangGraph orchestrator requires a subgraph to automate the generation of individual story documents from story index entries. Currently, the `/pm-generate-story` command relies on manual or ad-hoc story creation, which is time-consuming and inconsistent. This story implements the core `pm_generate_graph` subgraph to orchestrate story generation using LangGraph nodes, leveraging existing infrastructure from wrkf-1010 (GraphState) and wrkf-1020 (Node Runner).

The subgraph will:
1. Load a story template that defines the required structure
2. Gather context from the story index and plan documents
3. Use an LLM (Claude) to generate story content based on the template and context
4. Validate the generated story to ensure all required sections are present and well-formed
5. Apply critical quality gates (template versioning, index validation, placeholder detection, error classification)

This is a critical building block for the orchestrator ecosystem, establishing patterns for LLM-based content generation nodes that will be reused in other subgraphs (elaboration, code review, etc.).

## Goal

Implement the core `pm_generate_graph` LangGraph subgraph with all essential nodes, critical quality gates, and production-ready error handling to automatically generate complete, high-quality story documents from story index entries.

**Success Criteria:**
- Story generation completes end-to-end without manual intervention
- Generated stories pass structural validation (all required sections present)
- Template versioning prevents version mismatches
- Index validation fails fast before expensive LLM calls
- Placeholder content is detected and flagged
- LLM errors are classified and retried appropriately
- Story regeneration workflow supports --force flag
- PM command integration is documented and functional
- Subgraph integrates cleanly with existing GraphState and Node Runner infrastructure

## Non-goals

- Multi-turn story refinement (deferred to WRKF-1042)
- Batch story generation (deferred to WRKF-1042)
- Quality scoring agent (deferred to WRKF-1042)
- Interactive refinement UI (deferred to WRKF-1042)
- Evidence bundle integration (deferred to WRKF-1042)
- Human-in-the-loop approval before writing story file (manual PM review happens post-generation)
- Story versioning or diff tracking (stories are generated once, manual edits tracked via Git)
- Integration with CI/CD for automated story generation (invoked manually via CLI only)
- Semantic quality validation beyond placeholder detection (testability of ACs, etc.)
- Full plan document embedding in LLM context (use excerpts to manage context window)

## Scope

### Packages Affected

**Primary:**
- `packages/orchestrator/src/subgraphs/pm-generate-graph/` (new directory)
  - `index.ts` - Subgraph entry point and graph definition
  - `nodes/template-loader.ts` - Node to load story template from filesystem
  - `nodes/context-gatherer.ts` - Node to read story index entry and plan excerpts
  - `nodes/story-writer.ts` - LLM node to generate story content via Claude API
  - `nodes/validator.ts` - Node to validate story structure and completeness
  - `graph.ts` - LangGraph composition and edge definitions
  - `__tests__/` - Unit and integration tests for all nodes and graph

**Supporting:**
- `packages/orchestrator/src/core/state/graph-state.ts` (extend with story generation fields)
- `packages/orchestrator/src/utils/` (add file I/O, markdown parsing, YAML frontmatter utilities)
- `packages/orchestrator/templates/story-template.md` (new file - story template with version)
- `packages/orchestrator/src/clients/claude-client.ts` (new file - Claude API wrapper)

**Adjacent:**
- `.claude/commands/pm-generate-story.md` - Command documentation (update to reference new subgraph)

### Endpoints

**None** - This is backend infrastructure, not HTTP API.

The subgraph is invoked via the `/pm-generate-story` CLI command, not via HTTP endpoints.

### Data/Storage

**Reads:**
- Story index file (e.g., `plans/stories/wrkf.stories.index.md`)
- Plan documents (e.g., `PLAN.meta.md`, `PLAN.exec.md`) if referenced in index
- Story template file (`packages/orchestrator/templates/story-template.md`)

**Writes:**
- Story document (e.g., `plans/stories/backlog/wrkf-1041/wrkf-1041.md`)

**No database access** - all I/O is filesystem-based.

## Acceptance Criteria

### AC1: Template Loader Node Reads Template File with Version
**Given** a story template file exists at `packages/orchestrator/templates/story-template.md`
**And** the template includes a version field in its YAML frontmatter (e.g., `template_version: "1.0.0"`)
**When** the template loader node executes
**Then** the template content is loaded into GraphState
**And** the template version is extracted and stored in GraphState
**And** the template contains markdown section headers for all required sections
**And** no file read errors occur

**Validation:**
- Unit test verifies template loader reads file correctly
- Unit test verifies template version extraction from frontmatter
- Integration test confirms GraphState contains both template content and version
- Template file includes required sections: Title, Context, Goal, Non-goals, Scope, Acceptance Criteria, Test Plan, Reuse Plan, Architecture Notes

### AC2: Context Gatherer Node Validates Index Entry Before LLM Call
**Given** a story ID is provided to the context gatherer node
**When** the context gatherer node executes
**Then** the index entry is validated against a Zod schema requiring:
  - `story_id` field (non-empty string)
  - `title` field (non-empty string)
  - `status` field (valid enum value)
  - `feature` field (non-empty string)
**And** if validation fails, the graph halts immediately with error details (fail-fast before LLM call)
**And** if validation passes, the story index entry is extracted and added to GraphState
**And** relevant plan excerpts (architecture notes, reuse strategy) are extracted (max 20KB total)
**And** GraphState contains `storyGenerationContext` with `indexEntry`, `planExcerpts`, and `templateContent` fields

**Validation:**
- Unit test verifies Zod schema validation catches missing/invalid required fields
- Unit test verifies index parsing and plan excerpt extraction for valid entries
- Integration test confirms graph halts before LLM call when index entry invalid
- Error handling test: missing index file returns clear error in GraphState

### AC3: Story Writer Node Generates Complete Story via LLM
**Given** GraphState contains template content and validated story generation context
**When** the story writer node executes (LLM call to Claude)
**Then** a complete story document is generated with all required sections
**And** the story includes valid YAML frontmatter with `status: backlog` and `template_version` matching template
**And** acceptance criteria are concrete and testable (no vague placeholders)
**And** GraphState contains `generatedStoryContent` field with markdown output

**Validation:**
- Integration test with mocked LLM client produces expected story structure
- Manual test with real Claude API generates quality story (reviewed by PM)
- Error handling test: LLM failure returns error in GraphState (no partial file written)

**LLM Configuration:**
- Model: `claude-sonnet-4-5` (cost-effective for story generation)
- Temperature: 0.3 (balance creativity with consistency)
- Max tokens: 8000 (sufficient for long stories)
- Retry on transient errors (rate limit, 5xx) up to 3 times with exponential backoff (1s, 2s, 4s)

### AC4: Validation Node Checks Story Structural Completeness
**Given** a generated story in GraphState
**When** the validation node executes
**Then** the story is checked for required sections (frontmatter, Title, Context, Goal, Acceptance Criteria, etc.)
**And** validation results are added to GraphState (`validationResults` with `isValid`, `errors`, `warnings`)
**And** if validation fails, the graph halts with actionable error messages (e.g., "Missing section: Test Plan")

**Validation:**
- Unit test verifies validation catches missing sections
- Unit test verifies validation accepts complete, well-formed stories
- Integration test confirms graph fails gracefully on validation errors

**Required Sections (Tier 1 - Must-Have):**
- YAML frontmatter (valid, includes `status: backlog` and `template_version`)
- Title
- Context
- Goal
- Non-goals
- Scope
- Acceptance Criteria
- Test Plan
- Reuse Plan
- Architecture Notes

**Optional Sections:**
- UI/UX Notes (required only if UI touched)
- Infrastructure Notes (required only if infra touched)
- HTTP Contract Plan (required only if API impacted)

### AC5: Placeholder Content Detection in Generated Stories
**Given** a generated story in GraphState
**When** the validation node executes
**Then** the story is scanned for common LLM placeholder patterns:
  - "TODO" or "TBD" (case insensitive)
  - "Example: ..." or "e.g., ..." at the start of content sections
  - "[...]" or "[ ]" placeholder brackets
  - "PLACEHOLDER" or "FIXME" (case insensitive)
**And** if placeholders are detected, warnings are added to `validationResults.warnings`
**And** the location of each placeholder is logged (section name, line number)
**And** the graph does NOT halt (warnings only), but placeholders are reported

**Validation:**
- Unit test verifies placeholder detection regex patterns catch all common cases
- Unit test verifies warnings are added to GraphState without halting graph
- Integration test confirms placeholder warnings appear in final output

### AC6: LLM Error Classification and Targeted Retry Strategy
**Given** the story writer node calls the Claude API
**When** an error occurs during the LLM call
**Then** the error is classified into one of the following categories:
  - **Rate Limit**: HTTP 429 status code
  - **Timeout**: Request timeout or connection timeout
  - **Server Error**: HTTP 5xx status codes
  - **Client Error**: HTTP 4xx (non-429) status codes
  - **Invalid Response**: Malformed JSON or missing required fields
**And** retry logic is applied based on error classification:
  - Rate Limit: retry up to 3 times with exponential backoff (1s, 2s, 4s)
  - Timeout: retry up to 3 times with exponential backoff
  - Server Error: retry up to 2 times with exponential backoff
  - Client Error: do NOT retry (fail immediately)
  - Invalid Response: do NOT retry (fail immediately)
**And** the error type and retry count are logged via `@repo/logger`
**And** if all retries fail, the error is propagated to GraphState with classification details

**Validation:**
- Unit test verifies error classification logic for each error type
- Unit test verifies retry counts match strategy (3x for rate limit, 2x for server error, 0x for client error)
- Integration test with mocked failing LLM client confirms retry behavior

### AC7: Story Regeneration Workflow with --force Flag
**Given** the pm_generate_graph subgraph is invoked
**When** a story file already exists at the output path
**Then** the graph checks for a `--force` or `--regenerate` flag in GraphState
**And** if the flag is NOT present, the graph fails with error "Story already exists at {path}. Use --force to overwrite."
**And** if the flag IS present, the existing story is overwritten with the newly generated story
**And** a warning is logged: "Regenerating story {story_id}, overwriting existing file"

**Validation:**
- Integration test verifies graph fails when story exists and no --force flag
- Integration test verifies graph succeeds and overwrites when --force flag present
- Error message includes exact file path for clarity

### AC8: Story File Written to Correct Output Path
**Given** a validated story in GraphState
**When** the validation node passes
**Then** the story is written to `{OUTPUT_DIR}/{STORY_ID}/{STORY_ID}.md` (e.g., `plans/stories/backlog/wrkf-1041/wrkf-1041.md`)
**And** the file write is atomic (write to temp file, rename on success)
**And** no partial or corrupted files are left on disk if write fails

**Validation:**
- Integration test verifies story file exists at expected path after graph completion
- Error handling test: write failure (permissions, disk full) returns error in GraphState without partial file
- Edge case test: existing story file handled via --force flag (AC7)

### AC9: GraphState Extensions for Story Generation
**Given** the base GraphState schema from wrkf-1010
**When** this subgraph extends GraphState
**Then** the following fields are added (Zod schema):
- `storyGenerationContext`: object with `indexEntry: string`, `planExcerpts: string`, `templateContent: string`, `templateVersion: string`
- `generatedStoryContent`: string (markdown output from writer node)
- `validationResults`: object with `isValid: boolean`, `errors: string[]`, `warnings: string[]`
- `forceRegenerate`: boolean (default false, set via CLI flag)

**Validation:**
- Unit test verifies Zod schema validation for new fields
- Type-checking passes (no TypeScript errors on GraphState usage)

### AC10: Error Handling and Fail-Fast Strategy
**Given** any node in the subgraph encounters an error
**When** the error occurs (file not found, LLM failure, validation failure)
**Then** the graph halts immediately (fail-fast)
**And** errors are logged via `@repo/logger` at ERROR level
**And** GraphState contains error details in `errors` array
**And** no downstream nodes execute after error

**Validation:**
- Error handling tests for each error scenario:
  - Story ID not found in index
  - Index file missing
  - Plan file read error (if referenced)
  - Output directory creation fails
  - LLM API error (timeout, rate limit, 5xx)
  - Validation failure (missing required sections)
- Integration test confirms graph halts on first error
- Logs include actionable error messages (file paths, error types, suggested fixes)

### AC11: Integration with Node Runner Infrastructure (wrkf-1020)
**Given** the Node Runner infrastructure from wrkf-1020 provides node factory, error handling, and logging
**When** nodes in this subgraph are created
**Then** they use the node factory pattern from wrkf-1020
**And** error handling and retry logic (for LLM calls) leverage wrkf-1020 infrastructure
**And** all node executions are logged via `@repo/logger`

**Validation:**
- Code review confirms nodes use `createNode()` factory (if available from wrkf-1020)
- Integration test logs show node execution lifecycle (start, complete, error)

### AC12: CLI Command Integration and Documentation
**Given** the pm_generate_graph subgraph is implemented
**When** the `/pm-generate-story` CLI command is invoked
**Then** the command parses CLI arguments (story ID, index path, optional --force flag)
**And** the command constructs initial GraphState with parsed arguments
**And** the command invokes the pm_generate_graph subgraph with GraphState
**And** the command handles subgraph completion (success or error) and outputs results
**And** the `.claude/commands/pm-generate-story.md` documentation is updated to reference the new subgraph

**Validation:**
- Integration test verifies CLI command to subgraph invocation flow
- Manual test confirms CLI command works end-to-end
- Documentation review confirms command documentation is complete and accurate

### AC13: Template Versioning and Validation on Regeneration
**Given** a story template file includes `template_version` in its frontmatter
**And** a generated story includes `template_version` in its frontmatter
**When** the story is regenerated (using --force flag)
**Then** the template version in the template file is compared to the version in the existing story
**And** if versions differ, a warning is logged: "Template version mismatch: story uses v{X}, template is v{Y}"
**And** the regenerated story is stamped with the current template version
**And** the story is regenerated regardless of version mismatch (warning only, not blocking)

**Validation:**
- Unit test verifies version comparison logic
- Integration test confirms warning is logged when versions differ
- Integration test confirms regenerated story has current template version

## Reuse Plan

### Existing Components to Reuse

**From wrkf-1010 (GraphState Schema):**
- Base GraphState Zod schema and type inference
- State validation utilities

**From wrkf-1020 (Node Runner Infrastructure):**
- Node factory pattern (`createNode()` if exposed)
- Error handling and retry logic
- Logging integration (`@repo/logger`)

**From monorepo:**
- `@repo/logger` for consistent logging
- Zod for schema validation (already in orchestrator dependencies)
- Existing Turborepo build pipeline

**From wrkf-1030 (bootstrap_graph - reference implementation):**
- Graph composition patterns (how to define LangGraph edges and nodes)
- Test structure (unit + integration tests for subgraph)
- File I/O patterns (reading index, writing artifacts)

### New Components to Create

**Story Template:**
- `packages/orchestrator/templates/story-template.md` - Markdown template with version in frontmatter

**Utility Modules:**
- `packages/orchestrator/src/utils/file-io.ts` - Read/write utilities with atomic writes
- `packages/orchestrator/src/utils/markdown-parser.ts` - Parse markdown sections, extract frontmatter
- `packages/orchestrator/src/utils/yaml-frontmatter.ts` - Parse/validate YAML frontmatter

**LLM Client Wrapper:**
- `packages/orchestrator/src/clients/claude-client.ts` - Wrapper for Anthropic SDK with retry logic and error classification

**Story Writer Prompt:**
- `packages/orchestrator/src/subgraphs/pm-generate-graph/prompts/story-writer-prompt.ts` - Prompt template for story generation

## Architecture Notes

### Ports & Adapters Alignment

**Ports (Interfaces):**
- **Story Generation Port**: Abstract interface for story generation subgraph
  - Input: Story ID, index path, force regenerate flag
  - Output: Generated story content, validation results

**Adapters (Implementations):**
- **LangGraph Adapter**: Implementation using LangGraphJS for node orchestration
- **Filesystem Adapter**: Read index/plans, write story files
- **LLM Adapter**: Claude API client for story writer node

**Domain Logic (Core):**
- Story validation rules (required sections, frontmatter structure)
- Context extraction logic (index parsing, plan excerpt selection)
- Story structure definition (template)
- Placeholder detection patterns
- Template versioning logic

**Flow:**
```
CLI Command → Story Generation Port → LangGraph Adapter → Nodes (Template Loader → Context Gatherer → Story Writer → Validator) → Filesystem Adapter → Story File
```

This architecture ensures the subgraph is testable (mock adapters for tests) and extensible (swap LangGraph for alternative orchestration if needed).

### Node Execution Flow

```
START
  ↓
Template Loader Node
  - Read story template from filesystem
  - Extract template version
  - Add template and version to GraphState
  ↓
Context Gatherer Node
  - Validate index entry with Zod schema (fail-fast if invalid)
  - Read story index entry
  - Extract relevant plan excerpts (if any)
  - Add context to GraphState
  ↓
Story Writer Node (LLM)
  - Construct prompt from template + context
  - Call Claude API to generate story content
  - Add generated content to GraphState
  - Retry on transient errors with error classification
  ↓
Validator Node
  - Parse generated story
  - Check for required sections
  - Validate YAML frontmatter
  - Detect placeholder content (warnings)
  - Add validation results to GraphState
  - If invalid → ERROR state
  ↓
File Writer (part of Validator or separate node)
  - Check for existing story file
  - If exists and no --force flag → ERROR state
  - Write story to output path (atomic write)
  - If write fails → ERROR state
  ↓
END (SUCCESS or ERROR)
```

### GraphState Schema Extension

```typescript
// Extension to base GraphState from wrkf-1010
const StoryGenerationStateSchema = z.object({
  storyGenerationContext: z.object({
    indexEntry: z.string(),
    planExcerpts: z.string(),
    templateContent: z.string(),
    templateVersion: z.string(),
  }).optional(),

  generatedStoryContent: z.string().optional(),

  validationResults: z.object({
    isValid: z.boolean(),
    errors: z.array(z.string()),
    warnings: z.array(z.string()),
  }).optional(),

  forceRegenerate: z.boolean().default(false),
})

// Merged with base GraphState
type ExtendedGraphState = z.infer<typeof GraphStateSchema> & z.infer<typeof StoryGenerationStateSchema>
```

## Infrastructure Notes

### Dependencies

**Required:**
- LangGraphJS (already in orchestrator package)
- Anthropic SDK (`@anthropic-ai/sdk`) for Claude API access
- Zod for schema validation (already in orchestrator)
- `@repo/logger` for logging

**No new infrastructure** required (Lambda, Aurora, etc.) - runs locally as CLI command.

### Environment Variables

**Required:**
- `ANTHROPIC_API_KEY` - Claude API key for story writer node

**Optional:**
- `STORY_TEMPLATE_PATH` - Override default template location (defaults to `packages/orchestrator/templates/story-template.md`)
- `LOG_LEVEL` - Logging verbosity (DEBUG, INFO, ERROR)

### Runtime Considerations

**Performance:**
- End-to-end graph execution time: ~10-30 seconds (depends on LLM latency)
- Context size: limited to 20KB plan excerpts to manage LLM context window
- LLM call duration: ~5-15 seconds per story (Claude Sonnet 4.5)

**Concurrency:**
- File write operations must be atomic (write to temp, rename) to prevent corruption
- Batch generation (concurrent story generation) deferred to WRKF-1042

**Error Recovery:**
- LLM failures retry based on error classification (AC6)
- File I/O errors fail immediately (no retry) with clear error messages
- Validation failures halt graph with actionable error details

## HTTP Contract Plan

**Not applicable** - This is backend infrastructure, not an HTTP API.

The subgraph is invoked via CLI command (`/pm-generate-story`), not via HTTP endpoints.

## Seed Requirements

**Not applicable** - No database seeding required.

Story generation reads from filesystem (index, plans) and writes to filesystem (story file). No database state involved.

## Test Plan

### Scope Summary

**Endpoints touched:** None (infrastructure code)
**UI touched:** No
**Data/storage touched:** No (filesystem I/O only)

**Components affected:**
- `packages/orchestrator/src/subgraphs/pm-generate-graph/`
- Story generation nodes (template loader, context gatherer, writer, validator)
- LangGraph state management for story generation workflow

### Happy Path Tests

#### Test 1: Generate Story from Valid Index Entry
**Setup:**
- Valid story index entry with status "Pending"
- Output directory exists
- Plan documents available (if referenced)

**Action:**
- Invoke `pm_generate_graph` with story ID
- Graph executes: template loader → context gatherer → story writer → validation

**Expected outcome:**
- Story file created at `{OUTPUT_DIR}/{STORY_ID}/{STORY_ID}.md`
- Story contains all required sections
- Frontmatter has `status: backlog` and `template_version`
- No validation errors

**Evidence:**
- Story file exists at expected path
- All required sections present
- YAML frontmatter valid
- Log shows successful node execution sequence
- GraphState contains expected artifact paths

#### Test 2: Template Version Tracking
**Setup:**
- Story template with `template_version: "1.0.0"`

**Action:**
- Generate story

**Expected outcome:**
- Generated story frontmatter includes `template_version: "1.0.0"`
- Template version matches template file version

**Evidence:**
- Story frontmatter inspection shows template_version field
- Version matches template

#### Test 3: Index Entry Validation Fails Fast
**Setup:**
- Index entry missing required `title` field

**Action:**
- Invoke pm_generate_graph

**Expected outcome:**
- Graph fails before LLM call
- Error message identifies missing field
- No LLM API call logged

**Evidence:**
- Error logged with validation failure details
- No LLM API call in logs
- GraphState contains validation error

#### Test 4: Placeholder Content Detection
**Setup:**
- Mocked LLM response includes "TODO: implement this section"

**Action:**
- Generate story

**Expected outcome:**
- Story is generated successfully (not blocked)
- Validation warnings include placeholder detection
- Warning identifies section and location

**Evidence:**
- Story file written
- GraphState.validationResults.warnings includes placeholder warning

### Error Cases

#### Error 1: Story ID Not Found in Index
**Setup:** Story ID does not exist in index
**Action:** Invoke graph with invalid story ID
**Expected:** Graph fails with "Story not found" error, no output files created
**Evidence:** Error logged with story ID and index path, GraphState status = "failed"

#### Error 2: LLM Rate Limit Error with Retry
**Setup:** Mocked LLM client returns HTTP 429 on first call
**Action:** Execute story writer node
**Expected:** Node retries up to 3 times, succeeds on retry
**Evidence:** Logs show 3 retry attempts with exponential backoff, final success

#### Error 3: Story Already Exists Without --force Flag
**Setup:** Story file exists at output path, no --force flag
**Action:** Invoke graph
**Expected:** Graph fails with "Story already exists" error
**Evidence:** Error message includes file path, file not overwritten

#### Error 4: Story Regeneration with Version Mismatch Warning
**Setup:** Existing story has `template_version: "1.0.0"`, template has `template_version: "1.1.0"`, --force flag present
**Action:** Regenerate story
**Expected:** Warning logged about version mismatch, story regenerated with new version
**Evidence:** Log shows version mismatch warning, regenerated story has `template_version: "1.1.0"`

### Edge Cases

#### Edge 1: Story Entry Has Minimal Information
**Setup:** Index entry contains only required fields (id, title, status, feature)
**Action:** Generate story from minimal index entry
**Expected:** Story generated with available information, passes validation
**Evidence:** Story file created, validation passes

#### Edge 2: Special Characters in Story ID or Paths
**Setup:** Story ID contains special chars or paths contain spaces/unicode
**Action:** Generate story with non-standard ID/paths
**Expected:** Path sanitization occurs or clear error if ID format invalid
**Evidence:** Path validation logged, files created with sanitized names

### Required Tooling Evidence

**Backend (LangGraph Orchestrator):**

**Required test execution:**
- Unit tests for each node (template loader, context gatherer, writer, validator)
- Integration test for full `pm_generate_graph` execution
- Error handling tests for each error case

**Assertions:**
- Node execution order: template → context → writer → validator
- GraphState transitions correctly through nodes
- File I/O operations succeed (read index, write story)
- LLM node receives correct prompt structure
- Validation catches malformed stories
- Error states propagate correctly in GraphState

**Test framework:**
- Vitest for unit and integration tests
- Mocked filesystem for file I/O tests
- Mocked LLM client for writer node tests (deterministic responses)
- Real filesystem in E2E tests (use temp directories)

**Evidence artifacts:**
- Test coverage report (>45% minimum, aim for >80% on new code)
- Sample story outputs from test runs
- Error case logs showing proper error handling
- GraphState snapshots at each node transition

**Frontend:** Not applicable - backend infrastructure only

### Risks to Call Out

**Risk 1: LLM Hallucinations in Story Content**
- **Description:** Story writer may generate incorrect assumptions or invalid technical details
- **Mitigation:** Include codebase context in LLM prompt, validation node checks patterns, placeholder detection, PM review post-generation

**Risk 2: Context Window Management**
- **Description:** Large plan documents may exceed LLM context window
- **Mitigation:** Limit plan excerpts to 20KB, prioritize critical sections, fail gracefully with clear error

**Risk 3: File System Race Conditions**
- **Description:** Concurrent graph executions may corrupt files
- **Mitigation:** Implement atomic writes (write to temp, rename), --force flag prevents accidental overwrites

**Risk 4: Incomplete Validation Coverage**
- **Description:** Validation node may miss critical story quality issues beyond structural completeness
- **Mitigation:** Placeholder detection catches common LLM issues, PM review as final quality gate

**Risk 5: Test Fragility from External Dependencies**
- **Description:** Tests depend on filesystem, LLM mocks, which may be brittle
- **Mitigation:** Use dependency injection, provide test fixtures, document test setup requirements clearly

## UI/UX Notes

**Not applicable** - This story implements backend infrastructure (LangGraph subgraph) with no UI components.

---

## Implementation Checklist (For Dev)

Before creating PR:
- [ ] All unit tests pass locally (`pnpm test`)
- [ ] Integration test passes locally (full graph execution)
- [ ] Lint and type-check pass (`pnpm lint`, `pnpm check-types`)
- [ ] Sample story output committed to `_pm/sample-story.md`
- [ ] GraphState schema changes documented in commit message
- [ ] Prompt template committed to repo
- [ ] README or inline comments explain node responsibilities
- [ ] Error messages are actionable (no generic "Error occurred" messages)
- [ ] Retry logic tested with LLM mock failures
- [ ] File I/O atomic writes tested (no partial files on error)
- [ ] Template versioning tested (AC13)
- [ ] Placeholder detection tested (AC5)
- [ ] LLM error classification tested (AC6)
- [ ] --force flag regeneration tested (AC7)
