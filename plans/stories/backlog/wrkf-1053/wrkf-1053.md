---
story_id: wrkf-1053
title: elab_graph Advanced Features
status: backlog
created: 2026-01-27
updated: 2026-01-27
epic: wrkf
feature: LangGraph Orchestrator - Elaboration Advanced Features
depends_on: [wrkf-1051]
split_from: wrkf-1050
split_part: 3 of 4
related_stories:
  - wrkf-1051 # elab_graph MVP (Core Implementation)
---

# wrkf-1053: elab_graph Advanced Features

## Split Context

This story is part of a split from wrkf-1050.
- **Original Story:** wrkf-1050 (elab_graph Subgraph)
- **Split Reason:** QA Elaboration identified 26 AC (original 8 + 18 additions), exceeding the 8-10 AC threshold. Split into 4 focused stories.
- **This Part:** 3 of 4 (Advanced Features)
- **Dependency:** Depends on wrkf-1051 (elab_graph MVP - Core Implementation)

**Sibling Stories:**
- wrkf-1051: elab_graph MVP (Core Implementation) - PREREQUISITE
- wrkf-1052: elab_graph Observability & Quality
- wrkf-1054: elab_graph Metadata & Linking

## Context

The MVP implementation (wrkf-1051) provides functional elaboration generation, but performance and quality can be significantly improved through advanced techniques:

1. **Parallel Codebase Exploration** - Reduce exploration time from ~30s to ~10s by reading multiple packages concurrently
2. **Embeddings-Based Context Selection** - Use semantic similarity to select the most relevant files, reducing context size and improving focus
3. **Semantic AC Validation** - Upgrade from keyword matching to LLM-based semantic validation for more accurate coverage detection
4. **Incremental Section Updates** - Allow regenerating specific sections (e.g., only AC Breakdown) instead of full elaboration

These features address:
- **Performance** - Large monorepos with many packages benefit from parallel exploration
- **Quality** - Embeddings ensure the most relevant context is included, improving elaboration specificity
- **Accuracy** - Semantic validation catches AC coverage that keyword matching misses
- **Efficiency** - Section-level updates save LLM costs and time when refining elaborations

## Goal

Add performance and feature enhancements to elab_graph including parallel codebase exploration, embeddings-based context selection, semantic AC validation, and incremental section updates to improve speed, quality, accuracy, and efficiency.

**Success Criteria:**
- Parallel exploration reduces codebase reading time by 50-70%
- Embeddings-based selection maintains or improves elaboration quality with smaller context
- Semantic validation detects AC coverage with >95% accuracy (vs ~80% for keyword matching)
- Incremental updates allow section regeneration without full LLM call

## Non-goals

- Codebase indexing or caching (separate optimization - out of scope)
- Visual embeddings or multimodal context (text-based only)
- Real-time incremental updates during elaboration generation (post-generation only)
- Custom embedding models or fine-tuning (use OpenAI or Anthropic embeddings)
- Automated AC validation without PM approval (semantic validation is advisory)

## Scope

### Packages Affected

**Primary:**
- `packages/backend/orchestrator/src/subgraphs/elab-graph/` (extend existing)
  - `nodes/codebase-explorer.ts` - Add parallel exploration
  - `nodes/context-selector.ts` - New node for embeddings-based selection
  - `nodes/semantic-ac-validator.ts` - New node for LLM-based AC validation
  - `nodes/section-regenerator.ts` - New node for incremental section updates
  - `graph.ts` - Update graph for new nodes and flows

**Supporting:**
- `packages/backend/orchestrator/src/core/state/graph-state.ts` (extend with advanced feature fields)
- `packages/backend/orchestrator/src/clients/embeddings-client.ts` - New client for embeddings API

### Endpoints

**None** - This is backend infrastructure, not HTTP API.

### Data/Storage

**Reads:**
- Existing elaboration files (for incremental updates)
- Codebase files (for embeddings generation)

**Writes:**
- Updated elaboration sections (for incremental updates)

## Acceptance Criteria

### AC1: Parallel Codebase Exploration
**Given** the story scope includes multiple packages (3+)
**When** the codebase explorer node executes
**Then** packages are explored in parallel using `Promise.all()` or `p-limit` for concurrency control
**And** exploration time is reduced by 50-70% compared to sequential exploration
**And** context results are aggregated correctly (no data loss)
**And** concurrency limit prevents resource exhaustion (default: 5 concurrent reads)

**Validation:**
- Performance test: 5 packages explored in <15s (vs ~30s sequential)
- Unit test: parallel exploration aggregates context correctly
- Concurrency test: concurrency limit respected (max 5 concurrent reads)
- Error handling: package read failure doesn't block other packages

**Implementation:**
- Use `p-limit` library for concurrency control
- Log exploration time metrics (before/after parallel optimization)

### AC2: Embeddings-Based Context Selection
**Given** the codebase explorer gathers files from packages
**When** context size exceeds 50KB (configurable threshold)
**Then** the context selector node:
1. Generates embeddings for story content (goal + scope + ACs)
2. Generates embeddings for each file in codebase context
3. Computes cosine similarity between story and each file
4. Selects top N most relevant files (default: top 20 files or 50KB, whichever is smaller)
5. Replaces full context with selected files in GraphState
**And** selected context maintains or improves elaboration quality (validated via quality scoring)

**Validation:**
- Unit test: embeddings client generates embeddings for story and files
- Integration test: context selector reduces context size from 100KB to <50KB
- Quality test: elaborations with embeddings-selected context score ≥ elaborations with full context
- Log output shows: "Context reduced: 100KB → 45KB (selected 18 most relevant files)"

**Embeddings API:**
- Use OpenAI `text-embedding-3-small` or Anthropic embeddings (fallback)
- Cache embeddings by file content hash (avoid re-embedding unchanged files)

### AC3: Semantic AC Validation
**Given** elaboration is generated
**When** the semantic AC validator node executes (opt-in via flag `--semantic-validation`)
**Then** the validator:
1. For each AC, constructs a prompt: "Does this elaboration address the following acceptance criterion? [AC text]"
2. Calls Claude API with elaboration content as context
3. LLM responds with boolean (yes/no) and reasoning
4. Validation results include: AC ID, covered (boolean), reasoning
**And** semantic validation achieves >95% accuracy (compared to manual PM review)
**And** validation results are added to GraphState (`semanticValidation`)

**Validation:**
- Unit test: semantic validator calls LLM with correct prompt for each AC
- Integration test: semantic validation correctly identifies covered and missing ACs
- Comparison test: semantic validation detects ACs missed by keyword matching
- False positive test: semantic validation doesn't flag unrelated content as covering AC

**Cost Optimization:**
- Only run semantic validation when keyword validation coverage < 100% (use as refinement step)
- Cache validation results to avoid re-validation on subsequent runs

### AC4: Incremental Section Updates
**Given** an elaboration file exists and PM wants to regenerate a specific section (e.g., "AC Breakdown")
**When** the `/elab-story` command is invoked with `--update-section="AC Breakdown"` flag
**Then** the section regenerator node:
1. Reads existing elaboration from file
2. Parses and extracts the specified section
3. Constructs prompt for section regeneration (story content + codebase context + section name)
4. Calls Claude API to regenerate only the specified section
5. Replaces the section in the existing elaboration (markdown parsing)
6. Writes updated elaboration atomically
**And** other sections in elaboration remain unchanged
**And** section update is logged: "Regenerated section: AC Breakdown (1200 tokens)"

**Validation:**
- Unit test: section regenerator parses elaboration and extracts section correctly
- Integration test: regenerating "AC Breakdown" updates only that section
- Atomicity test: file write failure doesn't corrupt existing elaboration
- Markdown parsing test: section boundaries detected correctly (using headers)

**Section Boundary Detection:**
- Use markdown headers (## Section Name) to identify section boundaries
- Validate section exists before regeneration (error if section not found)

## Reuse Plan

### Existing Components to Reuse

**From wrkf-1051 (elab_graph MVP):**
- Codebase explorer node (extend with parallel exploration)
- Elaboration writer node (reuse for section regeneration)
- GraphState elaboration fields

**From wrkf-1020 (Node Runner Infrastructure):**
- Node factory pattern for new nodes

**From monorepo:**
- `@repo/logger` for logging

### New Components to Create

**Embeddings Client:**
- `src/clients/embeddings-client.ts` - API client for OpenAI or Anthropic embeddings

**Context Selector Node:**
- `src/subgraphs/elab-graph/nodes/context-selector.ts` - Embeddings-based file selection

**Semantic AC Validator Node:**
- `src/subgraphs/elab-graph/nodes/semantic-ac-validator.ts` - LLM-based AC validation

**Section Regenerator Node:**
- `src/subgraphs/elab-graph/nodes/section-regenerator.ts` - Incremental section updates

**Markdown Section Parser:**
- `src/utils/markdown-section-parser.ts` - Parse and extract sections from markdown

## Architecture Notes

### Parallel Exploration Flow

```
START
  ↓
Codebase Explorer Node (Parallel Mode)
  - Split packages into parallel tasks
  - Use p-limit(5) for concurrency control
  - Read each package concurrently: Promise.all([pkg1, pkg2, pkg3, ...])
  - Aggregate results into single codebaseContext
  ↓
Context Selector Node (if context > 50KB)
  - Generate story embedding
  - Generate file embeddings
  - Compute cosine similarity
  - Select top N files
  - Replace codebaseContext with selected files
  ↓
(Continue to Elaboration Writer...)
```

### Advanced GraphState Fields

```typescript
advancedFeatures: z.object({
  parallelExploration: z.object({
    enabled: z.boolean(),
    concurrencyLimit: z.number(),
    explorationTimeMs: z.number(),
  }).optional(),

  embeddingsSelection: z.object({
    enabled: z.boolean(),
    originalContextSizeBytes: z.number(),
    selectedContextSizeBytes: z.number(),
    selectedFileCount: z.number(),
    topFiles: z.array(z.string()), // file paths
  }).optional(),

  semanticValidation: z.object({
    enabled: z.boolean(),
    results: z.array(z.object({
      acId: z.string(),
      covered: z.boolean(),
      reasoning: z.string(),
    })),
  }).optional(),

  sectionUpdate: z.object({
    sectionName: z.string(),
    tokensGenerated: z.number(),
  }).optional(),
}).optional(),
```

## Test Plan

### Happy Path Tests

#### Test 1: Parallel Codebase Exploration
**Setup:** Story scope includes 5 packages
**Action:** Execute codebase explorer with parallel mode enabled
**Expected:** Exploration completes in <15s (vs ~30s sequential), all context aggregated
**Evidence:** Log shows exploration time, GraphState contains all package context

#### Test 2: Embeddings-Based Context Selection
**Setup:** Codebase context is 100KB (exceeds 50KB threshold)
**Action:** Execute context selector node
**Expected:** Context reduced to <50KB, most relevant files selected
**Evidence:** Log shows context reduction, quality score maintained or improved

#### Test 3: Semantic AC Validation
**Setup:** Elaboration generated with ambiguous AC coverage (keyword matching uncertain)
**Action:** Execute semantic AC validator
**Expected:** LLM confirms AC coverage with reasoning
**Evidence:** GraphState contains semantic validation results, AC marked as covered

#### Test 4: Incremental Section Update
**Setup:** Existing elaboration file, PM wants to update "AC Breakdown"
**Action:** Invoke with `--update-section="AC Breakdown"`
**Expected:** Only AC Breakdown section regenerated, other sections unchanged
**Evidence:** File diff shows only AC Breakdown changed, log confirms section update

### Error Cases

#### Error 1: Parallel Exploration with Package Failure
**Setup:** One package unreadable during parallel exploration
**Action:** Execute parallel exploration
**Expected:** Error logged, other packages continue, partial context returned
**Evidence:** Log shows package error, GraphState contains partial context

#### Error 2: Embeddings API Failure
**Setup:** Embeddings API unavailable
**Action:** Execute context selector
**Expected:** Fallback to full context (no embeddings selection), log warning
**Evidence:** Log shows "Embeddings API unavailable, using full context"

#### Error 3: Section Not Found for Update
**Setup:** PM requests update for non-existent section "Foo Bar"
**Action:** Invoke with `--update-section="Foo Bar"`
**Expected:** Error: "Section 'Foo Bar' not found in elaboration"
**Evidence:** Error logged, no file modifications

## UI/UX Notes

**Not applicable** - This is backend infrastructure with CLI interactions only.

---

## Implementation Checklist (For Dev)

Before creating PR:
- [ ] Parallel exploration tested (time reduction verified)
- [ ] Embeddings client tested (generates embeddings correctly)
- [ ] Context selector tested (reduces context size)
- [ ] Semantic validation tested (detects AC coverage)
- [ ] Section regenerator tested (updates specific section only)
- [ ] Markdown section parser tested (boundary detection)
- [ ] All unit tests pass
- [ ] Integration tests with real embeddings API pass
- [ ] Performance benchmarks documented (before/after parallel exploration)
