---
story_id: wrkf-1050
title: elab_graph Subgraph
status: needs-split
created: 2026-01-25
updated: 2026-01-27
epic: wrkf
feature: LangGraph Orchestrator - Story Elaboration Workflow
depends_on: []
related_stories:
  - wrkf-1010 # GraphState Schema
  - wrkf-1020 # Node Runner Infrastructure
  - wrkf-1041 # pm_generate_graph Subgraph - Core Infrastructure (reference implementation)
  - wrkf-1120 # MCP Read Tools (optional dependency)
---

# wrkf-1050: elab_graph Subgraph

## Context

The LangGraph orchestrator requires a subgraph to automate the elaboration of story documents before implementation. Currently, the `/elab-story` command relies on manual or ad-hoc elaboration creation, which is time-consuming and inconsistent. This story implements the `elab_graph` subgraph to orchestrate story elaboration using LangGraph nodes, leveraging existing infrastructure from wrkf-1010 (GraphState) and wrkf-1020 (Node Runner).

The subgraph will:
1. Read a story document and extract its content (title, context, goal, scope, acceptance criteria)
2. Explore the codebase to gather relevant context (package structure, types, existing patterns, test examples)
3. Use an LLM (Claude) to generate detailed elaboration content with implementation guidance
4. Validate that the elaboration addresses all acceptance criteria from the story

This is a critical building block for the orchestrator ecosystem, establishing patterns for codebase exploration and context-aware LLM generation that will be reused in other subgraphs (dev implementation, code review, etc.).

## Goal

Implement the `elab_graph` LangGraph subgraph to automatically generate complete, high-quality elaboration documents from story files, with codebase context integration and acceptance criteria validation to ensure implementation readiness.

**Success Criteria:**
- Elaboration generation completes end-to-end without manual intervention
- Generated elaborations include concrete implementation guidance based on actual codebase patterns
- Subgraph integrates cleanly with existing GraphState and Node Runner infrastructure
- AC validator confirms all acceptance criteria are addressed in elaboration
- Elaboration quality is sufficient for developer implementation (actionable, specific, references actual code)

## Non-goals

- Multi-turn elaboration refinement (v1 generates elaboration in one shot; refinement is out of scope)
- Human-in-the-loop approval before writing elaboration file (manual PM review happens post-generation)
- Elaboration versioning or diff tracking (elaborations are generated once, manual edits tracked via Git)
- Integration with CI/CD for automated elaboration generation (invoked manually via CLI only)
- Semantic quality validation beyond AC coverage (e.g., implementation feasibility assessment) - structural validation only
- Codebase indexing or caching layer (v1 reads files on-demand)
- Visual elaboration (diagrams, flowcharts) - markdown text only
- Git history analysis (codebase explorer reads current state only)
- Integration with external documentation (no fetching from external URLs or knowledge bases)

## Scope

### Packages Affected

**Primary:**
- `packages/backend/orchestrator/src/subgraphs/elab-graph/` (new directory)
  - `index.ts` - Subgraph entry point and graph definition
  - `nodes/story-reader.ts` - Node to read and parse story file
  - `nodes/codebase-explorer.ts` - Node to gather codebase context from relevant packages
  - `nodes/elaboration-writer.ts` - LLM node to generate elaboration content via Claude API
  - `nodes/ac-validator.ts` - Node to validate AC coverage in elaboration
  - `graph.ts` - LangGraph composition and edge definitions
  - `__tests__/` - Unit and integration tests for all nodes and graph

**Supporting:**
- `packages/backend/orchestrator/src/core/state/graph-state.ts` (extend with elaboration fields)
- `packages/backend/orchestrator/src/utils/` (file I/O, markdown parsing utilities - may reuse from wrkf-1041)
- `packages/backend/orchestrator/templates/elaboration-template.md` (new file - elaboration template)
- `packages/backend/orchestrator/src/clients/claude-client.ts` (reuse from wrkf-1041 if exists, or create)

**Adjacent:**
- `.claude/commands/elab-story.md` - Command documentation (may require updates to reference new subgraph)
- `packages/backend/orchestrator/src/adapters/mcp/` (new directory - MCP read tools adapter, if MCP integration included)

### Endpoints

**None** - This is backend infrastructure, not HTTP API.

The subgraph is invoked via the `/elab-story` CLI command, not via HTTP endpoints.

### Data/Storage

**Reads:**
- Story file (e.g., `plans/stories/wrkf/wrkf-1050/wrkf-1050.md`)
- Codebase files from packages listed in story scope (e.g., `packages/backend/orchestrator/src/**/*.ts`)
- Elaboration template file (`packages/backend/orchestrator/templates/elaboration-template.md`)

**Writes:**
- Elaboration document (e.g., `plans/stories/wrkf/wrkf-1050/ELAB-wrkf-1050.md`)

**No database access** - all I/O is filesystem-based.

## Acceptance Criteria

### AC1: Story Reader Node Loads Story Content
**Given** a story file exists at `{FEATURE_DIR}/{STORY_ID}/{STORY_ID}.md`
**And** the story file contains valid YAML frontmatter and required sections
**When** the story reader node executes
**Then** the story content is parsed and loaded into GraphState
**And** GraphState contains `storyContent` with fields: `title`, `context`, `goal`, `scope`, `acceptanceCriteria`
**And** story frontmatter is parsed correctly (story_id, status, dependencies)
**And** no file read errors occur

**Validation:**
- Unit test verifies story reader parses valid story file correctly
- Integration test confirms GraphState contains story content after node execution
- Error handling test: missing story file returns clear error in GraphState
- Error handling test: malformed YAML frontmatter returns parse error with actionable message

### AC2: Codebase Explorer Node Gathers Relevant Context
**Given** GraphState contains story content with scope (packages affected)
**And** relevant packages exist in monorepo (e.g., `packages/backend/orchestrator`)
**When** the codebase explorer node executes
**Then** the node reads relevant files from packages listed in story scope
**And** GraphState contains `codebaseContext` with fields: `filePaths`, `typeDefinitions`, `testPatterns`
**And** codebase context includes package structure and existing patterns
**And** context size does not exceed 100KB total (configurable limit)
**And** file exploration completes within 30 seconds (timeout)

**Validation:**
- Unit test verifies codebase explorer reads files from specified packages
- Integration test confirms GraphState includes codebase context (file paths, type samples)
- Performance test: large package scope (5+ packages) completes within timeout
- Context size test: context does not exceed 100KB limit
- Error handling test: package not found logs warning and continues with available context

**Codebase Explorer Behavior:**
- Reads files matching: `src/**/*.ts`, `src/**/*.tsx`
- Skips: `node_modules/`, `dist/`, `__tests__/` (unless test patterns explicitly requested), `.next/`, `build/`
- Skips files larger than 500KB (configurable limit)
- Logs: files explored (paths, sizes), context size metrics, exploration duration

### AC3: Elaboration Writer Node Generates Complete Elaboration via LLM
**Given** GraphState contains story content and codebase context
**When** the elaboration writer node executes (LLM call to Claude)
**Then** a complete elaboration document is generated with all required sections
**And** the elaboration includes concrete implementation guidance referencing actual codebase patterns
**And** GraphState contains `generatedElaborationContent` field with markdown output
**And** no placeholder text in critical sections (e.g., "TBD", "TODO")

**Validation:**
- Integration test with mocked LLM client produces expected elaboration structure
- Manual test with real Claude API generates quality elaboration (reviewed by PM)
- Error handling test: LLM failure returns error in GraphState (no partial file written)
- Content quality test: elaboration references actual file paths and types from codebase context

**LLM Configuration:**
- Model: `claude-sonnet-4-5` (cost-effective for elaboration generation)
- Temperature: 0.3 (balance creativity with consistency)
- Max tokens: 16000 (sufficient for detailed elaborations)
- Retry on transient errors (rate limit, 5xx) up to 3 times with exponential backoff (1s, 2s, 4s)

**Required Elaboration Sections:**
- Scope (packages, files affected - specific paths)
- Implementation Plan (step-by-step guidance with concrete actions)
- Technical Approach (architecture, patterns, integration points)
- AC Breakdown (each AC with specific implementation notes)
- Reuse Plan (existing utilities, packages to leverage)
- Test Strategy (how to test each AC - unit, integration, E2E)

### AC4: AC Validator Node Checks Elaboration Coverage
**Given** a generated elaboration in GraphState
**When** the AC validator node executes
**Then** the validator checks that all acceptance criteria from story are addressed in elaboration
**And** validation results are added to GraphState (`validationResults` with `isValid`, `coveredACs`, `missingACs`)
**And** if any ACs are not addressed, validation fails with list of missing ACs
**And** if validation fails, the graph halts with actionable error messages (e.g., "Missing coverage for AC3: Elaboration Writer...")

**Validation:**
- Unit test verifies validator detects missing AC coverage
- Unit test verifies validator accepts complete elaboration with all ACs addressed
- Integration test confirms graph halts gracefully on validation failure
- Coverage report test: validator outputs list of covered vs missing ACs

**AC Validator Behavior:**
- Uses keyword matching + section header analysis (not semantic LLM validation)
- Checks for AC ID (e.g., "AC1", "AC2") or AC text in elaboration
- Outputs coverage report: which ACs addressed, which missing, coverage percentage
- Validation failure halts graph with actionable error

### AC5: Elaboration File Written to Correct Output Path
**Given** a validated elaboration in GraphState
**When** the validation node passes
**Then** the elaboration is written to `{FEATURE_DIR}/{STORY_ID}/ELAB-{STORY_ID}.md` (e.g., `plans/stories/wrkf/wrkf-1050/ELAB-wrkf-1050.md`)
**And** the file write is atomic (write to temp file, rename on success)
**And** no partial or corrupted files are left on disk if write fails

**Validation:**
- Integration test verifies elaboration file exists at expected path after graph completion
- Error handling test: write failure (permissions, disk full) returns error in GraphState without partial file
- Edge case test: existing elaboration file causes graph to fail with "Elaboration already exists" error (prevent accidental overwrites)

### AC6: GraphState Extensions for Elaboration Generation
**Given** the base GraphState schema from wrkf-1010
**When** this subgraph extends GraphState
**Then** the following fields are added (Zod schema):
- `storyContent`: object with `title: string`, `context: string`, `goal: string`, `scope: string`, `acceptanceCriteria: string[]`
- `codebaseContext`: object with `filePaths: string[]`, `typeDefinitions: string`, `testPatterns: string`
- `generatedElaborationContent`: string (markdown output from writer node)
- `validationResults`: object with `isValid: boolean`, `coveredACs: string[]`, `missingACs: string[]`, `coveragePercentage: number`

**Validation:**
- Unit test verifies Zod schema validation for new fields
- Type-checking passes (no TypeScript errors on GraphState usage)

### AC7: Error Handling and Fail-Fast Strategy
**Given** any node in the subgraph encounters an error
**When** the error occurs (file not found, LLM failure, validation failure)
**Then** the graph halts immediately (fail-fast)
**And** errors are logged via `@repo/logger` at ERROR level
**And** GraphState contains error details in `errors` array
**And** no downstream nodes execute after error

**Validation:**
- Error handling tests for each error scenario:
  - Story file not found
  - Story file missing required sections (e.g., "Acceptance Criteria")
  - Codebase explorer cannot access package (logs warning, continues)
  - Output directory creation fails
  - LLM API error (timeout, rate limit, 5xx)
  - Validation failure (missing AC coverage)
- Integration test confirms graph halts on first fatal error
- Logs include actionable error messages (file paths, error types, suggested fixes)

**Error Handling Philosophy:**
- Fail-fast for fatal errors (story not found, LLM failure, write failure)
- Graceful degradation for codebase explorer (log warning, continue with partial context if some files unreadable)
- Validation failure halts graph (elaboration not written)

### AC8: Integration with Node Runner Infrastructure (wrkf-1020)
**Given** the Node Runner infrastructure from wrkf-1020 provides node factory, error handling, and logging
**When** nodes in this subgraph are created
**Then** they use the node factory pattern from wrkf-1020 (`createNode()`)
**And** error handling and retry logic (for LLM calls) leverage wrkf-1020 infrastructure
**And** all node executions are logged via `@repo/logger`

**Validation:**
- Code review confirms nodes use `createNode()` factory
- Integration test logs show node execution lifecycle (start, complete, error)

## Reuse Plan

### Existing Components to Reuse

**From wrkf-1010 (GraphState Schema):**
- Base GraphState Zod schema and type inference
- State validation utilities

**From wrkf-1020 (Node Runner Infrastructure):**
- Node factory pattern (`createNode()`)
- Error handling and retry logic
- Logging integration (`@repo/logger`)

**From wrkf-1041 (pm_generate_graph - reference implementation):**
- LLM client wrapper (Claude API integration with retry logic)
- File I/O utilities (read/write with atomic writes)
- Markdown parser utilities (parse sections, extract frontmatter)
- YAML frontmatter parser (validate and extract frontmatter)
- Graph composition patterns (how to define LangGraph edges and nodes)
- Test structure (unit + integration tests for subgraph)

**From monorepo:**
- `@repo/logger` for consistent logging
- Zod for schema validation (already in orchestrator dependencies)
- Existing Turborepo build pipeline

### New Components to Create

**Elaboration Template:**
- `packages/backend/orchestrator/templates/elaboration-template.md` - Markdown template defining elaboration structure

**Codebase Explorer Node:**
- `packages/backend/orchestrator/src/subgraphs/elab-graph/nodes/codebase-explorer.ts` - Novel node to gather codebase context
  - File discovery logic (glob patterns, directory filtering)
  - Context extraction (read file contents, extract types)
  - Context size management (limits, truncation)
  - Performance optimization (timeout, file size limits)

**AC Validator Node:**
- `packages/backend/orchestrator/src/subgraphs/elab-graph/nodes/ac-validator.ts` - Novel node to validate AC coverage
  - AC extraction from story
  - Coverage analysis (keyword matching, section headers)
  - Coverage report generation

**Elaboration Writer Prompt:**
- `packages/backend/orchestrator/src/subgraphs/elab-graph/prompts/elaboration-writer-prompt.ts` - Prompt template for elaboration generation

**MCP Adapter (Optional - Future Enhancement):**
- If wrkf-1120 (MCP Read Tools) is completed, integrate MCP adapter for codebase exploration
- Otherwise, use direct filesystem access for v1

## Architecture Notes

### Ports & Adapters Alignment

**Ports (Interfaces):**
- **Story Elaboration Port**: Abstract interface for elaboration generation subgraph
  - Input: Story ID, feature directory
  - Output: Generated elaboration content, validation results

**Adapters (Implementations):**
- **LangGraph Adapter**: Implementation using LangGraphJS for node orchestration
- **Filesystem Adapter**: Read story files, write elaboration files
- **Codebase Adapter**: Read monorepo packages for context (filesystem or MCP)
- **LLM Adapter**: Claude API client for elaboration writer node

**Domain Logic (Core):**
- Elaboration validation rules (required sections, AC coverage)
- Context extraction logic (file filtering, type extraction)
- Elaboration structure definition (template)

**Flow:**
```
CLI Command → Story Elaboration Port → LangGraph Adapter → Nodes (Story Reader → Codebase Explorer → Elaboration Writer → AC Validator) → Filesystem Adapter → Elaboration File
```

This architecture ensures the subgraph is testable (mock adapters for tests) and extensible (swap LangGraph for alternative orchestration if needed, swap filesystem for MCP adapter).

### Node Execution Flow

```
START
  ↓
Story Reader Node
  - Read story file from filesystem
  - Parse YAML frontmatter and markdown sections
  - Extract: title, context, goal, scope, acceptance criteria
  - Add story content to GraphState
  ↓
Codebase Explorer Node
  - Read packages listed in story scope
  - Filter files (src/**/*.ts, skip dist/, node_modules/)
  - Extract context (file paths, type definitions, test patterns)
  - Apply context size limits (max 100KB)
  - Add codebase context to GraphState
  ↓
Elaboration Writer Node (LLM)
  - Construct prompt from story content + codebase context + template
  - Call Claude API to generate elaboration content
  - Add generated content to GraphState
  - Retry on transient errors (up to 3 times)
  ↓
AC Validator Node
  - Parse generated elaboration
  - Extract acceptance criteria from story
  - Check each AC for coverage in elaboration (keyword matching)
  - Add validation results to GraphState
  - If invalid (missing AC coverage) → ERROR state
  ↓
File Writer (part of AC Validator or separate node)
  - Write elaboration to output path (atomic write)
  - If write fails → ERROR state
  ↓
END (SUCCESS or ERROR)
```

### GraphState Schema Extension

```typescript
// Extension to base GraphState from wrkf-1010
const ElaborationStateSchema = z.object({
  storyContent: z.object({
    title: z.string(),
    context: z.string(),
    goal: z.string(),
    scope: z.string(),
    acceptanceCriteria: z.array(z.string()),
  }).optional(),

  codebaseContext: z.object({
    filePaths: z.array(z.string()),
    typeDefinitions: z.string(),
    testPatterns: z.string(),
  }).optional(),

  generatedElaborationContent: z.string().optional(),

  validationResults: z.object({
    isValid: z.boolean(),
    coveredACs: z.array(z.string()),
    missingACs: z.array(z.string()),
    coveragePercentage: z.number(),
  }).optional(),
})

// Merged with base GraphState
type ExtendedGraphState = z.infer<typeof GraphStateSchema> & z.infer<typeof ElaborationStateSchema>
```

## Infrastructure Notes

### Dependencies

**Required:**
- LangGraphJS (already in orchestrator package)
- Anthropic SDK (`@anthropic-ai/sdk`) for Claude API access
- Zod for schema validation (already in orchestrator)
- `@repo/logger` for logging

**Optional:**
- MCP adapter (if wrkf-1120 completed) for codebase exploration
- Otherwise, use direct filesystem access

### Environment Variables

**Required:**
- `ANTHROPIC_API_KEY` - Claude API key for elaboration writer node

**Optional:**
- `ELABORATION_TEMPLATE_PATH` - Override default template location (defaults to `packages/backend/orchestrator/templates/elaboration-template.md`)
- `CODEBASE_CONTEXT_LIMIT` - Override context size limit (defaults to 100KB)
- `LOG_LEVEL` - Logging verbosity (DEBUG, INFO, ERROR)

### Runtime Considerations

**Performance:**
- End-to-end graph execution time: ~30-60 seconds (depends on codebase exploration + LLM latency)
- Codebase exploration: ~10-20 seconds for typical package scope
- LLM call duration: ~10-30 seconds per elaboration (Claude Sonnet 4.5)
- Context size: limited to 100KB to manage LLM context window and costs

**Concurrency:**
- File write operations must be atomic (write to temp, rename) to prevent corruption
- Consider file locking if concurrent elaboration generation is needed (out of scope for v1)

**Error Recovery:**
- LLM failures retry up to 3 times with exponential backoff
- File I/O errors fail immediately (no retry) with clear error messages
- Codebase explorer errors (file unreadable) log warning and continue with partial context
- Validation failures halt graph with actionable error details

## HTTP Contract Plan

**Not applicable** - This is backend infrastructure, not an HTTP API.

The subgraph is invoked via CLI command (`/elab-story`), not via HTTP endpoints.

## Seed Requirements

**Not applicable** - No database seeding required.

Elaboration generation reads from filesystem (story, codebase) and writes to filesystem (elaboration file). No database state involved.

## Test Plan

(Synthesized from `_pm/TEST-PLAN.md`)

### Scope Summary

**Endpoints touched:** None (backend infrastructure)
**UI touched:** No
**Data/storage touched:** No (filesystem I/O only)

**Components affected:**
- `packages/backend/orchestrator/src/subgraphs/elab-graph/`
- Story elaboration nodes (story reader, codebase explorer, elaboration writer, AC validator)
- LangGraph state management for elaboration workflow

### Happy Path Tests

#### Test 1: Generate Elaboration from Valid Story File
**Setup:**
- Valid story file exists at `{FEATURE_DIR}/{STORY_ID}/{STORY_ID}.md`
- Story contains all required sections (Context, Goal, Scope, Acceptance Criteria)
- Output directory exists

**Action:**
- Invoke `elab_graph` subgraph with story ID
- Graph executes: story reader → codebase explorer → elaboration writer → AC validator

**Expected outcome:**
- Elaboration file created at `{FEATURE_DIR}/{STORY_ID}/ELAB-{STORY_ID}.md`
- Elaboration contains all required sections (Scope, Implementation Plan, Technical Approach, AC Breakdown)
- No validation errors
- GraphState contains expected artifact paths

**Evidence:**
- Elaboration file exists at expected path
- All required sections present in elaboration
- Log shows successful node execution sequence
- GraphState inspection confirms artifact paths populated

#### Test 2: Story Reader Node Loads Story Content
**Setup:**
- Story file exists with valid YAML frontmatter and markdown sections
- Story ID provided in GraphState

**Action:**
- Execute story reader node

**Expected outcome:**
- GraphState populated with story content (title, context, goal, ACs, scope)
- Story frontmatter parsed correctly
- No file read errors

**Evidence:**
- GraphState inspection shows story content loaded
- Log shows successful file read
- Story sections extracted correctly (title, scope, ACs)

#### Test 3: Codebase Explorer Node Gathers Context
**Setup:**
- Story reader has populated GraphState with story scope (packages affected)
- Relevant packages exist in monorepo (e.g., `packages/backend/orchestrator`)

**Action:**
- Execute codebase explorer node
- Node reads relevant package files, types, and existing test patterns

**Expected outcome:**
- GraphState populated with codebase context (file paths, type definitions, test examples)
- Context includes package structure and existing patterns
- Context size within 100KB limit
- No file read errors or permission issues

**Evidence:**
- GraphState inspection shows codebase context loaded
- Log shows files read by explorer
- Context includes type definitions and test patterns from relevant packages
- Context size logged and within limit

#### Test 4: Elaboration Writer Node Produces Complete Elaboration
**Setup:**
- GraphState populated with story content and codebase context
- Output directory exists

**Action:**
- Execute elaboration writer node (LLM call to Claude)

**Expected outcome:**
- Elaboration markdown generated with all required sections
- Content follows elaboration template structure
- Implementation guidance is concrete and actionable
- No placeholder text in critical sections

**Evidence:**
- Elaboration file written to filesystem
- Content includes all required sections (Scope, Implementation Plan, Technical Approach)
- Implementation guidance references actual codebase patterns
- Log shows successful LLM completion

#### Test 5: AC Validator Node Checks Elaboration Completeness
**Setup:**
- Elaboration writer produces complete elaboration

**Action:**
- Execute AC validator node
- Node checks that all acceptance criteria from story are addressed in elaboration

**Expected outcome:**
- Validation passes with all ACs accounted for
- GraphState contains validation results (`isValid: true`, coverage 100%)
- No missing AC coverage

**Evidence:**
- Validation success logged
- GraphState contains validation results
- Elaboration explicitly addresses each acceptance criterion from story

### Error Cases

#### Error 1: Story File Not Found
**Setup:** Story file does not exist at expected path
**Action:** Invoke graph with invalid story path
**Expected:** Graph fails with "Story not found" error, no output files created
**Evidence:** Error logged with story path, GraphState status = "failed"

#### Error 2: Story File Has Missing Required Sections
**Setup:** Story file exists but missing "Acceptance Criteria" section
**Action:** Execute story reader node
**Expected:** Story reader node fails with validation error, clear error message
**Evidence:** Validation error logged, GraphState contains error with missing section name

#### Error 3: Codebase Explorer Cannot Access Package
**Setup:** Story scope references package that doesn't exist or has permission issues
**Action:** Execute codebase explorer node
**Expected:** Node catches file access error, logs warning, continues with available context
**Evidence:** Warning logged with package path, GraphState contains partial context, graph continues

#### Error 4: LLM Node Fails or Times Out
**Setup:** Elaboration writer node encounters LLM API error (rate limit, timeout, etc.)
**Action:** Execute elaboration writer when LLM service unavailable
**Expected:** Node catches LLM error, graph fails gracefully, retry logic triggered
**Evidence:** LLM error logged with error type, GraphState contains LLM failure details, retry attempts logged

#### Error 5: Output Directory Write Permissions Denied
**Setup:** Output directory exists but write permissions denied
**Action:** Attempt to write elaboration file
**Expected:** File write error caught, graph fails with clear error
**Evidence:** Filesystem error logged, GraphState contains write failure, no partial files

#### Error 6: AC Validator Detects Missing Coverage
**Setup:** Elaboration writer produces elaboration that doesn't address all ACs
**Action:** Execute AC validator node
**Expected:** Validation fails with list of uncovered ACs, graph halts
**Evidence:** Validation failure logged, GraphState contains list of missing ACs, error actionable

### Edge Cases

(See `_pm/TEST-PLAN.md` for full edge case list including: story with many dependencies, large story scope, elaboration already exists, story with no scope section, codebase explorer reads large files, special characters in paths)

### Required Tooling Evidence

**Backend (LangGraph Orchestrator):**

**Required test execution:**
- Unit tests for each node (story reader, codebase explorer, elaboration writer, AC validator)
- Integration test for full `elab_graph` execution
- Error handling tests for each error case

**Assertions:**
- Node execution order: story reader → codebase explorer → elaboration writer → AC validator
- GraphState transitions correctly through nodes
- File I/O operations succeed (read story, write elaboration)
- Codebase explorer accesses relevant packages and files
- LLM node receives correct prompt structure with story + codebase context
- AC validator checks each acceptance criterion for coverage
- Error states propagate correctly in GraphState

**Test framework:**
- Vitest for unit and integration tests
- Mocked filesystem for file I/O tests
- Mocked LLM client for elaboration writer tests (deterministic responses)
- Real filesystem in E2E tests (use temp directories and test fixtures)

**Evidence artifacts:**
- Test coverage report (>45% minimum, aim for >80% on new code)
- Sample elaboration outputs from test runs
- Error case logs showing proper error handling
- GraphState snapshots at each node transition
- Codebase explorer context samples (show what files/types were gathered)

## UI/UX Notes

**Not applicable** - This story implements backend infrastructure (LangGraph subgraph) with no UI components.

---

## QA Discovery Notes (for PM Review)

_Added by QA Elaboration on 2026-01-27_

### Summary

QA discovery identified 26 findings (14 gaps + 12 enhancements) during elaboration analysis. User review selected 18 items as new acceptance criteria, bringing total AC count to 26+. This exceeds the healthy 8-10 AC threshold and requires splitting into 4 focused stories:
- **WRKF-1050-A**: MVP (15 AC) - ready-to-work
- **WRKF-1050-B**: Observability & Quality (5 AC) - backlog
- **WRKF-1050-C**: Advanced Features (4 AC) - backlog
- **WRKF-1050-D**: Metadata & Linking (2 AC) - backlog

### Gaps Identified

| # | Finding | User Decision | Notes |
|---|---------|---------------|-------|
| 1 | No LLM cost tracking or observability | Add as AC | Track input/output token counts from Claude API responses. Log to GraphState. Enables cost monitoring. |
| 2 | No elaboration quality metrics | Add as AC | Capture: sections count, AC coverage %, context size, LLM latency, timestamp. Helps identify quality regressions. |
| 3 | Minimum viable context not defined | Add as AC | Fail if <3 packages readable OR <5 total files readable instead of generating low-quality elaboration. |
| 4 | No validation for elaboration file size | Skip | Large elaborations (>100KB) may indicate hallucination. Add size limit: warn if >50KB, fail if >200KB. |
| 5 | Concurrent elaboration generation not addressed | Skip | Race condition possible if two users run `/elab-story` for same story simultaneously. Add file locking. |
| 6 | Edge case: Story with no scope section | Add as AC | Fail fast with clear error "Story missing required 'Scope' section" to force story quality. |
| 7 | LLM prompt not observable for debugging | Add as AC | Store/log full prompt sent to Claude in GraphState. Enables debugging low-quality elaborations. |
| 8 | Temp file cleanup on failure not specified | Add as AC | Ensure temp files cleaned up in error handling or use self-cleaning temp directory. Prevents disk clutter. |
| 9 | MCP integration pathway unclear | Add as AC | Document how to swap implementations if MCP (wrkf-1120) not ready. Provide fallback (direct filesystem). |
| 10 | Codebase context extraction strategy underspecified | Add as AC | Document extraction logic. v1: raw file contents. Label as "TODO: add AST parsing in v2". |
| 11 | No handling for binary files in codebase exploration | Skip | Skip binary files by mime type/extension detection. Log skipped files. |
| 12 | Error message quality not specified | Add as AC | Define standard format: (1) what failed, (2) why it failed, (3) how to fix. |
| 13 | No dry-run mode | Add as AC | Useful for PM to preview elaboration without writing file. Run all nodes, validate, log, skip write. |
| 14 | No incremental elaboration updates | Add as AC | If PM wants to regenerate one section (e.g., "regenerate AC Breakdown"), current design regenerates entire elaboration. |

### Enhancement Opportunities

| # | Finding | User Decision | Notes |
|---|---------|---------------|-------|
| 1 | Interactive elaboration refinement | Add as AC | Allow PM to provide feedback and regenerate specific sections. High value but complex. Consider for v2. |
| 2 | Elaboration diff tracking | Skip | Track diffs between generated and edited versions using Git-style diff. Helps improve prompt template. |
| 3 | Codebase context caching | Skip | Cache context by (package name + git hash). Reduces exploration from ~20s to <1s on cache hit. |
| 4 | Configurable LLM model selection | Skip | Add env var ELABORATION_LLM_MODEL for experimentation. Try Opus (slower, expensive) or Haiku (faster, cheaper). |
| 5 | Elaboration template versioning | Add as AC | Add template_version field to elaboration YAML frontmatter. Enables tracking template evolution. |
| 6 | Parallel codebase exploration | Add as AC | Use Promise.all or p-limit to parallelize multi-package reads. Reduce exploration time from ~30s to ~10s. |
| 7 | Smart context selection with embeddings | Add as AC | Use embeddings to select most relevant files. Reduces context size, improves focus, lowers cost. |
| 8 | Semantic AC validation with LLM | Add as AC | LLM-based validation (more accurate, but slower/higher cost). Recommend: keep keyword matching for v1, add as v2. |
| 9 | Elaboration quality scoring | Add as AC | Score elaborations (0-100) based on completeness, coverage, specificity, actionability. Log to GraphState. |
| 10 | Integration with PM dashboard | Skip | Expose metrics to PM dashboard UI. PM can monitor pipeline health, track costs. Out of scope for backend story. |
| 11 | Elaboration preview before write | Skip | Show PM preview of elaboration content before writing. Requires interactive mode. |
| 12 | Story-to-elaboration linking | Add as AC | Add elaboration_path field to story YAML pointing to elaboration file. Bidirectional navigation. |

### Follow-up Stories Suggested

- [ ] WRKF-1050-A: elab_graph MVP (Core Implementation) - move to ready-to-work
- [ ] WRKF-1050-B: elab_graph Observability & Quality - backlog
- [ ] WRKF-1050-C: elab_graph Advanced Features - backlog
- [ ] WRKF-1050-D: elab_graph Metadata & Linking - backlog

### Items Marked Out-of-Scope

- **File size validation**: User chose to skip (can add later if hallucinations detected)
- **Concurrent elaboration generation**: User chose to skip (complex race condition handling)
- **Elaboration diff tracking**: User chose to skip (can be added post-MVP)
- **Codebase context caching**: User chose to skip (performance optimization for future)
- **Configurable LLM model selection**: User chose to skip (can add as config later)
- **Dashboard integration**: User chose to skip (frontend integration out of scope for backend story)
- **Elaboration preview before write**: User chose to skip (requires interactive mode)
- **Binary file handling**: User chose to skip (can add file type detection later)

---

## Implementation Checklist (For Dev)

Before creating PR:
- [ ] All unit tests pass locally (`pnpm test`)
- [ ] Integration test passes locally (full graph execution)
- [ ] Lint and type-check pass (`pnpm lint`, `pnpm check-types`)
- [ ] Sample elaboration output committed to `_pm/sample-elaboration.md`
- [ ] GraphState schema changes documented in commit message
- [ ] Prompt template committed to repo (if external file)
- [ ] README or inline comments explain node responsibilities
- [ ] Error messages are actionable (no generic "Error occurred" messages)
- [ ] Retry logic tested with LLM mock failures
- [ ] File I/O atomic writes tested (no partial files on error)
- [ ] Codebase explorer context size limits tested
- [ ] AC validator coverage tests pass (detect missing ACs)
