/**
 * {{description}}
 *
 * Generated Lambda handler with JWT validation pre-configured.
 *
 * Features:
 {{#unless (eq authType "none")}}
 * - JWT authentication using @monorepo/lambda-auth
 {{#if (eq authType "enhanced")}}
 * - Enhanced JWT validation (issuer, expiration, audience)
 {{/if}}
 {{#if (eq authType "ownership")}}
 * - Resource ownership validation (user can only access own resources)
 {{/if}}
 {{/unless}}
 * - Zod schema validation for requests and responses
 * - Structured logging with @repo/logger
 * - Automatic error handling with retry logic
 * - Error sanitization for security
 * - CloudWatch metrics and X-Ray tracing
 * - TypeScript strict mode
 */

import { APIGatewayProxyEventV2, APIGatewayProxyResultV2 } from 'aws-lambda'
import { withErrorHandling } from '@/lib/utils/lambda-wrapper'
{{#unless (eq authType "none")}}
import {
  {{#if (eq authType "basic")}}
  validateAuthentication,
  {{/if}}
  {{#if (eq authType "enhanced")}}
  validateAuthentication,
  createDefaultJwtConfig,
  {{/if}}
  {{#if (eq authType "ownership")}}
  validateUserResourceAccess,
  createDefaultJwtConfig,
  {{/if}}
  type AuthError,
} from '@monorepo/lambda-auth'
{{/unless}}
{{#if includeSchemas}}
import { RequestSchema } from './schemas/request'
import { ResponseSchema } from './schemas/response'
{{/if}}
import { successResponse, errorResponse } from '@monorepo/lambda-responses'
import { ValidationError, NotFoundError } from '@monorepo/lambda-responses'
import { logger } from '@repo/logger'

{{#if (or (eq authType "enhanced") (eq authType "ownership"))}}
// JWT Configuration
const JWT_CONFIG = createDefaultJwtConfig(
  '{{cognitoUserPoolId}}',
  '{{awsRegion}}',
  '{{cognitoClientId}}'
)
{{/if}}

/**
 * Internal Lambda handler (wrapped with error handling)
 */
const lambdaHandler = async (
  event: APIGatewayProxyEventV2
): Promise<APIGatewayProxyResultV2> => {
    {{#unless (eq authType "none")}}
    // Step 1: Authentication{{#if (eq authType "ownership")}} and Authorization{{/if}}
    {{#if (eq authType "basic")}}
    const authResult = validateAuthentication(event)
    {{/if}}
    {{#if (eq authType "enhanced")}}
    const authResult = validateAuthentication(event, JWT_CONFIG)
    {{/if}}
    {{#if (eq authType "ownership")}}
    const authResult = validateUserResourceAccess(
      event,
      'id', // Path parameter name (adjust as needed)
      '{{kebabCase name}}', // Resource name for error messages
      JWT_CONFIG
    )
    {{/if}}

    if (!authResult.authenticated{{#if (eq authType "ownership")}} || !authResult.authorized{{/if}}) {
      throw new ValidationError(
        authResult.error?.message || 'Authentication required',
        {
          code: authResult.error?.code,
        }
      )
    }

    const userId = authResult.userId!
    {{#if (or (eq authType "enhanced") (eq authType "ownership"))}}
    const userClaims = authResult.claims
    {{/if}}

    {{/unless}}
    {{#if includeSchemas}}
    // Step {{#if (eq authType "none")}}1{{else}}2{{/if}}: Validate request body (if present)
    let requestData
    if (event.body) {
      const parsedBody = JSON.parse(event.body)
      const validation = RequestSchema.safeParse(parsedBody)

      if (!validation.success) {
        throw new ValidationError(
          `Invalid request: ${validation.error.issues.map(i => i.message).join(', ')}`,
          {
            errors: validation.error.issues,
          }
        )
      }

      requestData = validation.data
    }

    {{/if}}
    // Step {{#if includeSchemas}}{{#if (eq authType "none")}}2{{else}}3{{/if}}{{else}}{{#if (eq authType "none")}}1{{else}}2{{/if}}{{/if}}: Business logic
    {{#unless (eq authType "none")}}
    // TODO: Implement your business logic here
    // You have access to:
    // - userId: string (authenticated user ID)
    {{#if (or (eq authType "enhanced") (eq authType "ownership"))}}
    // - userClaims: CognitoJwtClaims (full JWT claims)
    {{/if}}
    {{#if includeSchemas}}
    // - requestData: validated request data (if body was provided)
    {{/if}}
    // - event: full API Gateway event
    // - context: Lambda context
    {{else}}
    // TODO: Implement your business logic here
    // You have access to:
    {{#if includeSchemas}}
    // - requestData: validated request data (if body was provided)
    {{/if}}
    // - event: full API Gateway event
    // - context: Lambda context
    {{/unless}}

    const result = {
      message: 'Hello from {{pascalCase name}} Lambda!',
      {{#unless (eq authType "none")}}
      userId,
      {{#if (or (eq authType "enhanced") (eq authType "ownership"))}}
      userEmail: userClaims?.email,
      {{/if}}
      {{/unless}}
      {{#if includeSchemas}}
      requestData,
      {{/if}}
      timestamp: new Date().toISOString(),
    }

    {{#if includeSchemas}}
    // Step {{#if includeSchemas}}{{#if (eq authType "none")}}3{{else}}4{{/if}}{{else}}{{#if (eq authType "none")}}2{{else}}3{{/if}}{{/if}}: Validate response
    const responseValidation = ResponseSchema.safeParse(result)
    if (!responseValidation.success) {
      throw new ValidationError('Failed to generate valid response', {
        errors: responseValidation.error.issues,
      })
    }

    {{/if}}
    return successResponse(200, result)
}

/**
 * Main Lambda handler with error handling wrapper
 *
 * The wrapper provides:
 * - Automatic error catching and sanitization
 * - Structured logging with request context
 * - CloudWatch metrics for errors and latency
 * - Error response generation
 */
export const handler = withErrorHandling(lambdaHandler, {
  functionName: '{{kebabCase name}}',
  logRequest: true,
  logResponse: true,
})
