# Story 5.1: Create CloudWatch Dashboards for SST Services

**Epic**: 5 - Production Deployment, Monitoring & Cutover

**As a** DevOps engineer,
**I want** CloudWatch dashboards for all SST Lambda functions,
**so that** I can monitor performance and health in real-time.

## Acceptance Criteria

1. Dashboard created with widgets for each Lambda function (MOC, Gallery, Wishlist, Profile)
2. Metrics displayed: invocation count, duration (p50, p95, p99), error rate, throttles
3. API Gateway metrics: request count, 4xx/5xx errors, latency (p50, p95, p99)
4. Database metrics: RDS connections, CPU, memory, IOPS
5. Redis metrics: cache hit rate, evictions, connections
6. OpenSearch metrics: cluster health, indexing rate, search latency
7. Dashboard deployed via CDK in `infra/monitoring/dashboards.ts`
8. Auto-refresh enabled (1 minute interval)
9. Time range selector: Last 1h, 3h, 6h, 12h, 24h, 7d
10. All metrics use CloudWatch Metrics Insights queries for efficiency

## Implementation Status

**Status**: Not Started

## Files Modified

_To be populated during implementation_

## QA Results

_Pending implementation and review_

---

## Requirements Traceability Matrix

| AC # | Requirement                            | Test Coverage | Status   |
| ---- | -------------------------------------- | ------------- | -------- |
| 1    | Dashboard for each Lambda function     | TBD           | ⏳ PENDING |
| 2    | Lambda metrics (count, duration, errors) | TBD         | ⏳ PENDING |
| 3    | API Gateway metrics                    | TBD           | ⏳ PENDING |
| 4    | RDS metrics                            | TBD           | ⏳ PENDING |
| 5    | Redis metrics                          | TBD           | ⏳ PENDING |
| 6    | OpenSearch metrics                     | TBD           | ⏳ PENDING |
| 7    | CDK deployment                         | TBD           | ⏳ PENDING |
| 8    | Auto-refresh 1 minute                  | TBD           | ⏳ PENDING |
| 9    | Time range selector                    | TBD           | ⏳ PENDING |
| 10   | Metrics Insights queries               | TBD           | ⏳ PENDING |

**Overall Coverage: TBD**

---

## Test Summary

_To be populated during implementation_

### Recommended Test Coverage

1. **Dashboard Creation** - 2 tests
   - Dashboard deployed successfully via CDK
   - Dashboard accessible in CloudWatch console

2. **Metrics Validation** - 5 tests
   - Lambda metrics display correctly
   - API Gateway metrics display correctly
   - RDS metrics display correctly
   - Redis metrics display correctly
   - OpenSearch metrics display correctly

3. **Widget Configuration** - 3 tests
   - Auto-refresh interval set to 1 minute
   - Time range selector includes all required options
   - Metrics Insights queries execute without errors

4. **Performance** - 1 test
   - Dashboard loads in <3 seconds with 24h time range

---

## Technical Notes

### Dashboard Structure

The dashboard is organized into logical sections:

1. **Overview Section** - High-level health indicators
2. **Lambda Functions Section** - Per-function metrics
3. **API Gateway Section** - Request/response metrics
4. **Database Section** - RDS performance
5. **Cache Section** - Redis performance
6. **Search Section** - OpenSearch performance

### CDK Dashboard Definition

```typescript
// infra/monitoring/dashboards.ts
import * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch'
import { Construct } from 'constructs'

export interface DashboardProps {
  readonly mocFunction: lambda.IFunction
  readonly galleryFunction: lambda.IFunction
  readonly wishlistFunction: lambda.IFunction
  readonly profileFunction: lambda.IFunction
  readonly apiGateway: apigatewayv2.IHttpApi
  readonly database: rds.IDatabaseCluster
  readonly redis: elasticache.ICfnCacheCluster
  readonly openSearch: opensearch.IDomain
}

export class LegoApiDashboard extends Construct {
  public readonly dashboard: cloudwatch.Dashboard

  constructor(scope: Construct, id: string, props: DashboardProps) {
    super(scope, id)

    this.dashboard = new cloudwatch.Dashboard(this, 'Dashboard', {
      dashboardName: 'lego-api-sst-production',
      defaultInterval: Duration.minutes(1), // Auto-refresh every 1 minute
      periodOverride: cloudwatch.PeriodOverride.AUTO,
    })

    // Add sections
    this.addOverviewSection(props)
    this.addLambdaSection(props)
    this.addApiGatewaySection(props)
    this.addDatabaseSection(props)
    this.addCacheSection(props)
    this.addSearchSection(props)
  }

  private addOverviewSection(props: DashboardProps): void {
    this.dashboard.addWidgets(
      new cloudwatch.TextWidget({
        markdown: '# LEGO API Production Monitoring\n\nReal-time metrics for SST serverless infrastructure',
        width: 24,
        height: 2,
      }),
    )

    // Overall API health widget
    this.dashboard.addWidgets(
      new cloudwatch.GraphWidget({
        title: 'API Request Volume',
        width: 12,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/ApiGateway',
            metricName: 'Count',
            dimensionsMap: {
              ApiId: props.apiGateway.apiId,
            },
            statistic: cloudwatch.Stats.SUM,
            period: Duration.minutes(1),
            label: 'Total Requests',
          }),
        ],
      }),
      new cloudwatch.GraphWidget({
        title: 'API Error Rate',
        width: 12,
        height: 6,
        left: [
          new cloudwatch.MathExpression({
            expression: '(m1 / m2) * 100',
            usingMetrics: {
              m1: new cloudwatch.Metric({
                namespace: 'AWS/ApiGateway',
                metricName: '5XXError',
                dimensionsMap: { ApiId: props.apiGateway.apiId },
                statistic: cloudwatch.Stats.SUM,
              }),
              m2: new cloudwatch.Metric({
                namespace: 'AWS/ApiGateway',
                metricName: 'Count',
                dimensionsMap: { ApiId: props.apiGateway.apiId },
                statistic: cloudwatch.Stats.SUM,
              }),
            },
            label: '5xx Error Rate (%)',
            period: Duration.minutes(1),
          }),
        ],
      }),
    )
  }

  private addLambdaSection(props: DashboardProps): void {
    this.dashboard.addWidgets(
      new cloudwatch.TextWidget({
        markdown: '## Lambda Functions',
        width: 24,
        height: 1,
      }),
    )

    // Create widgets for each Lambda function
    const functions = [
      { name: 'MOC', func: props.mocFunction },
      { name: 'Gallery', func: props.galleryFunction },
      { name: 'Wishlist', func: props.wishlistFunction },
      { name: 'Profile', func: props.profileFunction },
    ]

    functions.forEach((lambda) => {
      this.dashboard.addWidgets(
        // Invocation count
        new cloudwatch.GraphWidget({
          title: `${lambda.name} - Invocations`,
          width: 6,
          height: 6,
          left: [
            lambda.func.metricInvocations({
              statistic: cloudwatch.Stats.SUM,
              period: Duration.minutes(1),
            }),
          ],
        }),
        // Duration percentiles
        new cloudwatch.GraphWidget({
          title: `${lambda.name} - Duration`,
          width: 6,
          height: 6,
          left: [
            lambda.func.metricDuration({
              statistic: 'p50',
              period: Duration.minutes(1),
              label: 'p50',
            }),
            lambda.func.metricDuration({
              statistic: 'p95',
              period: Duration.minutes(1),
              label: 'p95',
            }),
            lambda.func.metricDuration({
              statistic: 'p99',
              period: Duration.minutes(1),
              label: 'p99',
            }),
          ],
        }),
        // Errors and throttles
        new cloudwatch.GraphWidget({
          title: `${lambda.name} - Errors & Throttles`,
          width: 6,
          height: 6,
          left: [
            lambda.func.metricErrors({
              statistic: cloudwatch.Stats.SUM,
              period: Duration.minutes(1),
              label: 'Errors',
            }),
            lambda.func.metricThrottles({
              statistic: cloudwatch.Stats.SUM,
              period: Duration.minutes(1),
              label: 'Throttles',
            }),
          ],
        }),
        // Concurrent executions
        new cloudwatch.GraphWidget({
          title: `${lambda.name} - Concurrent Executions`,
          width: 6,
          height: 6,
          left: [
            lambda.func.metricConcurrentExecutions({
              statistic: cloudwatch.Stats.MAXIMUM,
              period: Duration.minutes(1),
            }),
          ],
        }),
      )
    })
  }

  private addApiGatewaySection(props: DashboardProps): void {
    this.dashboard.addWidgets(
      new cloudwatch.TextWidget({
        markdown: '## API Gateway',
        width: 24,
        height: 1,
      }),
    )

    this.dashboard.addWidgets(
      // Request count by route
      new cloudwatch.GraphWidget({
        title: 'Requests by Route',
        width: 8,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/ApiGateway',
            metricName: 'Count',
            dimensionsMap: {
              ApiId: props.apiGateway.apiId,
              Stage: '$default',
            },
            statistic: cloudwatch.Stats.SUM,
            period: Duration.minutes(1),
          }),
        ],
      }),
      // Latency percentiles
      new cloudwatch.GraphWidget({
        title: 'API Latency',
        width: 8,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/ApiGateway',
            metricName: 'Latency',
            dimensionsMap: { ApiId: props.apiGateway.apiId },
            statistic: 'p50',
            period: Duration.minutes(1),
            label: 'p50',
          }),
          new cloudwatch.Metric({
            namespace: 'AWS/ApiGateway',
            metricName: 'Latency',
            dimensionsMap: { ApiId: props.apiGateway.apiId },
            statistic: 'p95',
            period: Duration.minutes(1),
            label: 'p95',
          }),
          new cloudwatch.Metric({
            namespace: 'AWS/ApiGateway',
            metricName: 'Latency',
            dimensionsMap: { ApiId: props.apiGateway.apiId },
            statistic: 'p99',
            period: Duration.minutes(1),
            label: 'p99',
          }),
        ],
      }),
      // Error rates (4xx and 5xx)
      new cloudwatch.GraphWidget({
        title: '4xx and 5xx Errors',
        width: 8,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/ApiGateway',
            metricName: '4XXError',
            dimensionsMap: { ApiId: props.apiGateway.apiId },
            statistic: cloudwatch.Stats.SUM,
            period: Duration.minutes(1),
            label: '4xx Errors',
          }),
          new cloudwatch.Metric({
            namespace: 'AWS/ApiGateway',
            metricName: '5XXError',
            dimensionsMap: { ApiId: props.apiGateway.apiId },
            statistic: cloudwatch.Stats.SUM,
            period: Duration.minutes(1),
            label: '5xx Errors',
          }),
        ],
      }),
    )
  }

  private addDatabaseSection(props: DashboardProps): void {
    this.dashboard.addWidgets(
      new cloudwatch.TextWidget({
        markdown: '## RDS PostgreSQL',
        width: 24,
        height: 1,
      }),
    )

    this.dashboard.addWidgets(
      // Database connections
      new cloudwatch.GraphWidget({
        title: 'Database Connections',
        width: 8,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/RDS',
            metricName: 'DatabaseConnections',
            dimensionsMap: {
              DBClusterIdentifier: props.database.clusterIdentifier,
            },
            statistic: cloudwatch.Stats.AVERAGE,
            period: Duration.minutes(1),
          }),
        ],
      }),
      // CPU utilization
      new cloudwatch.GraphWidget({
        title: 'CPU Utilization',
        width: 8,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/RDS',
            metricName: 'CPUUtilization',
            dimensionsMap: {
              DBClusterIdentifier: props.database.clusterIdentifier,
            },
            statistic: cloudwatch.Stats.AVERAGE,
            period: Duration.minutes(1),
          }),
        ],
      }),
      // Freeable memory
      new cloudwatch.GraphWidget({
        title: 'Freeable Memory',
        width: 8,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/RDS',
            metricName: 'FreeableMemory',
            dimensionsMap: {
              DBClusterIdentifier: props.database.clusterIdentifier,
            },
            statistic: cloudwatch.Stats.AVERAGE,
            period: Duration.minutes(1),
          }),
        ],
      }),
    )

    this.dashboard.addWidgets(
      // Read/Write IOPS
      new cloudwatch.GraphWidget({
        title: 'Read/Write IOPS',
        width: 12,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/RDS',
            metricName: 'ReadIOPS',
            dimensionsMap: {
              DBClusterIdentifier: props.database.clusterIdentifier,
            },
            statistic: cloudwatch.Stats.AVERAGE,
            period: Duration.minutes(1),
            label: 'Read IOPS',
          }),
          new cloudwatch.Metric({
            namespace: 'AWS/RDS',
            metricName: 'WriteIOPS',
            dimensionsMap: {
              DBClusterIdentifier: props.database.clusterIdentifier,
            },
            statistic: cloudwatch.Stats.AVERAGE,
            period: Duration.minutes(1),
            label: 'Write IOPS',
          }),
        ],
      }),
      // Read/Write Latency
      new cloudwatch.GraphWidget({
        title: 'Read/Write Latency',
        width: 12,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/RDS',
            metricName: 'ReadLatency',
            dimensionsMap: {
              DBClusterIdentifier: props.database.clusterIdentifier,
            },
            statistic: cloudwatch.Stats.AVERAGE,
            period: Duration.minutes(1),
            label: 'Read Latency',
          }),
          new cloudwatch.Metric({
            namespace: 'AWS/RDS',
            metricName: 'WriteLatency',
            dimensionsMap: {
              DBClusterIdentifier: props.database.clusterIdentifier,
            },
            statistic: cloudwatch.Stats.AVERAGE,
            period: Duration.minutes(1),
            label: 'Write Latency',
          }),
        ],
      }),
    )
  }

  private addCacheSection(props: DashboardProps): void {
    this.dashboard.addWidgets(
      new cloudwatch.TextWidget({
        markdown: '## ElastiCache Redis',
        width: 24,
        height: 1,
      }),
    )

    this.dashboard.addWidgets(
      // Cache hit rate
      new cloudwatch.GraphWidget({
        title: 'Cache Hit Rate',
        width: 8,
        height: 6,
        left: [
          new cloudwatch.MathExpression({
            expression: '(hits / (hits + misses)) * 100',
            usingMetrics: {
              hits: new cloudwatch.Metric({
                namespace: 'AWS/ElastiCache',
                metricName: 'CacheHits',
                dimensionsMap: {
                  CacheClusterId: props.redis.ref,
                },
                statistic: cloudwatch.Stats.SUM,
              }),
              misses: new cloudwatch.Metric({
                namespace: 'AWS/ElastiCache',
                metricName: 'CacheMisses',
                dimensionsMap: {
                  CacheClusterId: props.redis.ref,
                },
                statistic: cloudwatch.Stats.SUM,
              }),
            },
            label: 'Hit Rate (%)',
            period: Duration.minutes(1),
          }),
        ],
      }),
      // Evictions
      new cloudwatch.GraphWidget({
        title: 'Evictions',
        width: 8,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/ElastiCache',
            metricName: 'Evictions',
            dimensionsMap: {
              CacheClusterId: props.redis.ref,
            },
            statistic: cloudwatch.Stats.SUM,
            period: Duration.minutes(1),
          }),
        ],
      }),
      // Connections
      new cloudwatch.GraphWidget({
        title: 'Current Connections',
        width: 8,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/ElastiCache',
            metricName: 'CurrConnections',
            dimensionsMap: {
              CacheClusterId: props.redis.ref,
            },
            statistic: cloudwatch.Stats.AVERAGE,
            period: Duration.minutes(1),
          }),
        ],
      }),
    )

    this.dashboard.addWidgets(
      // CPU utilization
      new cloudwatch.GraphWidget({
        title: 'CPU Utilization',
        width: 12,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/ElastiCache',
            metricName: 'CPUUtilization',
            dimensionsMap: {
              CacheClusterId: props.redis.ref,
            },
            statistic: cloudwatch.Stats.AVERAGE,
            period: Duration.minutes(1),
          }),
        ],
      }),
      // Memory utilization
      new cloudwatch.GraphWidget({
        title: 'Database Memory Usage',
        width: 12,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/ElastiCache',
            metricName: 'DatabaseMemoryUsagePercentage',
            dimensionsMap: {
              CacheClusterId: props.redis.ref,
            },
            statistic: cloudwatch.Stats.AVERAGE,
            period: Duration.minutes(1),
          }),
        ],
      }),
    )
  }

  private addSearchSection(props: DashboardProps): void {
    this.dashboard.addWidgets(
      new cloudwatch.TextWidget({
        markdown: '## OpenSearch',
        width: 24,
        height: 1,
      }),
    )

    this.dashboard.addWidgets(
      // Cluster status
      new cloudwatch.SingleValueWidget({
        title: 'Cluster Status',
        width: 8,
        height: 6,
        metrics: [
          new cloudwatch.Metric({
            namespace: 'AWS/ES',
            metricName: 'ClusterStatus.green',
            dimensionsMap: {
              DomainName: props.openSearch.domainName,
              ClientId: Stack.of(this).account,
            },
            statistic: cloudwatch.Stats.MAXIMUM,
            period: Duration.minutes(1),
          }),
        ],
      }),
      // Indexing rate
      new cloudwatch.GraphWidget({
        title: 'Indexing Rate',
        width: 8,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/ES',
            metricName: 'IndexingRate',
            dimensionsMap: {
              DomainName: props.openSearch.domainName,
              ClientId: Stack.of(this).account,
            },
            statistic: cloudwatch.Stats.AVERAGE,
            period: Duration.minutes(1),
          }),
        ],
      }),
      // Search latency
      new cloudwatch.GraphWidget({
        title: 'Search Latency',
        width: 8,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/ES',
            metricName: 'SearchLatency',
            dimensionsMap: {
              DomainName: props.openSearch.domainName,
              ClientId: Stack.of(this).account,
            },
            statistic: cloudwatch.Stats.AVERAGE,
            period: Duration.minutes(1),
          }),
        ],
      }),
    )

    this.dashboard.addWidgets(
      // CPU utilization
      new cloudwatch.GraphWidget({
        title: 'CPU Utilization',
        width: 12,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/ES',
            metricName: 'CPUUtilization',
            dimensionsMap: {
              DomainName: props.openSearch.domainName,
              ClientId: Stack.of(this).account,
            },
            statistic: cloudwatch.Stats.AVERAGE,
            period: Duration.minutes(1),
          }),
        ],
      }),
      // JVM memory pressure
      new cloudwatch.GraphWidget({
        title: 'JVM Memory Pressure',
        width: 12,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/ES',
            metricName: 'JVMMemoryPressure',
            dimensionsMap: {
              DomainName: props.openSearch.domainName,
              ClientId: Stack.of(this).account,
            },
            statistic: cloudwatch.Stats.MAXIMUM,
            period: Duration.minutes(1),
          }),
        ],
      }),
    )
  }
}
```

### Integration with SST Config

```typescript
// sst.config.ts
import { LegoApiDashboard } from './infra/monitoring/dashboards'

export default $config({
  app(input) {
    return {
      name: 'lego-api',
      removal: input?.stage === 'production' ? 'retain' : 'remove',
      home: 'aws',
    }
  },
  async run() {
    const vpc = new sst.aws.Vpc('LegoVpc')
    const postgres = new sst.aws.Postgres('LegoDatabase', { vpc })
    const redis = new sst.aws.Redis('LegoCache', { vpc })
    const openSearch = new sst.aws.OpenSearch('LegoSearch', { vpc })
    const bucket = new sst.aws.Bucket('LegoFiles')

    // Lambda functions
    const mocFunction = new sst.aws.Function('MocFunction', { ... })
    const galleryFunction = new sst.aws.Function('GalleryFunction', { ... })
    const wishlistFunction = new sst.aws.Function('WishlistFunction', { ... })
    const profileFunction = new sst.aws.Function('ProfileFunction', { ... })

    // API Gateway
    const api = new sst.aws.ApiGatewayV2('LegoApi', { ... })

    // Create CloudWatch dashboard
    const dashboard = new LegoApiDashboard(this, 'LegoApiDashboard', {
      mocFunction,
      galleryFunction,
      wishlistFunction,
      profileFunction,
      apiGateway: api,
      database: postgres,
      redis,
      openSearch,
    })

    return {
      dashboardUrl: `https://console.aws.amazon.com/cloudwatch/home?region=${Stack.of(this).region}#dashboards:name=${dashboard.dashboard.dashboardName}`,
    }
  },
})
```

### CloudWatch Metrics Insights Queries

```typescript
// Use Metrics Insights for advanced queries
new cloudwatch.GraphWidget({
  title: 'Lambda Cold Starts',
  width: 12,
  height: 6,
  left: [
    new cloudwatch.MathExpression({
      expression: `
        SELECT COUNT(Init Duration)
        FROM SCHEMA("AWS/Lambda", FunctionName)
        WHERE FunctionName = '${mocFunction.functionName}'
        GROUP BY FunctionName
      `,
      period: Duration.minutes(5),
      label: 'Cold Starts',
    }),
  ],
})
```

### Response Format

Dashboard URL returned from SST deployment:

```json
{
  "dashboardUrl": "https://console.aws.amazon.com/cloudwatch/home?region=us-east-1#dashboards:name=lego-api-sst-production"
}
```

---

## Design Decisions

### Auto-Refresh Interval: 1 Minute

**Decision**: Set dashboard auto-refresh to 1 minute

**Rationale**:
- Provides near real-time visibility
- Balances freshness with CloudWatch API rate limits
- Standard interval for production monitoring
- Can be overridden by user for faster refresh if needed

### Percentile Metrics for Latency

**Decision**: Display p50, p95, p99 percentiles for duration and latency metrics

**Rationale**:
- p50 (median) shows typical performance
- p95 shows performance for most users
- p99 identifies outliers and tail latency issues
- Industry standard for SLA monitoring

### Organized by Service Layer

**Decision**: Group metrics into sections (Lambda, API Gateway, Database, Cache, Search)

**Rationale**:
- Matches mental model of application architecture
- Easier to diagnose issues by layer
- Each section can be reviewed independently
- Supports team specialization (frontend, backend, database, DevOps)

### Math Expressions for Derived Metrics

**Decision**: Use CloudWatch Math Expressions for calculated metrics (error rate, cache hit rate)

**Rationale**:
- Provides actionable metrics beyond raw counts
- Reduces cognitive load (percentages vs raw numbers)
- Standard practice for CloudWatch dashboards
- Supports alarming on derived metrics

---

## Error Scenarios

| Scenario | Resolution |
|----------|------------|
| Dashboard not visible after deployment | Check IAM permissions for CloudWatch Dashboards |
| Metrics not displaying | Verify Lambda/API Gateway/RDS are sending metrics to CloudWatch |
| "Insufficient data" message | Wait 5-10 minutes for metrics to populate |
| Math expression errors | Validate metric names and dimensions match actual resources |
| Dashboard load timeout | Reduce time range or remove high-cardinality widgets |

---

## Performance Considerations

1. **Widget Count**: Limit to 50 widgets per dashboard (CloudWatch limit is 100)
2. **Time Range**: Default to 1 hour, allow up to 7 days
3. **Metric Resolution**: Use 1-minute periods for recent data, 5-minute for older data
4. **Query Efficiency**: Use Metrics Insights for complex aggregations
5. **Auto-Refresh**: 1 minute interval balances freshness with API rate limits

**Benchmark Targets**:
- Dashboard loads in <3 seconds (1h time range)
- Auto-refresh completes in <2 seconds
- All widgets render without errors

---

## Dependencies

- **AWS CloudWatch**: For metrics and dashboards
- **AWS CDK**: For infrastructure as code
- **SST v3**: For Lambda, API Gateway, RDS, Redis, OpenSearch resources
- **Story 1.1-2.7**: All Lambda functions must be deployed before metrics are available

---

## Future Enhancements

1. **Custom Metrics**: Emit business metrics (MOCs created, images uploaded, wishlist items added)
2. **Anomaly Detection**: Use CloudWatch Anomaly Detection for automated alerting
3. **Dashboard Variables**: Add dropdown filters for environment (dev, staging, prod)
4. **Cross-Region Dashboard**: Aggregate metrics from multiple regions
5. **Embedded Dashboards**: Embed CloudWatch graphs in internal admin UI
6. **Log Insights Integration**: Add widget for common log queries

---

## Related Stories

- **Story 5.2**: CloudWatch Alarms - Use dashboard metrics as alarm data sources
- **Story 5.3**: AWS X-Ray - Add X-Ray trace links to dashboard
- **Story 5.6**: Performance Validation - Use dashboard to validate performance targets
