# Story 4.2: Implement GET /api/users/:id - Retrieve User Profile

**Epic**: 4 - User Profile & Advanced Features Migration

**As a** user,
**I want** to view my profile information,
**so that** I can see my account details and avatar.

## Acceptance Criteria

1. Lambda handler queries AWS Cognito User Pool via `AdminGetUserCommand`
2. Authorization: userId from JWT must match route parameter `:id`
3. User attributes extracted: `sub`, `email`, `name`, `picture` (avatar URL)
4. Response includes aggregated statistics: total MOCs, total gallery images, total wishlist items (queries PostgreSQL)
5. Profile data cached in Redis with key: `profile:user:{userId}`, TTL 10 minutes
6. Response format: `{ success: true, data: { id, email, name, avatarUrl, stats: { mocs, images, wishlistItems } } }`
7. 403 if user attempts to access another user's profile
8. 404 if user not found in Cognito

## Implementation Status

**Status**: Not Started

## Files Modified

_To be populated during implementation_

## QA Results

_Pending implementation and review_

---

## Requirements Traceability Matrix

| AC # | Requirement                            | Test Coverage | Status   |
| ---- | -------------------------------------- | ------------- | -------- |
| 1    | Cognito AdminGetUserCommand            | TBD           | ⏳ PENDING |
| 2    | Authorization userId match             | TBD           | ⏳ PENDING |
| 3    | User attributes extracted              | TBD           | ⏳ PENDING |
| 4    | Aggregated stats from PostgreSQL       | TBD           | ⏳ PENDING |
| 5    | Redis caching (10 min TTL)             | TBD           | ⏳ PENDING |
| 6    | Response format compliance             | TBD           | ⏳ PENDING |
| 7    | 403 for unauthorized access            | TBD           | ⏳ PENDING |
| 8    | 404 for user not found                 | TBD           | ⏳ PENDING |

**Overall Coverage: TBD**

---

## Test Summary

_To be populated during implementation_

### Recommended Test Coverage

1. **Successful Retrieval** - 2 tests
   - Get own profile successfully
   - Cached response verified

2. **Authorization** - 2 tests
   - 403 when accessing another user's profile
   - 401 when JWT missing

3. **User Not Found** - 1 test
   - 404 when Cognito user doesn't exist

4. **Statistics Aggregation** - 1 test
   - Verify stats include correct counts from PostgreSQL

5. **Cache Behavior** - 2 tests
   - First request queries Cognito and PostgreSQL
   - Second request served from cache

---

## Technical Notes

### Cognito Query

```typescript
import { AdminGetUserCommand } from '@aws-sdk/client-cognito-identity-provider'

const command = new AdminGetUserCommand({
  UserPoolId: process.env.COGNITO_USER_POOL_ID,
  Username: userId, // Cognito uses sub as username
})

const response = await cognitoClient.send(command)
```

### Extract User Attributes

```typescript
function extractUserAttributes(cognitoResponse: AdminGetUserCommandOutput): CognitoUserProfile {
  const attrs = cognitoResponse.UserAttributes || []

  return {
    sub: attrs.find(a => a.Name === 'sub')?.Value || '',
    email: attrs.find(a => a.Name === 'email')?.Value || '',
    email_verified: attrs.find(a => a.Name === 'email_verified')?.Value === 'true',
    name: attrs.find(a => a.Name === 'name')?.Value,
    picture: attrs.find(a => a.Name === 'picture')?.Value,
  }
}
```

### Aggregated Statistics Query

```typescript
// Query PostgreSQL for user's content counts
const [mocStats] = await db
  .select({ count: count() })
  .from(mocInstructions)
  .where(eq(mocInstructions.userId, userId))

const [imageStats] = await db
  .select({ count: count() })
  .from(galleryImages)
  .where(eq(galleryImages.userId, userId))

const [wishlistStats] = await db
  .select({ count: count() })
  .from(wishlistItems)
  .where(eq(wishlistItems.userId, userId))

const stats = {
  mocs: Number(mocStats.count),
  images: Number(imageStats.count),
  wishlistItems: Number(wishlistStats.count),
}
```

### Caching Strategy

```typescript
const cacheKey = `profile:user:${userId}`

// Check cache first
const redis = await getRedisClient()
const cached = await redis.get(cacheKey)
if (cached) {
  return createSuccessResponse(JSON.parse(cached))
}

// Fetch from Cognito + PostgreSQL
const cognitoProfile = await getCognitoProfile(userId)
const stats = await getProfileStats(userId)

const profile = {
  id: cognitoProfile.sub,
  email: cognitoProfile.email,
  name: cognitoProfile.name || null,
  avatarUrl: cognitoProfile.picture || null,
  stats,
}

// Cache for 10 minutes
await redis.setEx(cacheKey, 600, JSON.stringify(profile))

return createSuccessResponse(profile)
```

### Response Format

```json
{
  "success": true,
  "data": {
    "id": "cognito-user-sub-uuid",
    "email": "user@example.com",
    "name": "John Doe",
    "avatarUrl": "https://bucket.s3.region.amazonaws.com/avatars/userId/avatar.webp",
    "stats": {
      "mocs": 15,
      "images": 42,
      "wishlistItems": 8
    }
  },
  "timestamp": "2025-01-02T12:00:00Z"
}
```

### Error Handling

```typescript
try {
  const cognitoResponse = await cognitoClient.send(command)
} catch (error) {
  if (error.name === 'UserNotFoundException') {
    return createErrorResponse(404, 'NOT_FOUND', 'User not found')
  }

  console.error('Cognito error:', error)
  return createErrorResponse(500, 'INTERNAL_ERROR', 'Failed to retrieve profile')
}
```

### Authorization Flow

```typescript
async function handleGetProfile(
  event: APIGatewayProxyEventV2,
  userId: string,
  profileId: string,
): Promise<APIGatewayProxyResultV2> {
  // Verify user can only access their own profile
  if (userId !== profileId) {
    return createErrorResponse(403, 'FORBIDDEN', 'Cannot access another user\'s profile')
  }

  // Proceed with profile retrieval
  // ...
}
```

---

## Performance Considerations

1. **Cache First**: Always check Redis before querying Cognito/PostgreSQL
2. **Parallel Queries**: Fetch Cognito profile and PostgreSQL stats in parallel using `Promise.all()`
3. **Cache TTL**: 10 minutes balances freshness with performance
4. **Database Indexes**: Ensure indexes on `userId` columns for stat queries

```typescript
// Parallel fetch for better performance
const [cognitoProfile, stats] = await Promise.all([
  getCognitoProfile(userId),
  getProfileStats(userId),
])
```

---

## Dependencies

- **Story 4.1**: Profile Lambda handler infrastructure (prerequisite)
- **AWS Cognito User Pool**: Must be configured and accessible
- **PostgreSQL Tables**: `mocInstructions`, `galleryImages`, `wishlistItems` must exist
- **Redis**: For caching

---

## Security Considerations

1. **Authorization**: Strict userId matching prevents unauthorized access
2. **No Sensitive Data**: Email verified status not exposed (internal use only)
3. **Cognito Errors**: Never expose Cognito error details to client
4. **Rate Limiting**: Consider implementing if profile endpoint becomes heavily used
