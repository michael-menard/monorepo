# Story 4.5.5: Implement WebSocket Server for Real-Time Updates

**Epic**: 4 - User Profile & Advanced Features Migration

**As a** user,
**I want** to receive real-time progress updates for file uploads and notifications,
**so that** I can see the status of long-running operations without polling.

## Acceptance Criteria

1. AWS API Gateway WebSocket API configured in SST
2. Lambda handlers created for `$connect`, `$disconnect`, `$default` routes
3. DynamoDB table `websocket_connections` stores `connectionId`, `userId`, `connectedAt`
4. JWT authentication enforced on `$connect` (extract userId from token)
5. Connection cleanup on `$disconnect` (remove from DynamoDB)
6. Broadcast helper function `broadcastToUser(userId, message)` for publishing messages
7. Broadcast helper function `broadcastToConnection(connectionId, message)` for direct messaging
8. Support for message types: `upload_progress`, `notification`, `error`
9. WebSocket URL exposed in SST outputs for frontend consumption
10. Lambda timeout: 30 seconds for WebSocket handlers
11. Lambda memory: 256 MB for WebSocket handlers
12. Error handling for invalid JWT, connection failures, DynamoDB errors

## Implementation Status

**Status**: Not Started

## Files Modified

_To be populated during implementation_

## QA Results

_Pending implementation and review_

---

## Requirements Traceability Matrix

| AC # | Requirement                            | Test Coverage | Status   |
| ---- | -------------------------------------- | ------------- | -------- |
| 1    | API Gateway WebSocket configured       | TBD           | ⏳ PENDING |
| 2    | Lambda handlers for routes             | TBD           | ⏳ PENDING |
| 3    | DynamoDB connections table             | TBD           | ⏳ PENDING |
| 4    | JWT authentication on connect          | TBD           | ⏳ PENDING |
| 5    | Connection cleanup on disconnect       | TBD           | ⏳ PENDING |
| 6    | broadcastToUser helper                 | TBD           | ⏳ PENDING |
| 7    | broadcastToConnection helper           | TBD           | ⏳ PENDING |
| 8    | Message type support                   | TBD           | ⏳ PENDING |
| 9    | WebSocket URL in outputs               | TBD           | ⏳ PENDING |
| 10   | Lambda timeout 30 seconds              | TBD           | ⏳ PENDING |
| 11   | Lambda memory 256 MB                   | TBD           | ⏳ PENDING |
| 12   | Error handling                         | TBD           | ⏳ PENDING |

**Overall Coverage: TBD**

---

## Test Summary

_To be populated during implementation_

### Recommended Test Coverage

1. **Connection Management** - 4 tests
   - Connect with valid JWT → stores in DynamoDB
   - Connect with invalid JWT → 401 rejection
   - Disconnect removes connection from DynamoDB
   - Connection record includes userId and timestamp

2. **Broadcasting** - 3 tests
   - broadcastToUser sends to all user connections
   - broadcastToConnection sends to specific connection
   - Broadcast fails gracefully if connection gone

3. **Message Types** - 3 tests
   - upload_progress message delivered correctly
   - notification message delivered correctly
   - error message delivered correctly

4. **Authorization** - 2 tests
   - Only authenticated users can connect
   - JWT expiration closes connection

5. **Cleanup** - 2 tests
   - Stale connections removed after timeout
   - DynamoDB table cleaned on disconnect

---

## Technical Notes

### SST Configuration

```typescript
// sst.config.ts
import { api } from './sst-outputs'

// DynamoDB table for connection tracking
const websocketConnectionsTable = new sst.aws.Dynamo('WebSocketConnections', {
  fields: {
    connectionId: 'string',
    userId: 'string',
  },
  primaryIndex: { hashKey: 'connectionId' },
  globalIndexes: {
    userIdIndex: { hashKey: 'userId', projection: 'all' },
  },
  ttl: 'expiresAt', // Auto-cleanup stale connections after 2 hours
})

// WebSocket API
const websocketApi = new sst.aws.ApiGatewayWebSocket('WebSocketApi', {
  transform: {
    route: {
      handler: {
        link: [websocketConnectionsTable],
        environment: {
          CONNECTIONS_TABLE: websocketConnectionsTable.name,
          COGNITO_USER_POOL_ID: process.env.COGNITO_USER_POOL_ID,
        },
      },
    },
  },
})

// Routes
websocketApi.route('$connect', 'src/functions/websocket/connect.handler')
websocketApi.route('$disconnect', 'src/functions/websocket/disconnect.handler')
websocketApi.route('$default', 'src/functions/websocket/default.handler')

// Output WebSocket URL
return {
  websocketUrl: websocketApi.url,
}
```

### Lambda Handler - $connect

```typescript
// src/functions/websocket/connect.ts
import { APIGatewayProxyWebsocketEventV2, APIGatewayProxyResultV2 } from 'aws-lambda'
import { DynamoDBClient } from '@aws-sdk/client-dynamodb'
import { DynamoDBDocumentClient, PutCommand } from '@aws-sdk/lib-dynamodb'
import { verifyJWT } from '@/lib/auth/jwt'

const dynamodb = DynamoDBDocumentClient.from(new DynamoDBClient({}))

export async function handler(
  event: APIGatewayProxyWebsocketEventV2
): Promise<APIGatewayProxyResultV2> {
  const connectionId = event.requestContext.connectionId
  const queryParams = event.queryStringParameters || {}

  // Extract and verify JWT from query parameters
  const token = queryParams.token
  if (!token) {
    return { statusCode: 401, body: 'Unauthorized: Missing token' }
  }

  let userId: string
  try {
    const decoded = await verifyJWT(token)
    userId = decoded.sub
  } catch (error) {
    console.error('JWT verification failed:', error)
    return { statusCode: 401, body: 'Unauthorized: Invalid token' }
  }

  // Store connection in DynamoDB
  try {
    const expiresAt = Math.floor(Date.now() / 1000) + 7200 // 2 hours TTL

    await dynamodb.send(new PutCommand({
      TableName: process.env.CONNECTIONS_TABLE!,
      Item: {
        connectionId,
        userId,
        connectedAt: new Date().toISOString(),
        expiresAt, // TTL for auto-cleanup
      },
    }))

    console.log(`WebSocket connected: userId=${userId}, connectionId=${connectionId}`)
    return { statusCode: 200, body: 'Connected' }
  } catch (error) {
    console.error('Failed to store connection:', error)
    return { statusCode: 500, body: 'Internal server error' }
  }
}
```

### Lambda Handler - $disconnect

```typescript
// src/functions/websocket/disconnect.ts
import { APIGatewayProxyWebsocketEventV2, APIGatewayProxyResultV2 } from 'aws-lambda'
import { DynamoDBClient } from '@aws-sdk/client-dynamodb'
import { DynamoDBDocumentClient, DeleteCommand } from '@aws-sdk/lib-dynamodb'

const dynamodb = DynamoDBDocumentClient.from(new DynamoDBClient({}))

export async function handler(
  event: APIGatewayProxyWebsocketEventV2
): Promise<APIGatewayProxyResultV2> {
  const connectionId = event.requestContext.connectionId

  try {
    // Remove connection from DynamoDB
    await dynamodb.send(new DeleteCommand({
      TableName: process.env.CONNECTIONS_TABLE!,
      Key: { connectionId },
    }))

    console.log(`WebSocket disconnected: connectionId=${connectionId}`)
    return { statusCode: 200, body: 'Disconnected' }
  } catch (error) {
    console.error('Failed to delete connection:', error)
    return { statusCode: 500, body: 'Internal server error' }
  }
}
```

### Lambda Handler - $default

```typescript
// src/functions/websocket/default.ts
import { APIGatewayProxyWebsocketEventV2, APIGatewayProxyResultV2 } from 'aws-lambda'

export async function handler(
  event: APIGatewayProxyWebsocketEventV2
): Promise<APIGatewayProxyResultV2> {
  // Handle any messages sent from client (optional for now)
  console.log('WebSocket message received:', event.body)

  // For now, just acknowledge
  return { statusCode: 200, body: 'Message received' }
}
```

### Broadcast Helper - broadcastToUser

```typescript
// src/lib/websocket/broadcast.ts
import { ApiGatewayManagementApiClient, PostToConnectionCommand } from '@aws-sdk/client-apigatewaymanagementapi'
import { DynamoDBClient } from '@aws-sdk/client-dynamodb'
import { DynamoDBDocumentClient, QueryCommand, DeleteCommand } from '@aws-sdk/lib-dynamodb'

const dynamodb = DynamoDBDocumentClient.from(new DynamoDBClient({}))

interface WebSocketMessage {
  type: 'upload_progress' | 'notification' | 'error'
  data: any
  timestamp: string
}

export async function broadcastToUser(
  userId: string,
  message: Omit<WebSocketMessage, 'timestamp'>
): Promise<void> {
  // Query all connections for this user
  const result = await dynamodb.send(new QueryCommand({
    TableName: process.env.CONNECTIONS_TABLE!,
    IndexName: 'userIdIndex',
    KeyConditionExpression: 'userId = :userId',
    ExpressionAttributeValues: {
      ':userId': userId,
    },
  }))

  const connections = result.Items || []

  // Broadcast to all user connections
  const promises = connections.map(conn =>
    broadcastToConnection(conn.connectionId, message)
  )

  await Promise.allSettled(promises)
}

export async function broadcastToConnection(
  connectionId: string,
  message: Omit<WebSocketMessage, 'timestamp'>
): Promise<void> {
  // Get WebSocket API endpoint from environment or construct it
  const endpoint = process.env.WEBSOCKET_API_ENDPOINT!

  const client = new ApiGatewayManagementApiClient({
    endpoint,
  })

  const fullMessage: WebSocketMessage = {
    ...message,
    timestamp: new Date().toISOString(),
  }

  try {
    await client.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: Buffer.from(JSON.stringify(fullMessage)),
    }))
  } catch (error: any) {
    // Connection is stale (410 GoneException)
    if (error.statusCode === 410) {
      console.log(`Stale connection detected: ${connectionId}`)

      // Clean up stale connection
      await dynamodb.send(new DeleteCommand({
        TableName: process.env.CONNECTIONS_TABLE!,
        Key: { connectionId },
      }))
    } else {
      console.error('Failed to broadcast message:', error)
      throw error
    }
  }
}
```

### Message Type Schemas

```typescript
// src/lib/websocket/message-types.ts
import { z } from 'zod'

export const UploadProgressMessageSchema = z.object({
  type: z.literal('upload_progress'),
  data: z.object({
    uploadId: z.string(),
    fileName: z.string(),
    progress: z.number().min(0).max(100),
    currentRow: z.number().optional(),
    totalRows: z.number().optional(),
    message: z.string(),
  }),
})

export const NotificationMessageSchema = z.object({
  type: z.literal('notification'),
  data: z.object({
    title: z.string(),
    message: z.string(),
    severity: z.enum(['info', 'success', 'warning', 'error']),
    actionUrl: z.string().optional(),
  }),
})

export const ErrorMessageSchema = z.object({
  type: z.literal('error'),
  data: z.object({
    code: z.string(),
    message: z.string(),
    details: z.any().optional(),
  }),
})

export type UploadProgressMessage = z.infer<typeof UploadProgressMessageSchema>
export type NotificationMessage = z.infer<typeof NotificationMessageSchema>
export type ErrorMessage = z.infer<typeof ErrorMessageSchema>
```

### Usage Example from Lambda

```typescript
// Example: CSV parser Lambda using WebSocket for progress
import { broadcastToUser } from '@/lib/websocket/broadcast'

export async function handler(event: any) {
  const { userId, mocId, s3Key } = JSON.parse(event.body)

  // Send initial progress
  await broadcastToUser(userId, {
    type: 'upload_progress',
    data: {
      uploadId: mocId,
      fileName: 'parts-list.csv',
      progress: 0,
      message: 'Starting CSV parsing...',
    },
  })

  // Parse CSV with progress updates
  const rows = []
  let rowCount = 0

  stream.on('data', async (row) => {
    rows.push(row)
    rowCount++

    // Send progress every 100 rows
    if (rowCount % 100 === 0) {
      await broadcastToUser(userId, {
        type: 'upload_progress',
        data: {
          uploadId: mocId,
          fileName: 'parts-list.csv',
          progress: Math.min(50, (rowCount / 10000) * 50),
          currentRow: rowCount,
          message: `Parsing row ${rowCount}...`,
        },
      })
    }
  })

  // ... continue processing

  // Send completion
  await broadcastToUser(userId, {
    type: 'upload_progress',
    data: {
      uploadId: mocId,
      fileName: 'parts-list.csv',
      progress: 100,
      message: 'CSV parsing complete!',
    },
  })
}
```

---

## Design Decisions

### DynamoDB for Connection Tracking

**Decision**: Use DynamoDB instead of Redis for connection storage

**Rationale**:
- Serverless-native (no VPC required)
- Auto-scaling built-in
- TTL for automatic cleanup of stale connections
- Global secondary index for efficient user lookups
- Cost-effective for connection tracking workload

### JWT in Query Parameters

**Decision**: Pass JWT token in WebSocket connection URL query parameters

**Rationale**:
- WebSocket doesn't support custom headers in browser
- Query parameter is standard WebSocket auth pattern
- Can extract and verify before accepting connection
- Alternative (subprotocol) is less widely supported

**Example Connection URL**:
```
wss://abc123.execute-api.us-east-1.amazonaws.com/production?token=eyJhbGc...
```

### 2-Hour Connection TTL

**Decision**: Auto-expire connections after 2 hours using DynamoDB TTL

**Rationale**:
- Prevents indefinite stale connections
- JWT tokens typically expire in 1 hour
- 2-hour buffer allows for token refresh
- DynamoDB TTL cleanup is automatic and free

### Broadcast to All User Connections

**Decision**: Support multiple simultaneous connections per user

**Rationale**:
- Users may have app open on multiple devices
- Multiple browser tabs should all receive updates
- Query by `userId` via GSI returns all active connections
- Gracefully handles stale connections (410 error cleanup)

---

## Error Scenarios

| Scenario | Status Code | Error Type | Message |
|----------|-------------|------------|---------|
| Successful connection | 200 | N/A | Connected |
| Missing JWT token | 401 | UNAUTHORIZED | Missing token |
| Invalid JWT token | 401 | UNAUTHORIZED | Invalid token |
| Expired JWT token | 401 | UNAUTHORIZED | Token expired |
| DynamoDB store failure | 500 | INTERNAL_ERROR | Internal server error |
| Broadcast to stale connection | 410 | GONE | Connection removed |
| Message delivery failure | 500 | DELIVERY_ERROR | Failed to deliver message |

---

## Frontend Integration

### Connecting to WebSocket

```typescript
// Frontend example (React)
import { useEffect, useState } from 'react'

function useWebSocket(token: string) {
  const [ws, setWs] = useState<WebSocket | null>(null)
  const [messages, setMessages] = useState<any[]>([])

  useEffect(() => {
    const websocketUrl = import.meta.env.VITE_WEBSOCKET_URL
    const socket = new WebSocket(`${websocketUrl}?token=${token}`)

    socket.onopen = () => {
      console.log('WebSocket connected')
    }

    socket.onmessage = (event) => {
      const message = JSON.parse(event.data)
      setMessages(prev => [...prev, message])

      // Handle different message types
      if (message.type === 'upload_progress') {
        console.log('Upload progress:', message.data.progress)
      } else if (message.type === 'notification') {
        console.log('Notification:', message.data.title)
      }
    }

    socket.onerror = (error) => {
      console.error('WebSocket error:', error)
    }

    socket.onclose = () => {
      console.log('WebSocket disconnected')
    }

    setWs(socket)

    return () => {
      socket.close()
    }
  }, [token])

  return { ws, messages }
}
```

---

## Performance Considerations

1. **Connection Limits**: API Gateway WebSocket supports 100K concurrent connections
2. **Message Size**: Max 128KB per message (sufficient for progress updates)
3. **DynamoDB Queries**: GSI on userId allows efficient user connection lookups
4. **Stale Connection Cleanup**: 410 errors automatically remove dead connections
5. **TTL Cleanup**: DynamoDB TTL removes expired connections daily (free)

**Benchmark Targets**:
- Connect latency: <500ms
- Message delivery: <100ms
- Broadcast to 10 connections: <1 second

---

## Database Schema

```typescript
// DynamoDB Table: websocket_connections
{
  connectionId: string        // Primary Key
  userId: string             // GSI Hash Key
  connectedAt: string        // ISO timestamp
  expiresAt: number          // TTL (Unix timestamp)
}

// GSI: userIdIndex
// HashKey: userId
// Projection: ALL
```

---

## Dependencies

- **AWS API Gateway WebSocket API**: For WebSocket connections
- **DynamoDB**: For connection tracking
- **@aws-sdk/client-apigatewaymanagementapi**: For posting messages to connections
- **JWT Verification**: For authentication on connect
- **SST v3**: For infrastructure deployment

---

## Future Enhancements

1. **Presence Detection**: Track user online/offline status
2. **Rooms/Channels**: Subscribe to specific topics (e.g., "moc:123:comments")
3. **Message History**: Store recent messages in DynamoDB for reconnection
4. **Retry Logic**: Automatic reconnection on disconnect
5. **Compression**: Enable WebSocket compression for large messages
6. **Rate Limiting**: Prevent message spam per connection
7. **Admin Broadcast**: Send notifications to all connected users

---

## Security Considerations

1. **JWT Authentication**: Required on all connections
2. **User Isolation**: Messages only sent to authenticated user's connections
3. **Token Expiration**: Connections auto-close when JWT expires
4. **No Sensitive Data**: Avoid sending PII or secrets via WebSocket
5. **Message Validation**: Validate all message payloads with Zod schemas

---

## Related Stories

- **Story 4.6**: CSV Parts List Parser (uses WebSocket for progress)
- **Story 4.7**: Multi-File Upload (uses WebSocket for progress)
- **Story 3.2**: Gallery Image Upload (could be enhanced with progress)
- **Future**: In-app notifications system
