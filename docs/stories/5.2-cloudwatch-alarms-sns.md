# Story 5.2: Configure CloudWatch Alarms and SNS Notifications

**Epic**: 5 - Production Deployment, Monitoring & Cutover

**As a** DevOps engineer,
**I want** CloudWatch alarms with SNS notifications for critical issues,
**so that** the team is alerted immediately when problems occur.

## Acceptance Criteria

1. SNS topic created for production alerts with email subscription
2. Alarms configured for Lambda errors (threshold: >10 errors in 5 minutes)
3. Alarms configured for Lambda throttles (threshold: >5 throttles in 5 minutes)
4. Alarms configured for API Gateway 5xx errors (threshold: >5% error rate)
5. Alarms configured for RDS CPU (threshold: >80% for 10 minutes)
6. Alarms configured for RDS connections (threshold: >80% of max)
7. Alarms configured for Redis evictions (threshold: >100 in 5 minutes)
8. Alarms configured for OpenSearch cluster health (red status)
9. All alarms deployed via CDK in `infra/monitoring/alarms.ts`
10. Alarm actions trigger SNS notifications
11. Alarms include both email and Slack notifications (SNS â†’ Lambda â†’ Slack webhook)

## Implementation Status

**Status**: Not Started

## Files Modified

_To be populated during implementation_

## QA Results

_Pending implementation and review_

---

## Requirements Traceability Matrix

| AC # | Requirement                            | Test Coverage | Status   |
| ---- | -------------------------------------- | ------------- | -------- |
| 1    | SNS topic with email subscription      | TBD           | â³ PENDING |
| 2    | Lambda error alarms (>10 in 5 min)     | TBD           | â³ PENDING |
| 3    | Lambda throttle alarms (>5 in 5 min)   | TBD           | â³ PENDING |
| 4    | API Gateway 5xx alarms (>5% rate)      | TBD           | â³ PENDING |
| 5    | RDS CPU alarms (>80% for 10 min)       | TBD           | â³ PENDING |
| 6    | RDS connection alarms (>80% of max)    | TBD           | â³ PENDING |
| 7    | Redis eviction alarms (>100 in 5 min)  | TBD           | â³ PENDING |
| 8    | OpenSearch health alarm (red status)   | TBD           | â³ PENDING |
| 9    | CDK deployment                         | TBD           | â³ PENDING |
| 10   | SNS alarm actions                      | TBD           | â³ PENDING |
| 11   | Email and Slack notifications          | TBD           | â³ PENDING |

**Overall Coverage: TBD**

---

## Test Summary

_To be populated during implementation_

### Recommended Test Coverage

1. **SNS Topic** - 2 tests
   - SNS topic created successfully
   - Email subscription confirmed

2. **Alarm Creation** - 8 tests
   - Lambda error alarm created
   - Lambda throttle alarm created
   - API Gateway 5xx alarm created
   - RDS CPU alarm created
   - RDS connection alarm created
   - Redis eviction alarm created
   - OpenSearch health alarm created
   - All alarms in OK state initially

3. **Alarm Triggering** - 3 tests
   - Manually trigger alarm (simulate error spike)
   - Verify SNS message sent
   - Verify Slack webhook receives notification

4. **Alarm Recovery** - 1 test
   - Verify alarm returns to OK state when metric recovers

---

## Technical Notes

### SNS Topic Configuration

```typescript
// infra/monitoring/alarms.ts
import * as sns from 'aws-cdk-lib/aws-sns'
import * as subscriptions from 'aws-cdk-lib/aws-sns-subscriptions'
import * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch'
import * as actions from 'aws-cdk-lib/aws-cloudwatch-actions'

export interface AlarmProps {
  readonly mocFunction: lambda.IFunction
  readonly galleryFunction: lambda.IFunction
  readonly wishlistFunction: lambda.IFunction
  readonly profileFunction: lambda.IFunction
  readonly apiGateway: apigatewayv2.IHttpApi
  readonly database: rds.IDatabaseCluster
  readonly redis: elasticache.ICfnCacheCluster
  readonly openSearch: opensearch.IDomain
  readonly emailAddress: string
  readonly slackWebhookUrl?: string
}

export class LegoApiAlarms extends Construct {
  public readonly alarmTopic: sns.Topic

  constructor(scope: Construct, id: string, props: AlarmProps) {
    super(scope, id)

    // Create SNS topic for alarms
    this.alarmTopic = new sns.Topic(this, 'AlarmTopic', {
      topicName: 'lego-api-production-alarms',
      displayName: 'LEGO API Production Alarms',
    })

    // Subscribe email to SNS topic
    this.alarmTopic.addSubscription(
      new subscriptions.EmailSubscription(props.emailAddress),
    )

    // If Slack webhook provided, create Lambda forwarder
    if (props.slackWebhookUrl) {
      this.addSlackIntegration(props.slackWebhookUrl)
    }

    // Create alarms
    this.createLambdaAlarms(props)
    this.createApiGatewayAlarms(props)
    this.createDatabaseAlarms(props)
    this.createCacheAlarms(props)
    this.createSearchAlarms(props)
  }

  private addSlackIntegration(webhookUrl: string): void {
    // Lambda function to forward SNS messages to Slack
    const slackForwarder = new lambda.Function(this, 'SlackForwarder', {
      runtime: lambda.Runtime.NODEJS_20_X,
      handler: 'index.handler',
      code: lambda.Code.fromInline(`
        const https = require('https');

        exports.handler = async (event) => {
          const snsMessage = JSON.parse(event.Records[0].Sns.Message);
          const alarmName = snsMessage.AlarmName;
          const newState = snsMessage.NewStateValue;
          const reason = snsMessage.NewStateReason;
          const timestamp = snsMessage.StateChangeTime;

          const color = newState === 'ALARM' ? 'danger' : 'good';
          const emoji = newState === 'ALARM' ? ':rotating_light:' : ':white_check_mark:';

          const slackPayload = {
            attachments: [
              {
                color: color,
                title: \`\${emoji} CloudWatch Alarm: \${alarmName}\`,
                fields: [
                  { title: 'State', value: newState, short: true },
                  { title: 'Time', value: timestamp, short: true },
                  { title: 'Reason', value: reason, short: false },
                ],
                footer: 'LEGO API Production Monitoring',
                ts: Math.floor(new Date(timestamp).getTime() / 1000),
              },
            ],
          };

          return new Promise((resolve, reject) => {
            const req = https.request('${webhookUrl}', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
            }, (res) => {
              resolve({ statusCode: res.statusCode });
            });

            req.on('error', reject);
            req.write(JSON.stringify(slackPayload));
            req.end();
          });
        };
      `),
      environment: {
        SLACK_WEBHOOK_URL: webhookUrl,
      },
    })

    // Subscribe Lambda to SNS topic
    this.alarmTopic.addSubscription(
      new subscriptions.LambdaSubscription(slackForwarder),
    )
  }

  private createLambdaAlarms(props: AlarmProps): void {
    const functions = [
      { name: 'MOC', func: props.mocFunction },
      { name: 'Gallery', func: props.galleryFunction },
      { name: 'Wishlist', func: props.wishlistFunction },
      { name: 'Profile', func: props.profileFunction },
    ]

    functions.forEach((lambda) => {
      // Error alarm
      const errorAlarm = new cloudwatch.Alarm(this, `${lambda.name}ErrorAlarm`, {
        alarmName: `lego-api-${lambda.name.toLowerCase()}-errors`,
        alarmDescription: `${lambda.name} function has >10 errors in 5 minutes`,
        metric: lambda.func.metricErrors({
          statistic: cloudwatch.Stats.SUM,
          period: Duration.minutes(5),
        }),
        threshold: 10,
        evaluationPeriods: 1,
        comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
        treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING,
      })

      errorAlarm.addAlarmAction(new actions.SnsAction(this.alarmTopic))

      // Throttle alarm
      const throttleAlarm = new cloudwatch.Alarm(this, `${lambda.name}ThrottleAlarm`, {
        alarmName: `lego-api-${lambda.name.toLowerCase()}-throttles`,
        alarmDescription: `${lambda.name} function has >5 throttles in 5 minutes`,
        metric: lambda.func.metricThrottles({
          statistic: cloudwatch.Stats.SUM,
          period: Duration.minutes(5),
        }),
        threshold: 5,
        evaluationPeriods: 1,
        comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
        treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING,
      })

      throttleAlarm.addAlarmAction(new actions.SnsAction(this.alarmTopic))

      // Duration alarm (p99 > 10 seconds)
      const durationAlarm = new cloudwatch.Alarm(this, `${lambda.name}DurationAlarm`, {
        alarmName: `lego-api-${lambda.name.toLowerCase()}-duration`,
        alarmDescription: `${lambda.name} function p99 duration >10 seconds`,
        metric: lambda.func.metricDuration({
          statistic: 'p99',
          period: Duration.minutes(5),
        }),
        threshold: 10000, // 10 seconds in milliseconds
        evaluationPeriods: 2, // Must breach for 2 consecutive periods
        comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
        treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING,
      })

      durationAlarm.addAlarmAction(new actions.SnsAction(this.alarmTopic))
    })
  }

  private createApiGatewayAlarms(props: AlarmProps): void {
    // 5xx error rate alarm (>5%)
    const errorRateAlarm = new cloudwatch.Alarm(this, 'ApiGateway5xxAlarm', {
      alarmName: 'lego-api-gateway-5xx-errors',
      alarmDescription: 'API Gateway 5xx error rate >5%',
      metric: new cloudwatch.MathExpression({
        expression: '(m1 / m2) * 100',
        usingMetrics: {
          m1: new cloudwatch.Metric({
            namespace: 'AWS/ApiGateway',
            metricName: '5XXError',
            dimensionsMap: { ApiId: props.apiGateway.apiId },
            statistic: cloudwatch.Stats.SUM,
            period: Duration.minutes(5),
          }),
          m2: new cloudwatch.Metric({
            namespace: 'AWS/ApiGateway',
            metricName: 'Count',
            dimensionsMap: { ApiId: props.apiGateway.apiId },
            statistic: cloudwatch.Stats.SUM,
            period: Duration.minutes(5),
          }),
        },
        period: Duration.minutes(5),
      }),
      threshold: 5, // 5% error rate
      evaluationPeriods: 2,
      comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
      treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING,
    })

    errorRateAlarm.addAlarmAction(new actions.SnsAction(this.alarmTopic))

    // Latency alarm (p95 > 2 seconds)
    const latencyAlarm = new cloudwatch.Alarm(this, 'ApiGatewayLatencyAlarm', {
      alarmName: 'lego-api-gateway-latency',
      alarmDescription: 'API Gateway p95 latency >2 seconds',
      metric: new cloudwatch.Metric({
        namespace: 'AWS/ApiGateway',
        metricName: 'Latency',
        dimensionsMap: { ApiId: props.apiGateway.apiId },
        statistic: 'p95',
        period: Duration.minutes(5),
      }),
      threshold: 2000, // 2 seconds in milliseconds
      evaluationPeriods: 2,
      comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
      treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING,
    })

    latencyAlarm.addAlarmAction(new actions.SnsAction(this.alarmTopic))
  }

  private createDatabaseAlarms(props: AlarmProps): void {
    // CPU utilization alarm (>80% for 10 minutes)
    const cpuAlarm = new cloudwatch.Alarm(this, 'DatabaseCpuAlarm', {
      alarmName: 'lego-api-database-cpu',
      alarmDescription: 'RDS CPU utilization >80% for 10 minutes',
      metric: new cloudwatch.Metric({
        namespace: 'AWS/RDS',
        metricName: 'CPUUtilization',
        dimensionsMap: {
          DBClusterIdentifier: props.database.clusterIdentifier,
        },
        statistic: cloudwatch.Stats.AVERAGE,
        period: Duration.minutes(5),
      }),
      threshold: 80, // 80%
      evaluationPeriods: 2, // 10 minutes total (2 x 5-minute periods)
      comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
      treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING,
    })

    cpuAlarm.addAlarmAction(new actions.SnsAction(this.alarmTopic))

    // Database connections alarm (>80% of max connections)
    // Assuming max connections is 100 (adjust based on instance type)
    const connectionsAlarm = new cloudwatch.Alarm(this, 'DatabaseConnectionsAlarm', {
      alarmName: 'lego-api-database-connections',
      alarmDescription: 'RDS connections >80 (80% of max)',
      metric: new cloudwatch.Metric({
        namespace: 'AWS/RDS',
        metricName: 'DatabaseConnections',
        dimensionsMap: {
          DBClusterIdentifier: props.database.clusterIdentifier,
        },
        statistic: cloudwatch.Stats.AVERAGE,
        period: Duration.minutes(5),
      }),
      threshold: 80, // 80% of 100 max connections
      evaluationPeriods: 1,
      comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
      treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING,
    })

    connectionsAlarm.addAlarmAction(new actions.SnsAction(this.alarmTopic))

    // Freeable memory alarm (<500 MB)
    const memoryAlarm = new cloudwatch.Alarm(this, 'DatabaseMemoryAlarm', {
      alarmName: 'lego-api-database-memory',
      alarmDescription: 'RDS freeable memory <500 MB',
      metric: new cloudwatch.Metric({
        namespace: 'AWS/RDS',
        metricName: 'FreeableMemory',
        dimensionsMap: {
          DBClusterIdentifier: props.database.clusterIdentifier,
        },
        statistic: cloudwatch.Stats.AVERAGE,
        period: Duration.minutes(5),
      }),
      threshold: 500 * 1024 * 1024, // 500 MB in bytes
      evaluationPeriods: 2,
      comparisonOperator: cloudwatch.ComparisonOperator.LESS_THAN_THRESHOLD,
      treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING,
    })

    memoryAlarm.addAlarmAction(new actions.SnsAction(this.alarmTopic))
  }

  private createCacheAlarms(props: AlarmProps): void {
    // Evictions alarm (>100 in 5 minutes)
    const evictionsAlarm = new cloudwatch.Alarm(this, 'RedisEvictionsAlarm', {
      alarmName: 'lego-api-redis-evictions',
      alarmDescription: 'Redis evictions >100 in 5 minutes',
      metric: new cloudwatch.Metric({
        namespace: 'AWS/ElastiCache',
        metricName: 'Evictions',
        dimensionsMap: {
          CacheClusterId: props.redis.ref,
        },
        statistic: cloudwatch.Stats.SUM,
        period: Duration.minutes(5),
      }),
      threshold: 100,
      evaluationPeriods: 1,
      comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
      treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING,
    })

    evictionsAlarm.addAlarmAction(new actions.SnsAction(this.alarmTopic))

    // CPU utilization alarm (>75%)
    const cpuAlarm = new cloudwatch.Alarm(this, 'RedisCpuAlarm', {
      alarmName: 'lego-api-redis-cpu',
      alarmDescription: 'Redis CPU utilization >75%',
      metric: new cloudwatch.Metric({
        namespace: 'AWS/ElastiCache',
        metricName: 'CPUUtilization',
        dimensionsMap: {
          CacheClusterId: props.redis.ref,
        },
        statistic: cloudwatch.Stats.AVERAGE,
        period: Duration.minutes(5),
      }),
      threshold: 75,
      evaluationPeriods: 2,
      comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
      treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING,
    })

    cpuAlarm.addAlarmAction(new actions.SnsAction(this.alarmTopic))

    // Memory pressure alarm (>75%)
    const memoryAlarm = new cloudwatch.Alarm(this, 'RedisMemoryAlarm', {
      alarmName: 'lego-api-redis-memory',
      alarmDescription: 'Redis memory usage >75%',
      metric: new cloudwatch.Metric({
        namespace: 'AWS/ElastiCache',
        metricName: 'DatabaseMemoryUsagePercentage',
        dimensionsMap: {
          CacheClusterId: props.redis.ref,
        },
        statistic: cloudwatch.Stats.AVERAGE,
        period: Duration.minutes(5),
      }),
      threshold: 75,
      evaluationPeriods: 2,
      comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
      treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING,
    })

    memoryAlarm.addAlarmAction(new actions.SnsAction(this.alarmTopic))
  }

  private createSearchAlarms(props: AlarmProps): void {
    // Cluster status red alarm
    const clusterRedAlarm = new cloudwatch.Alarm(this, 'OpenSearchRedAlarm', {
      alarmName: 'lego-api-opensearch-cluster-red',
      alarmDescription: 'OpenSearch cluster status is RED',
      metric: new cloudwatch.Metric({
        namespace: 'AWS/ES',
        metricName: 'ClusterStatus.red',
        dimensionsMap: {
          DomainName: props.openSearch.domainName,
          ClientId: Stack.of(this).account,
        },
        statistic: cloudwatch.Stats.MAXIMUM,
        period: Duration.minutes(1),
      }),
      threshold: 1, // Red status = 1
      evaluationPeriods: 1,
      comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_OR_EQUAL_TO_THRESHOLD,
      treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING,
    })

    clusterRedAlarm.addAlarmAction(new actions.SnsAction(this.alarmTopic))

    // Cluster status yellow alarm
    const clusterYellowAlarm = new cloudwatch.Alarm(this, 'OpenSearchYellowAlarm', {
      alarmName: 'lego-api-opensearch-cluster-yellow',
      alarmDescription: 'OpenSearch cluster status is YELLOW for 15 minutes',
      metric: new cloudwatch.Metric({
        namespace: 'AWS/ES',
        metricName: 'ClusterStatus.yellow',
        dimensionsMap: {
          DomainName: props.openSearch.domainName,
          ClientId: Stack.of(this).account,
        },
        statistic: cloudwatch.Stats.MAXIMUM,
        period: Duration.minutes(5),
      }),
      threshold: 1,
      evaluationPeriods: 3, // 15 minutes total (3 x 5-minute periods)
      comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_OR_EQUAL_TO_THRESHOLD,
      treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING,
    })

    clusterYellowAlarm.addAlarmAction(new actions.SnsAction(this.alarmTopic))

    // JVM memory pressure alarm (>90%)
    const jvmMemoryAlarm = new cloudwatch.Alarm(this, 'OpenSearchJvmMemoryAlarm', {
      alarmName: 'lego-api-opensearch-jvm-memory',
      alarmDescription: 'OpenSearch JVM memory pressure >90%',
      metric: new cloudwatch.Metric({
        namespace: 'AWS/ES',
        metricName: 'JVMMemoryPressure',
        dimensionsMap: {
          DomainName: props.openSearch.domainName,
          ClientId: Stack.of(this).account,
        },
        statistic: cloudwatch.Stats.MAXIMUM,
        period: Duration.minutes(5),
      }),
      threshold: 90,
      evaluationPeriods: 2,
      comparisonOperator: cloudwatch.ComparisonOperator.GREATER_THAN_THRESHOLD,
      treatMissingData: cloudwatch.TreatMissingData.NOT_BREACHING,
    })

    jvmMemoryAlarm.addAlarmAction(new actions.SnsAction(this.alarmTopic))
  }
}
```

### Integration with SST Config

```typescript
// sst.config.ts
import { LegoApiAlarms } from './infra/monitoring/alarms'

export default $config({
  app(input) {
    return {
      name: 'lego-api',
      removal: input?.stage === 'production' ? 'retain' : 'remove',
      home: 'aws',
    }
  },
  async run() {
    // ... existing resources

    // Create alarms
    const alarms = new LegoApiAlarms(this, 'LegoApiAlarms', {
      mocFunction,
      galleryFunction,
      wishlistFunction,
      profileFunction,
      apiGateway: api,
      database: postgres,
      redis,
      openSearch,
      emailAddress: process.env.ALARM_EMAIL || 'devops@example.com',
      slackWebhookUrl: process.env.SLACK_WEBHOOK_URL,
    })

    return {
      snsTopicArn: alarms.alarmTopic.topicArn,
    }
  },
})
```

### Email Notification Format

```
AlarmName: lego-api-moc-errors
AlarmDescription: MOC function has >10 errors in 5 minutes
AWSAccountId: 123456789012
NewStateValue: ALARM
NewStateReason: Threshold Crossed: 1 datapoint [15.0 (04/01/25 12:05:00)] was greater than the threshold (10.0).
StateChangeTime: 2025-01-04T12:05:00.000+0000
Region: US East (N. Virginia)
AlarmArn: arn:aws:cloudwatch:us-east-1:123456789012:alarm:lego-api-moc-errors
OldStateValue: OK
Trigger:
  MetricName: Errors
  Namespace: AWS/Lambda
  StatisticType: Statistic
  Statistic: SUM
  Unit: null
  Dimensions: [FunctionName: lego-api-MocFunction-xyz123]
  Period: 300
  EvaluationPeriods: 1
  ComparisonOperator: GreaterThanThreshold
  Threshold: 10.0
  TreatMissingData: notBreaching
  EvaluateLowSampleCountPercentile: ignore
```

### Slack Notification Format

```json
{
  "attachments": [
    {
      "color": "danger",
      "title": "ðŸš¨ CloudWatch Alarm: lego-api-moc-errors",
      "fields": [
        { "title": "State", "value": "ALARM", "short": true },
        { "title": "Time", "value": "2025-01-04T12:05:00.000+0000", "short": true },
        { "title": "Reason", "value": "Threshold Crossed: 1 datapoint [15.0] was greater than the threshold (10.0).", "short": false }
      ],
      "footer": "LEGO API Production Monitoring",
      "ts": 1704369900
    }
  ]
}
```

---

## Design Decisions

### Alarm Thresholds

**Decision**: Use conservative thresholds that balance sensitivity with false positives

**Rationale**:
- Lambda errors: >10 in 5 minutes catches sustained issues, not transient spikes
- API 5xx rate: >5% indicates significant degradation
- RDS CPU: >80% for 10 minutes (not just 5) avoids alerts during normal load spikes
- Redis evictions: >100 in 5 minutes indicates memory pressure
- OpenSearch red status: Immediate alert (critical)
- OpenSearch yellow status: Only after 15 minutes (less critical)

**Tuning Process**: Monitor for 2 weeks, adjust thresholds based on false positive rate

### SNS + Slack Integration

**Decision**: Use SNS â†’ Lambda â†’ Slack instead of direct SNS â†’ Slack integration

**Rationale**:
- SNS doesn't natively support Slack webhooks
- Lambda allows custom formatting of Slack messages (attachments, colors, emojis)
- Can add additional logic (throttling, de-duplication, routing)
- Can integrate with PagerDuty or other services in future

**Alternative Considered**: AWS Chatbot (rejected due to limited customization)

### Treat Missing Data as Not Breaching

**Decision**: Set `treatMissingData: TreatMissingData.NOT_BREACHING` for all alarms

**Rationale**:
- Prevents false alarms during low-traffic periods
- Missing data often indicates service is idle, not broken
- Critical services (RDS, OpenSearch) always emit metrics
- Lambda functions may have no invocations = no data (expected)

### Multiple Evaluation Periods for Stability

**Decision**: Use 2 evaluation periods for performance alarms (latency, CPU, memory)

**Rationale**:
- Requires sustained degradation before alerting
- Reduces false positives from transient spikes
- Error/throttle alarms use 1 period (more urgent)
- Balance between responsiveness and noise

---

## Error Scenarios

| Scenario | Resolution |
|----------|------------|
| Email subscription not confirmed | Check email inbox for confirmation link, resend if needed |
| Alarm stuck in "Insufficient data" | Verify metric is being published, check metric dimensions |
| False positive alarms | Adjust threshold or evaluation periods |
| No Slack notifications | Verify webhook URL, check Lambda logs for errors |
| Alarm doesn't trigger SNS | Verify IAM permissions for CloudWatch to publish to SNS |

---

## Alarm Summary Table

| Alarm Name | Metric | Threshold | Period | Evaluation | Severity |
|------------|--------|-----------|--------|------------|----------|
| lego-api-moc-errors | Lambda Errors | >10 | 5 min | 1 | High |
| lego-api-moc-throttles | Lambda Throttles | >5 | 5 min | 1 | High |
| lego-api-moc-duration | Lambda Duration p99 | >10s | 5 min | 2 | Medium |
| lego-api-gateway-5xx-errors | API 5xx Rate | >5% | 5 min | 2 | High |
| lego-api-gateway-latency | API Latency p95 | >2s | 5 min | 2 | Medium |
| lego-api-database-cpu | RDS CPU | >80% | 5 min | 2 (10 min) | Medium |
| lego-api-database-connections | RDS Connections | >80 | 5 min | 1 | High |
| lego-api-database-memory | RDS Memory | <500 MB | 5 min | 2 | Medium |
| lego-api-redis-evictions | Redis Evictions | >100 | 5 min | 1 | Medium |
| lego-api-redis-cpu | Redis CPU | >75% | 5 min | 2 | Medium |
| lego-api-redis-memory | Redis Memory | >75% | 5 min | 2 | Medium |
| lego-api-opensearch-cluster-red | OpenSearch Red | â‰¥1 | 1 min | 1 | Critical |
| lego-api-opensearch-cluster-yellow | OpenSearch Yellow | â‰¥1 | 5 min | 3 (15 min) | Low |
| lego-api-opensearch-jvm-memory | OpenSearch JVM | >90% | 5 min | 2 | Medium |

---

## Performance Considerations

1. **Alarm Evaluation Frequency**: CloudWatch evaluates alarms every minute (minimum)
2. **SNS Message Delivery**: Typically <1 second
3. **Lambda Slack Forwarder**: <500ms execution time
4. **Email Delivery**: 1-5 minutes (depends on email provider)
5. **Alarm State Changes**: Reflected in console within 1 minute

**Benchmark Targets**:
- Alarm triggers within 5 minutes of threshold breach
- Slack notification received within 10 seconds of alarm trigger
- Email notification received within 5 minutes of alarm trigger

---

## Dependencies

- **AWS CloudWatch**: For alarms and metrics
- **AWS SNS**: For notifications
- **AWS Lambda**: For Slack integration
- **AWS CDK**: For infrastructure as code
- **Story 5.1**: CloudWatch Dashboards (provides metrics for alarms)

---

## Environment Variables

```bash
# .env
ALARM_EMAIL=devops@example.com
SLACK_WEBHOOK_URL=https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXX
```

---

## Future Enhancements

1. **PagerDuty Integration**: Add PagerDuty for on-call rotation
2. **Composite Alarms**: Combine multiple alarms (e.g., errors + high latency = critical)
3. **Anomaly Detection Alarms**: Use ML-based anomaly detection instead of static thresholds
4. **Auto-Remediation**: Trigger Lambda to auto-scale resources when alarms fire
5. **Alarm Dashboards**: Create dedicated dashboard showing alarm history
6. **Custom Metrics**: Add business metric alarms (e.g., MOCs created per hour drops >50%)

---

## Related Stories

- **Story 5.1**: CloudWatch Dashboards - Provides metrics visualized in dashboards
- **Story 5.3**: AWS X-Ray - Add tracing for debugging when alarms fire
- **Story 5.6**: Performance Validation - Use alarms to detect performance regressions
