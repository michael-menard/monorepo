# Story 5.3: Implement AWS X-Ray Distributed Tracing

**Epic**: 5 - Production Deployment, Monitoring & Cutover

**As a** DevOps engineer,
**I want** AWS X-Ray tracing enabled for all Lambda functions,
**so that** I can debug performance issues and trace requests across services.

## Acceptance Criteria

1. X-Ray SDK integrated into all Lambda functions (MOC, Gallery, Wishlist, Profile)
2. Tracing enabled in Lambda configuration (`tracingConfig: Active`)
3. Custom segments created for database queries, S3 operations, Redis calls, OpenSearch queries
4. Subsegments capture detailed timing for each operation
5. Metadata and annotations added for filtering (userId, mocId, imageId, etc.)
6. X-Ray service map displays all dependencies (Lambda → RDS, Redis, S3, OpenSearch)
7. Trace retention: 30 days
8. X-Ray sampling rule configured (10% of requests in production)
9. Integration with CloudWatch Logs for error correlation
10. X-Ray dashboard created showing trace analytics

## Implementation Status

**Status**: Not Started

## Files Modified

_To be populated during implementation_

## QA Results

_Pending implementation and review_

---

## Requirements Traceability Matrix

| AC # | Requirement                            | Test Coverage | Status   |
| ---- | -------------------------------------- | ------------- | -------- |
| 1    | X-Ray SDK in all Lambda functions      | TBD           | ⏳ PENDING |
| 2    | Tracing enabled in Lambda config       | TBD           | ⏳ PENDING |
| 3    | Custom segments for operations         | TBD           | ⏳ PENDING |
| 4    | Subsegments for detailed timing        | TBD           | ⏳ PENDING |
| 5    | Metadata and annotations               | TBD           | ⏳ PENDING |
| 6    | Service map with dependencies          | TBD           | ⏳ PENDING |
| 7    | 30-day trace retention                 | TBD           | ⏳ PENDING |
| 8    | 10% sampling rule                      | TBD           | ⏳ PENDING |
| 9    | CloudWatch Logs integration            | TBD           | ⏳ PENDING |
| 10   | X-Ray dashboard with analytics         | TBD           | ⏳ PENDING |

**Overall Coverage: TBD**

---

## Test Summary

_To be populated during implementation_

### Recommended Test Coverage

1. **X-Ray Integration** - 4 tests
   - Verify X-Ray enabled for MOC Lambda
   - Verify X-Ray enabled for Gallery Lambda
   - Verify X-Ray enabled for Wishlist Lambda
   - Verify X-Ray enabled for Profile Lambda

2. **Trace Capture** - 5 tests
   - Database query segment captured
   - S3 operation segment captured
   - Redis operation segment captured
   - OpenSearch query segment captured
   - Verify trace appears in X-Ray console

3. **Annotations and Metadata** - 3 tests
   - UserId annotation present in traces
   - ResourceId (mocId, imageId) metadata present
   - Error traces include exception details

4. **Service Map** - 1 test
   - Service map displays all dependencies (Lambda, RDS, Redis, S3, OpenSearch)

---

## Technical Notes

### X-Ray SDK Installation

```bash
npm install aws-xray-sdk-core
```

### Lambda Configuration for X-Ray

```typescript
// sst.config.ts
const mocFunction = new sst.aws.Function('MocFunction', {
  handler: 'src/functions/moc-instructions.handler',
  runtime: 'nodejs20.x',
  timeout: '60 seconds',
  memory: '1024 MB',
  vpc,
  link: [postgres, redis, openSearch, bucket],
  environment: {
    NODE_ENV: stage === 'production' ? 'production' : 'development',
    STAGE: stage,
  },
  // Enable X-Ray tracing
  tracing: 'Active', // SST v3 syntax
})
```

### X-Ray SDK Initialization

```typescript
// src/lib/tracing/xray-client.ts
import AWSXRay from 'aws-xray-sdk-core'
import { captureAWSv3Client } from 'aws-xray-sdk-core'
import { S3Client } from '@aws-sdk/client-s3'
import { DynamoDBClient } from '@aws-sdk/client-dynamodb'

// Capture AWS SDK v3 clients
export function getTracedS3Client(): S3Client {
  const s3Client = new S3Client({ region: process.env.AWS_REGION })
  return captureAWSv3Client(s3Client)
}

// Capture HTTP requests
AWSXRay.captureHTTPsGlobal(require('https'))
AWSXRay.captureHTTPsGlobal(require('http'))

// Capture PostgreSQL queries
import { Pool } from 'pg'
AWSXRay.capturePostgres(Pool)

// Capture Redis operations
import { createClient } from 'redis'
const redis = createClient({ url: process.env.REDIS_URL })
AWSXRay.capturePromise()

export { AWSXRay }
```

### Custom Segments and Subsegments

```typescript
// src/functions/moc-instructions.ts
import { AWSXRay } from '@/lib/tracing/xray-client'

export const handler = async (event: APIGatewayProxyEventV2): Promise<APIGatewayProxyResultV2> => {
  // X-Ray automatically creates root segment for Lambda invocations

  const userId = getUserIdFromEvent(event)
  const mocId = event.pathParameters?.id

  // Add annotations (indexed, searchable in X-Ray)
  AWSXRay.getSegment()?.addAnnotation('userId', userId)
  AWSXRay.getSegment()?.addAnnotation('mocId', mocId || 'N/A')
  AWSXRay.getSegment()?.addAnnotation('method', event.requestContext.http.method)
  AWSXRay.getSegment()?.addAnnotation('path', event.requestContext.http.path)

  // Add metadata (not indexed, but visible in trace details)
  AWSXRay.getSegment()?.addMetadata('requestId', event.requestContext.requestId)
  AWSXRay.getSegment()?.addMetadata('sourceIp', event.requestContext.http.sourceIp)

  try {
    // Custom subsegment for database query
    const moc = await AWSXRay.captureAsyncFunc('Database Query - Get MOC', async (subsegment) => {
      subsegment?.addAnnotation('table', 'moc_instructions')
      subsegment?.addAnnotation('operation', 'SELECT')
      subsegment?.addMetadata('query', 'SELECT * FROM moc_instructions WHERE id = $1')

      const result = await db.select().from(mocInstructions).where(eq(mocInstructions.id, mocId))

      subsegment?.addMetadata('rowCount', result.length)
      subsegment?.close()

      return result[0]
    })

    if (!moc) {
      AWSXRay.getSegment()?.addMetadata('error', 'MOC not found')
      return createErrorResponse(404, 'NOT_FOUND', 'MOC not found')
    }

    // Custom subsegment for Redis cache operation
    await AWSXRay.captureAsyncFunc('Redis - Set Cache', async (subsegment) => {
      subsegment?.addAnnotation('operation', 'SET')
      subsegment?.addMetadata('key', `moc:${mocId}`)
      subsegment?.addMetadata('ttl', 300)

      await redis.set(`moc:${mocId}`, JSON.stringify(moc), { EX: 300 })

      subsegment?.close()
    })

    // Custom subsegment for S3 operation
    if (moc.imageUrl) {
      await AWSXRay.captureAsyncFunc('S3 - Generate Presigned URL', async (subsegment) => {
        subsegment?.addAnnotation('bucket', process.env.S3_BUCKET!)
        subsegment?.addAnnotation('operation', 'getSignedUrl')
        subsegment?.addMetadata('key', moc.imageUrl)

        const url = await generatePresignedUrl(moc.imageUrl)
        moc.imageUrl = url

        subsegment?.close()
      })
    }

    return createSuccessResponse({ moc }, 200)
  } catch (error) {
    // Add error to trace
    AWSXRay.getSegment()?.addError(error as Error)
    AWSXRay.getSegment()?.addMetadata('errorDetails', {
      message: (error as Error).message,
      stack: (error as Error).stack,
    })

    console.error('MOC retrieval error:', error)
    return createErrorResponse(500, 'INTERNAL_ERROR', 'Failed to retrieve MOC')
  }
}
```

### Tracing Database Queries with Drizzle

```typescript
// src/lib/db/client.ts
import { drizzle } from 'drizzle-orm/node-postgres'
import { Pool } from 'pg'
import { AWSXRay } from '@/lib/tracing/xray-client'

// Create PostgreSQL pool with X-Ray tracing
const pool = new Pool({
  host: process.env.POSTGRES_HOST,
  port: parseInt(process.env.POSTGRES_PORT || '5432', 10),
  database: process.env.POSTGRES_DB,
  user: process.env.POSTGRES_USER,
  password: process.env.POSTGRES_PASSWORD,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
})

// Capture PostgreSQL queries with X-Ray
AWSXRay.capturePostgres(pool)

export const db = drizzle(pool, { schema })
```

### Tracing Redis Operations

```typescript
// src/lib/cache/redis-client.ts
import { createClient } from 'redis'
import { AWSXRay } from '@/lib/tracing/xray-client'

const redisClient = createClient({
  url: process.env.REDIS_URL,
})

redisClient.on('error', (err) => console.error('Redis Client Error', err))

await redisClient.connect()

// Wrap Redis operations in X-Ray subsegments
export async function getFromCache<T>(key: string): Promise<T | null> {
  return AWSXRay.captureAsyncFunc('Redis - GET', async (subsegment) => {
    subsegment?.addAnnotation('operation', 'GET')
    subsegment?.addMetadata('key', key)

    const value = await redisClient.get(key)

    subsegment?.addMetadata('hit', value !== null)
    subsegment?.close()

    return value ? JSON.parse(value) : null
  })
}

export async function setInCache<T>(key: string, value: T, ttl: number): Promise<void> {
  return AWSXRay.captureAsyncFunc('Redis - SET', async (subsegment) => {
    subsegment?.addAnnotation('operation', 'SET')
    subsegment?.addMetadata('key', key)
    subsegment?.addMetadata('ttl', ttl)

    await redisClient.set(key, JSON.stringify(value), { EX: ttl })

    subsegment?.close()
  })
}

export { redisClient }
```

### Tracing S3 Operations

```typescript
// src/lib/storage/s3-client.ts
import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3'
import { getSignedUrl } from '@aws-sdk/s3-request-presigner'
import { captureAWSv3Client } from 'aws-xray-sdk-core'

// Create S3 client with X-Ray tracing
const s3Client = captureAWSv3Client(new S3Client({ region: process.env.AWS_REGION }))

export async function uploadToS3(key: string, body: Buffer, contentType: string): Promise<string> {
  // X-Ray automatically captures this operation
  await s3Client.send(new PutObjectCommand({
    Bucket: process.env.S3_BUCKET!,
    Key: key,
    Body: body,
    ContentType: contentType,
  }))

  return `https://${process.env.S3_BUCKET}.s3.amazonaws.com/${key}`
}

export async function generatePresignedUrl(key: string): Promise<string> {
  // X-Ray automatically captures this operation
  const command = new GetObjectCommand({
    Bucket: process.env.S3_BUCKET!,
    Key: key,
  })

  return getSignedUrl(s3Client, command, { expiresIn: 3600 })
}

export async function deleteFromS3(key: string): Promise<void> {
  // X-Ray automatically captures this operation
  await s3Client.send(new DeleteObjectCommand({
    Bucket: process.env.S3_BUCKET!,
    Key: key,
  }))
}

export { s3Client }
```

### Tracing OpenSearch Queries

```typescript
// src/lib/search/opensearch-client.ts
import { Client } from '@opensearch-project/opensearch'
import { AWSXRay } from '@/lib/tracing/xray-client'

const openSearchClient = new Client({
  node: process.env.OPENSEARCH_ENDPOINT,
})

export async function searchGalleryImages(query: string, userId: string): Promise<GalleryImage[]> {
  return AWSXRay.captureAsyncFunc('OpenSearch - Search Gallery', async (subsegment) => {
    subsegment?.addAnnotation('index', 'gallery_images')
    subsegment?.addAnnotation('operation', 'SEARCH')
    subsegment?.addMetadata('query', query)
    subsegment?.addMetadata('userId', userId)

    const response = await openSearchClient.search({
      index: 'gallery_images',
      body: {
        query: {
          bool: {
            must: [
              { match: { userId } },
              { multi_match: { query, fields: ['title', 'description', 'tags'] } },
            ],
          },
        },
      },
    })

    subsegment?.addMetadata('hits', response.body.hits.total.value)
    subsegment?.close()

    return response.body.hits.hits.map((hit: any) => hit._source)
  })
}

export { openSearchClient }
```

### X-Ray Sampling Rule

```typescript
// infra/monitoring/xray-sampling.ts
import * as xray from 'aws-cdk-lib/aws-xray'

export class XRaySamplingRule extends Construct {
  constructor(scope: Construct, id: string) {
    super(scope, id)

    // Create sampling rule
    new xray.CfnSamplingRule(this, 'LegoApiSamplingRule', {
      ruleName: 'lego-api-production-sampling',
      priority: 1000,
      fixedRate: 0.1, // 10% of requests
      reservoirSize: 1, // Always sample at least 1 request per second
      serviceName: 'lego-api',
      serviceType: 'AWS::Lambda::Function',
      resourceArn: '*',
      urlPath: '*',
      httpMethod: '*',
      host: '*',
      version: 1,
    })
  }
}
```

### X-Ray Service Map

The service map automatically displays after tracing is enabled:

```
                    ┌─────────────┐
                    │  API Gateway│
                    └──────┬──────┘
                           │
          ┌────────────────┼────────────────┐
          │                │                │
    ┌─────▼──────┐   ┌─────▼──────┐   ┌────▼───────┐
    │ MOC Lambda │   │Gallery Lam.│   │Wishlist Lam│
    └─────┬──────┘   └─────┬──────┘   └────┬───────┘
          │                │                │
    ┌─────┼────────────────┼────────────────┼─────┐
    │     │                │                │     │
┌───▼───┐ │ ┌───────┐  ┌──▼───┐  ┌────────▼─┐ ┌─▼──────┐
│  RDS  │ └─┤ Redis │  │  S3  │  │OpenSearch│ │Cognito │
└───────┘   └───────┘  └──────┘  └──────────┘ └────────┘
```

### X-Ray Trace Example

```json
{
  "Id": "1-63f8d5a2-0a1b2c3d4e5f6g7h8i9j0k1l",
  "Duration": 0.245,
  "Segments": [
    {
      "Id": "2a3b4c5d6e7f8g9h",
      "Name": "MOC Lambda",
      "StartTime": 1677266466.123,
      "EndTime": 1677266466.368,
      "Subsegments": [
        {
          "Id": "3b4c5d6e7f8g9h0i",
          "Name": "Database Query - Get MOC",
          "StartTime": 1677266466.150,
          "EndTime": 1677266466.200,
          "Annotations": {
            "table": "moc_instructions",
            "operation": "SELECT"
          },
          "Metadata": {
            "query": "SELECT * FROM moc_instructions WHERE id = $1",
            "rowCount": 1
          }
        },
        {
          "Id": "4c5d6e7f8g9h0i1j",
          "Name": "Redis - Set Cache",
          "StartTime": 1677266466.210,
          "EndTime": 1677266466.230,
          "Annotations": {
            "operation": "SET"
          },
          "Metadata": {
            "key": "moc:12345",
            "ttl": 300
          }
        },
        {
          "Id": "5d6e7f8g9h0i1j2k",
          "Name": "S3 - Generate Presigned URL",
          "StartTime": 1677266466.240,
          "EndTime": 1677266466.365,
          "Annotations": {
            "bucket": "lego-api-files",
            "operation": "getSignedUrl"
          },
          "Metadata": {
            "key": "mocs/user123/moc456/image.webp"
          }
        }
      ],
      "Annotations": {
        "userId": "user123",
        "mocId": "moc456",
        "method": "GET",
        "path": "/api/mocs/moc456"
      },
      "Metadata": {
        "requestId": "abc123",
        "sourceIp": "192.168.1.1"
      }
    }
  ]
}
```

---

## Design Decisions

### 10% Sampling Rate

**Decision**: Sample 10% of requests in production

**Rationale**:
- Balances cost with visibility
- X-Ray pricing: $5 per 1M traces recorded, $0.50 per 1M traces retrieved
- 10% sampling provides sufficient data for analysis
- Always samples at least 1 request per second (reservoir)
- Can increase to 100% temporarily for debugging

**Alternative Considered**: 100% sampling (rejected due to cost)

### Active Tracing Mode

**Decision**: Use `Active` tracing mode (not `PassThrough`)

**Rationale**:
- `Active`: Lambda creates trace segments and sends to X-Ray
- `PassThrough`: Only traces if upstream service sends trace header
- Active mode ensures all Lambda invocations are traced
- Required for standalone testing and monitoring

### Annotations vs Metadata

**Decision**: Use annotations for searchable fields (userId, mocId), metadata for details

**Rationale**:
- **Annotations**: Indexed, searchable in X-Ray console (max 50 per segment)
- **Metadata**: Not indexed, visible in trace details (no limit)
- Annotations enable filtering traces by userId, resourceId, etc.
- Metadata stores full query text, error stack traces, etc.

### Custom Subsegments for All External Calls

**Decision**: Wrap database, Redis, S3, OpenSearch operations in custom subsegments

**Rationale**:
- Provides detailed timing breakdown for each operation
- Easier to identify bottlenecks (e.g., slow database query)
- Annotations/metadata per operation for context
- Service map automatically displays dependencies

---

## Error Scenarios

| Scenario | Resolution |
|----------|------------|
| Traces not appearing in X-Ray | Verify tracing enabled in Lambda config, check IAM permissions |
| Service map incomplete | Ensure X-Ray SDK captures all AWS SDK clients |
| High X-Ray costs | Reduce sampling rate, verify sampling rule applied |
| Missing subsegments | Verify custom segments closed with `subsegment?.close()` |
| Trace errors not captured | Ensure `addError()` called in catch blocks |

---

## X-Ray Dashboard

```typescript
// infra/monitoring/xray-dashboard.ts
import * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch'

export class XRayDashboard extends Construct {
  constructor(scope: Construct, id: string) {
    super(scope, id)

    const dashboard = new cloudwatch.Dashboard(this, 'XRayAnalyticsDashboard', {
      dashboardName: 'lego-api-xray-analytics',
    })

    // Trace count widget
    dashboard.addWidgets(
      new cloudwatch.GraphWidget({
        title: 'X-Ray Trace Count',
        width: 12,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/XRay',
            metricName: 'TraceCount',
            statistic: cloudwatch.Stats.SUM,
            period: Duration.minutes(5),
          }),
        ],
      }),
    )

    // Error traces widget
    dashboard.addWidgets(
      new cloudwatch.GraphWidget({
        title: 'X-Ray Error Traces',
        width: 12,
        height: 6,
        left: [
          new cloudwatch.Metric({
            namespace: 'AWS/XRay',
            metricName: 'ErrorCount',
            statistic: cloudwatch.Stats.SUM,
            period: Duration.minutes(5),
          }),
        ],
      }),
    )
  }
}
```

---

## Performance Considerations

1. **X-Ray SDK Overhead**: ~1-5ms per Lambda invocation
2. **Sampling Impact**: 10% sampling reduces overhead and cost
3. **Trace Size**: Each trace ~1-5 KB (depends on subsegments)
4. **Trace Retention**: 30 days (adjustable)
5. **Service Map Refresh**: Updates every 1 minute

**Benchmark Targets**:
- X-Ray overhead: <5ms per invocation
- Trace appears in console: <30 seconds
- Service map updates: <1 minute

---

## Dependencies

- **AWS X-Ray SDK**: For tracing instrumentation
- **AWS Lambda**: For automatic root segment creation
- **AWS CDK**: For sampling rule configuration
- **All Lambda Functions**: Stories 1.1, 2.1, 3.1-3.5, 4.1

---

## Future Enhancements

1. **Custom Business Metrics**: Emit custom metrics from traces (e.g., MOCs created per hour)
2. **Trace Groups**: Organize traces by feature (MOC, Gallery, Wishlist)
3. **X-Ray Insights**: Enable X-Ray Insights for anomaly detection
4. **Cross-Account Tracing**: Trace requests across AWS accounts
5. **APM Integration**: Integrate with Datadog or New Relic APM

---

## Related Stories

- **Story 5.1**: CloudWatch Dashboards - Add X-Ray trace links to dashboard
- **Story 5.2**: CloudWatch Alarms - Use X-Ray error traces to trigger alarms
- **Story 5.6**: Performance Validation - Use X-Ray to identify performance bottlenecks
