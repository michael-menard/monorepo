# Story 3.1.38: S3 Cleanup for Failed Edit Uploads

## GitHub Issue
- Issue: #259
- URL: https://github.com/michael-menard/monorepo/issues/259
- Status: Todo

## Status

Draft

## Story

**As a** platform operator,
**I want** orphaned S3 files from failed edits cleaned up,
**so that** storage costs are controlled and stale files don't accumulate.

## Epic Context

This is **Story 1.6 of Epic 1: Backend Edit Pipeline**.

This is the final story in Epic 1. Upon completion, Epic 2 (Edit UX & Frontend) can begin.

## Blocked By

- All Epic 0 stories (3.1.28-3.1.32)
- Story 3.1.35: Edit Presign Endpoint
- Story 3.1.36: Edit Finalize Endpoint

## Acceptance Criteria

1. Edit presign creates files in `edit/` path prefix: `{env}/moc-instructions/{ownerId}/{mocId}/edit/{category}/{uuid.ext}`
2. On finalize success: move files from `edit/` to permanent location OR keep in `edit/` with proper references
3. On finalize failure: files remain in `edit/` prefix as orphans
4. Scheduled cleanup job (daily) deletes files in `edit/` prefix older than 24 hours
5. Cleanup job logs each deleted file with correlationId
6. Best-effort synchronous cleanup on finalize transaction failure
7. Cleanup uses S3 batch delete (up to 1000 objects per request) for efficiency

## Tasks / Subtasks

- [ ] **Task 1: Verify Edit Path Prefix** (AC: 1)
  - [ ] Confirm presign uses `edit/` path prefix
  - [ ] Document S3 key format in code comments

- [ ] **Task 2: Implement Finalize Success Handling** (AC: 2)
  - [ ] Option A: Move files from `edit/` to permanent path
  - [ ] Option B: Keep in `edit/` but track as finalized
  - [ ] Update file records with final S3 key

- [ ] **Task 3: Synchronous Cleanup on Failure** (AC: 6)
  - [ ] On finalize transaction rollback, attempt to delete uploaded files
  - [ ] Use try-catch to make cleanup best-effort
  - [ ] Log failures as warnings (don't fail the error response)

- [ ] **Task 4: Create Cleanup Lambda** (AC: 4, 5, 7)
  - [ ] Create `apps/api/endpoints/cleanup/edit-orphans/handler.ts`
  - [ ] List objects in `*/moc-instructions/*/edit/*` prefix
  - [ ] Filter to objects older than 24 hours
  - [ ] Use S3 DeleteObjects for batch deletion
  - [ ] Log each deleted object with reason

- [ ] **Task 5: Schedule Cleanup Job** (AC: 4)
  - [ ] Add EventBridge rule for daily execution
  - [ ] Configure to run at 03:00 UTC (low traffic)
  - [ ] Add to serverless.yml

- [ ] **Task 6: Add Observability**
  - [ ] Log cleanup start with environment
  - [ ] Log objects found for cleanup
  - [ ] Log successful deletions
  - [ ] Log any errors during cleanup
  - [ ] Emit CloudWatch metric for orphan count

## Dev Notes

### S3 Key Structure

```
# Edit files (temporary)
{env}/moc-instructions/{ownerId}/{mocId}/edit/{category}/{uuid}.{ext}

# Permanent files (after finalize)
{env}/moc-instructions/{ownerId}/{mocId}/{category}/{uuid}.{ext}

# Example
production/moc-instructions/user-123/moc-456/edit/instruction/abc-def.pdf  # Temporary
production/moc-instructions/user-123/moc-456/instruction/abc-def.pdf       # Permanent
```

### Synchronous Cleanup Pattern

```typescript
// In edit-finalize handler
try {
  await db.transaction(async tx => {
    // ... finalize logic
  })
} catch (error) {
  // Best-effort cleanup of newly uploaded files
  try {
    await s3.deleteObjects({
      Bucket: bucket,
      Delete: {
        Objects: newFileKeys.map(key => ({ Key: key })),
      },
    })
    logger.info('Cleaned up edit files after finalize failure', {
      mocId,
      fileCount: newFileKeys.length,
    })
  } catch (cleanupError) {
    logger.warn('Failed to cleanup edit files on rollback', {
      mocId,
      fileCount: newFileKeys.length,
      error: cleanupError instanceof Error ? cleanupError.message : 'Unknown',
    })
    // Don't throw - cleanup is best-effort
  }

  throw error // Re-throw original error
}
```

### Cleanup Lambda

```typescript
// apps/api/endpoints/cleanup/edit-orphans/handler.ts
import { S3Client, ListObjectsV2Command, DeleteObjectsCommand } from '@aws-sdk/client-s3'
import { logger } from '@repo/logger'

const ORPHAN_THRESHOLD_HOURS = 24
const MAX_DELETE_BATCH = 1000

export const handler = async () => {
  const correlationId = generateCorrelationId()
  logger.info('edit-orphan-cleanup.start', { correlationId })

  const bucket = process.env.S3_BUCKET
  const env = process.env.STAGE

  // List all edit prefixes
  const listCommand = new ListObjectsV2Command({
    Bucket: bucket,
    Prefix: `${env}/moc-instructions/`,
    Delimiter: '', // Get all objects, not just prefixes
  })

  const objects = await s3.send(listCommand)
  const now = Date.now()
  const threshold = now - (ORPHAN_THRESHOLD_HOURS * 60 * 60 * 1000)

  const orphans = objects.Contents
    ?.filter(obj => obj.Key?.includes('/edit/'))
    ?.filter(obj => obj.LastModified && obj.LastModified.getTime() < threshold)
    ?? []

  logger.info('edit-orphan-cleanup.found', {
    correlationId,
    orphanCount: orphans.length,
  })

  if (orphans.length === 0) {
    return { deleted: 0 }
  }

  // Batch delete (up to 1000 at a time)
  let deleted = 0
  for (let i = 0; i < orphans.length; i += MAX_DELETE_BATCH) {
    const batch = orphans.slice(i, i + MAX_DELETE_BATCH)

    await s3.send(new DeleteObjectsCommand({
      Bucket: bucket,
      Delete: {
        Objects: batch.map(obj => ({ Key: obj.Key! })),
      },
    }))

    deleted += batch.length

    batch.forEach(obj => {
      logger.info('edit-orphan-cleanup.deleted', {
        correlationId,
        s3Key: obj.Key,
        ageHours: Math.round((now - (obj.LastModified?.getTime() ?? 0)) / (60 * 60 * 1000)),
      })
    })
  }

  logger.info('edit-orphan-cleanup.complete', {
    correlationId,
    deleted,
  })

  return { deleted }
}
```

### EventBridge Schedule

```yaml
# In serverless.yml
functions:
  cleanupEditOrphans:
    handler: endpoints/cleanup/edit-orphans/handler.handler
    memorySize: 256
    timeout: 300 # 5 minutes
    events:
      - schedule:
          rate: cron(0 3 * * ? *) # Daily at 03:00 UTC
          enabled: true
```

### Why Move Files (Option A) vs Keep in Edit (Option B)

**Option A: Move files**
- Cleaner separation between temporary and permanent
- Easier to identify orphans (anything in `/edit/` is orphan)
- Requires S3 copy + delete operations

**Option B: Keep files, track status**
- No S3 operations on finalize
- Requires database tracking of finalized files
- Cleanup job needs to check database

**Recommendation:** Option A (move files) for simpler orphan detection.

## Testing

### Test Location
- `apps/api/endpoints/cleanup/edit-orphans/__tests__/handler.test.ts`
- `apps/api/endpoints/moc-instructions/edit-finalize/__tests__/cleanup.test.ts`

### Test Requirements
- Unit: Cleanup identifies objects older than 24h
- Unit: Cleanup respects batch size limits
- Unit: Synchronous cleanup called on finalize failure
- Integration: Orphaned files deleted after 24h (with mocked time)
- Integration: Active edit files not deleted
- Integration: Batch delete handles large counts
- Unit: Logs include required fields

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-08 | 0.1 | Initial draft from Edit MOC PRD | SM Agent |

## Dev Agent Record

### Agent Model Used

N/A

### Debug Log References

N/A

### Completion Notes

N/A

### File List

- `apps/api/endpoints/cleanup/edit-orphans/handler.ts` - New
- `apps/api/endpoints/cleanup/edit-orphans/__tests__/handler.test.ts` - New
- `apps/api/endpoints/moc-instructions/edit-finalize/handler.ts` - Modified (add sync cleanup)
- `apps/api/serverless.yml` - Modified (add scheduled function)
