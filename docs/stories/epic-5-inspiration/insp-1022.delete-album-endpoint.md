# Story insp-1022: Delete Album Endpoint (with options)

## Status

Draft

## Story

**As a** user,
**I want** to delete an album with control over contents,
**so that** I can remove albums while choosing whether to keep or delete contents.

## Acceptance Criteria

1. DELETE /api/albums/:id deletes album
2. Query param deleteContents=false (default): orphan contents
3. Query param deleteContents=true: cascade delete all contents
4. Hard delete (no soft delete)
5. Returns 204 on success
6. Returns 404 if not found
7. Returns 403 if user doesn't own album
8. Handles nested albums recursively when cascade deleting

## Tasks / Subtasks

- [ ] **Task 1: Create Delete Endpoint** (AC: 1, 5, 6, 7)
  - [ ] Create DELETE /api/albums/:id handler
  - [ ] Add authentication middleware
  - [ ] Validate ownership
  - [ ] Parse deleteContents query param

- [ ] **Task 2: Implement Orphan Mode** (AC: 2)
  - [ ] Remove album from album_parents for nested albums
  - [ ] Remove album from inspiration_albums for inspirations
  - [ ] Delete the album record
  - [ ] Contents remain orphaned or in other albums

- [ ] **Task 3: Implement Cascade Mode** (AC: 3, 8)
  - [ ] Recursively collect all nested albums
  - [ ] Collect all inspirations in album tree
  - [ ] Delete S3 objects for all inspirations
  - [ ] Delete all records in transaction

- [ ] **Task 4: Clean Up Junction Tables** (AC: 4)
  - [ ] Remove from album_parents
  - [ ] Remove from album_mocs
  - [ ] Use transaction for atomicity

- [ ] **Task 5: Add to Serverless Config**
  - [ ] Add Lambda function definition
  - [ ] Configure API Gateway route

## Dev Notes

### Endpoint Location
`apps/api/endpoints/albums/delete/handler.ts`

### Query Parameters

```typescript
const DeleteAlbumQuerySchema = z.object({
  deleteContents: z.coerce.boolean().default(false),
})
```

### Orphan Mode (deleteContents=false)

```typescript
await db.transaction(async (tx) => {
  // Verify ownership
  const album = await tx.query.albums.findFirst({
    where: and(eq(albums.id, id), eq(albums.userId, userId)),
  })
  if (!album) throw new NotFoundError()

  // Remove parent relationships for nested albums
  await tx.delete(albumParents)
    .where(eq(albumParents.parentAlbumId, id))

  // Remove this album from its parents
  await tx.delete(albumParents)
    .where(eq(albumParents.childAlbumId, id))

  // Remove inspiration relationships (they become orphans or stay in other albums)
  await tx.delete(inspirationAlbums)
    .where(eq(inspirationAlbums.albumId, id))

  // Remove MOC links
  await tx.delete(albumMocs)
    .where(eq(albumMocs.albumId, id))

  // Delete album
  await tx.delete(albums).where(eq(albums.id, id))
})
```

### Cascade Mode (deleteContents=true)

```typescript
// Collect all nested albums recursively
async function collectNestedAlbums(albumId: string): Promise<string[]> {
  const nested = await db.select({ id: albumParents.childAlbumId })
    .from(albumParents)
    .where(eq(albumParents.parentAlbumId, albumId))

  const allNested = [albumId]
  for (const n of nested) {
    allNested.push(...await collectNestedAlbums(n.id))
  }
  return allNested
}

// Collect all inspirations in album tree
// Delete all in transaction
// Then delete S3 objects
```

## Testing

- [ ] Orphan mode: album deleted, contents orphaned
- [ ] Cascade mode: album and all contents deleted
- [ ] Nested albums handled correctly in cascade
- [ ] S3 objects deleted in cascade mode
- [ ] Returns 204 on success
- [ ] Returns 404 for non-existent
- [ ] Returns 403 for other user's album

## Change Log

| Date       | Version | Description   | Author   |
| ---------- | ------- | ------------- | -------- |
| 2025-12-27 | 0.1     | Initial draft | SM Agent |
