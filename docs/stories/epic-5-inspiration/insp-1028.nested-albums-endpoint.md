# Story insp-1028: Nested Albums Endpoint (with cycle detection)

## Status

Draft

## Story

**As a** user,
**I want** to nest albums within other albums,
**so that** I can create hierarchical organization.

## Acceptance Criteria

1. POST /api/albums/:parentId/albums/:childId adds parent relationship
2. Albums can have multiple parents (DAG structure)
3. Cycle detection prevents circular references
4. Returns 400 if adding would create a cycle
5. Assigns sortOrder within parent
6. Returns 204 on success
7. DELETE removes the parent-child relationship

## Tasks / Subtasks

- [ ] **Task 1: Create Add Endpoint** (AC: 1, 5, 6)
  - [ ] Create POST /api/albums/:parentId/albums/:childId
  - [ ] Add authentication middleware
  - [ ] Validate user owns both albums

- [ ] **Task 2: Implement Cycle Detection** (AC: 3, 4)
  - [ ] Before adding, traverse ancestors of parent
  - [ ] Check if child appears in ancestor chain
  - [ ] Return 400 with clear error if cycle detected

- [ ] **Task 3: Create Relationship** (AC: 2)
  - [ ] Insert into album_parents junction table
  - [ ] Assign sortOrder within parent
  - [ ] Update parent's updatedAt

- [ ] **Task 4: Create Remove Endpoint** (AC: 7)
  - [ ] Create DELETE /api/albums/:parentId/albums/:childId
  - [ ] Remove from album_parents
  - [ ] Child becomes orphaned or stays in other parents

- [ ] **Task 5: Add to Serverless Config**
  - [ ] Add Lambda functions
  - [ ] Configure API Gateway routes

## Dev Notes

### Endpoint Locations
- Add: `apps/api/endpoints/albums/add-child/handler.ts`
- Remove: `apps/api/endpoints/albums/remove-child/handler.ts`

### Cycle Detection Algorithm

```typescript
async function wouldCreateCycle(
  db: DbClient,
  parentId: string,
  childId: string
): Promise<boolean> {
  // If child is the same as parent, that's a self-cycle
  if (parentId === childId) return true

  // BFS to check if childId is an ancestor of parentId
  const visited = new Set<string>()
  const queue = [parentId]

  while (queue.length > 0) {
    const current = queue.shift()!
    if (visited.has(current)) continue
    visited.add(current)

    // Get all ancestors of current
    const parents = await db
      .select({ parentId: albumParents.parentAlbumId })
      .from(albumParents)
      .where(eq(albumParents.childAlbumId, current))

    for (const p of parents) {
      if (p.parentId === childId) {
        // Found childId in ancestor chain - would create cycle
        return true
      }
      queue.push(p.parentId)
    }
  }

  return false
}
```

### DAG Structure
Per PRD: "Albums can have multiple parents" - This creates a DAG (Directed Acyclic Graph), not a tree. Key properties:
- Multiple paths to same album allowed
- Cycles forbidden (detected and rejected)
- Orphaned albums (no parents) appear at root

### Junction Table Schema

```typescript
export const albumParents = pgTable('album_parents', {
  childAlbumId: uuid('child_album_id').notNull().references(() => albums.id),
  parentAlbumId: uuid('parent_album_id').notNull().references(() => albums.id),
  sortOrder: integer('sort_order').notNull().default(0),
}, (table) => ({
  pk: primaryKey(table.childAlbumId, table.parentAlbumId),
}))
```

## Testing

- [ ] Adds child album to parent
- [ ] Multiple parents allowed
- [ ] Self-cycle rejected (parent = child)
- [ ] Direct cycle rejected (A -> B -> A)
- [ ] Indirect cycle rejected (A -> B -> C -> A)
- [ ] Assigns correct sortOrder
- [ ] Remove endpoint works
- [ ] Returns 404 for non-existent albums
- [ ] Returns 403 if user doesn't own both

## Change Log

| Date       | Version | Description   | Author   |
| ---------- | ------- | ------------- | -------- |
| 2025-12-27 | 0.1     | Initial draft | SM Agent |
