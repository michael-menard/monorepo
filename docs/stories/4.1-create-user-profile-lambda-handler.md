# Story 4.1: Create User Profile Lambda Handler

**Epic**: 4 - User Profile & Advanced Features Migration

**As a** backend developer,
**I want** to create Lambda handlers for user profile operations,
**so that** users can manage their account settings and avatars.

## Acceptance Criteria

1. Lambda function created at `src/functions/profile.ts`
2. API Gateway routes: `GET /api/users/{id}`, `PATCH /api/users/{id}`, `POST /api/users/{id}/avatar`, `DELETE /api/users/{id}/avatar`
3. JWT authorizer validates user can only access their own profile (userId match)
4. Note: User profiles stored in AWS Cognito, not PostgreSQL - Lambda queries Cognito User Pool for profile data
5. S3 client configured for avatar storage
6. Redis client for profile caching
7. TypeScript types for Cognito user attributes

## Implementation Status

**Status**: Not Started

## Files Modified

_To be populated during implementation_

## QA Results

_Pending implementation and review_

---

## Requirements Traceability Matrix

| AC # | Requirement                            | Test Coverage | Status   |
| ---- | -------------------------------------- | ------------- | -------- |
| 1    | Lambda function at src/functions/profile.ts | TBD      | ⏳ PENDING |
| 2    | API Gateway routes configured          | TBD           | ⏳ PENDING |
| 3    | JWT authorizer with userId match       | TBD           | ⏳ PENDING |
| 4    | Cognito User Pool integration          | TBD           | ⏳ PENDING |
| 5    | S3 client configured                   | TBD           | ⏳ PENDING |
| 6    | Redis client configured                | TBD           | ⏳ PENDING |
| 7    | TypeScript types for Cognito attrs     | TBD           | ⏳ PENDING |

**Overall Coverage: TBD**

---

## Test Summary

_To be populated during implementation_

---

## Technical Notes

### Architecture Overview

This story sets up the infrastructure for user profile operations with a key architectural distinction:

**User Profile Data Storage**:
- **Cognito User Pool**: Primary source of truth for user identity and profile attributes
  - `sub` (user ID)
  - `email`
  - `name`
  - `picture` (avatar URL)
  - Other standard Cognito attributes

- **PostgreSQL**: Stores user-generated content
  - MOCs (`mocInstructions` table)
  - Gallery images (`galleryImages` table)
  - Wishlist items (`wishlistItems` table)
  - Used for aggregated statistics only

### Lambda Function Structure

```typescript
export const handler = async (event: APIGatewayProxyEventV2): Promise<APIGatewayProxyResultV2> => {
  // Extract userId from JWT
  // Extract route parameter :id
  // Verify userId === id (authorization)
  // Route to appropriate handler
}
```

### API Routes Configuration

```typescript
// sst.config.ts
const profileFunction = new sst.aws.Function('ProfileFunction', {
  handler: 'src/functions/profile.handler',
  runtime: 'nodejs20.x',
  timeout: '30 seconds',
  memory: '1024 MB', // For avatar processing
  vpc,
  link: [bucket, redis],
  environment: {
    COGNITO_USER_POOL_ID: cognitoUserPool.id,
  },
})

api.route('GET /api/users/{id}', profileFunction)
api.route('PATCH /api/users/{id}', profileFunction)
api.route('POST /api/users/{id}/avatar', profileFunction)
api.route('DELETE /api/users/{id}/avatar', profileFunction)
```

### Cognito Client Setup

```typescript
import { CognitoIdentityProviderClient } from '@aws-sdk/client-cognito-identity-provider'

const cognitoClient = new CognitoIdentityProviderClient({
  region: process.env.AWS_REGION,
})
```

### Authorization Pattern

```typescript
// Every handler must verify userId match
const userId = getUserIdFromEvent(event)
const profileId = event.pathParameters?.id

if (userId !== profileId) {
  return createErrorResponse(403, 'FORBIDDEN', 'Cannot access another user\'s profile')
}
```

### TypeScript Types

```typescript
// Cognito user attributes
interface CognitoUserProfile {
  sub: string          // User ID (Cognito sub claim)
  email: string
  email_verified: boolean
  name?: string
  picture?: string     // Avatar URL
}

// API response
interface UserProfileResponse {
  id: string
  email: string
  name: string | null
  avatarUrl: string | null
  stats: {
    mocs: number
    images: number
    wishlistItems: number
  }
}
```

### Redis Caching Setup

```typescript
// Cache key pattern
const cacheKey = `profile:user:${userId}`

// TTL: 10 minutes
await redis.setEx(cacheKey, 600, JSON.stringify(profile))
```

### S3 Storage Pattern

```
avatars/
  {userId}/
    avatar.webp    <- Current avatar (overwrites on upload)
```

---

## Dependencies

- **AWS Cognito User Pool**: Must be configured with user pool ID
- **S3 Bucket**: For avatar storage
- **Redis**: For profile caching
- **JWT Authorizer**: Must extract userId from Cognito token

---

## Next Steps

After this infrastructure story, implement:

- **Story 4.2**: GET /api/users/:id (retrieve profile)
- **Story 4.3**: PATCH /api/users/:id (update profile)
- **Story 4.4**: POST /api/users/:id/avatar (upload avatar)
- **Story 4.5**: DELETE /api/users/:id/avatar (remove avatar)

---

## Key Differences from Previous Stories

1. **No PostgreSQL for user data**: Profiles stored in Cognito, not database
2. **Cognito SDK**: Uses AWS SDK for Cognito Identity Provider
3. **Authorization pattern**: userId must match route parameter `:id`
4. **Single avatar per user**: Overwrites instead of versioning
