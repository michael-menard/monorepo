# Story 1.25: JWT Validation Utility

## Status

Approved

## Story

**As a** developer,
**I want** a utility to validate JWT tokens,
**so that** I can verify token integrity before API calls.

## Acceptance Criteria

1. ⬜ JWT decode utility (without verification)
2. ⬜ Token expiration check function
3. ⬜ Token payload extraction
4. ⬜ Type-safe token claims interface
5. ⬜ Handles invalid/malformed tokens gracefully

## Tasks / Subtasks

- [ ] **Task 1: Create JWT Utility** (AC: 1, 3)
  - [ ] Create lib/jwt.ts
  - [ ] Implement decodeToken(token: string)
  - [ ] Return decoded payload or null

- [ ] **Task 2: Expiration Check** (AC: 2)
  - [ ] Implement isTokenExpired(token: string)
  - [ ] Check exp claim against current time
  - [ ] Add buffer for clock skew (30s)

- [ ] **Task 3: Type Definitions** (AC: 4)
  - [ ] Define CognitoIdTokenPayload interface
  - [ ] Define CognitoAccessTokenPayload interface
  - [ ] Include common claims (sub, email, exp, etc.)

- [ ] **Task 4: Error Handling** (AC: 5)
  - [ ] Return null for invalid tokens
  - [ ] Don't throw on malformed input
  - [ ] Log errors for debugging

## Dev Notes

### JWT Decode (No Verification)

Note: Frontend JWT decode is for extracting claims only.
Actual verification should happen on the backend.

**File:** `apps/web/main-app/src/lib/jwt.ts`

```typescript
export interface JwtPayload {
  sub: string
  exp: number
  iat: number
  [key: string]: unknown
}

export interface CognitoIdTokenPayload extends JwtPayload {
  email: string
  email_verified: boolean
  'cognito:username': string
  'cognito:groups'?: string[]
}

export interface CognitoAccessTokenPayload extends JwtPayload {
  client_id: string
  scope: string
  token_use: 'access'
}

export function decodeToken<T extends JwtPayload>(token: string): T | null {
  try {
    const [, payloadBase64] = token.split('.')
    if (!payloadBase64) return null

    const payload = JSON.parse(atob(payloadBase64))
    return payload as T
  } catch (error) {
    logger.warn('Failed to decode JWT', { error })
    return null
  }
}

export function isTokenExpired(token: string, bufferSeconds = 30): boolean {
  const payload = decodeToken(token)
  if (!payload?.exp) return true

  const now = Math.floor(Date.now() / 1000)
  return payload.exp < now + bufferSeconds
}

export function getTokenExpiration(token: string): Date | null {
  const payload = decodeToken(token)
  if (!payload?.exp) return null
  return new Date(payload.exp * 1000)
}
```

### Usage

```typescript
const payload = decodeToken<CognitoIdTokenPayload>(idToken)
if (payload) {
  console.log(payload.email)
  console.log(payload['cognito:groups'])
}

if (isTokenExpired(accessToken)) {
  // Refresh token
}
```

### Testing

- Test valid token decodes correctly
- Test expired token detected
- Test malformed token returns null
- Test buffer time works

## Change Log

| Date       | Version | Description   | Author   |
| ---------- | ------- | ------------- | -------- |
| 2025-11-28 | 0.1     | Initial draft | SM Agent |
