# Story 1.1: AWS Infrastructure Foundation Setup

## Status
Draft

## Story
**As a** DevOps Engineer,
**I want** to establish the core AWS infrastructure foundation for observability,
**so that** all observability tools have the necessary networking, storage, and access controls in place.

## Acceptance Criteria
1. VPC created or identified with /24 CIDR block, 2 availability zones, 2 public subnets (/27), 2 private subnets (/26)
2. Single NAT Gateway deployed in one AZ for cost optimization
3. Security groups created for ECS tasks (OpenReplay, Umami) with appropriate ingress/egress rules
4. IAM roles created for ECS task execution, Lambda enhanced permissions, Grafana access
5. Comprehensive resource tagging schema implemented on all resources:
   - Required tags: Project, Environment, ManagedBy, CostCenter, Owner
   - Functional tags: Component, Function, DataType (where applicable)
   - Centralized tag configuration created in `sst/observability/tags.ts`
   - Cost allocation tags activated in AWS Billing Console
6. Tag compliance validated via AWS CLI or Tag Editor (all resources have minimum 5 required tags)
7. SST configuration extended with observability infrastructure constructs

**Integration Verification:**
- IV1: Existing VPC resources (if any) remain unaffected and accessible
- IV2: Application Lambda functions can still access existing Aurora database
- IV3: No disruption to current application deployment pipeline

## Tasks / Subtasks

- [ ] **Task 1: Create centralized tagging configuration** (AC: 5)
  - [ ] Create `apps/api/lego-api-serverless/sst/observability/` directory
  - [ ] Create `sst/observability/tags.ts` implementing required tags function following AWS tagging schema
  - [ ] Export tag utility functions: `requiredTags()`, `observabilityTags()`, `componentTags`
  - [ ] Reference: `docs/aws-tagging-schema.md` for complete tag structure

- [ ] **Task 2: Create or identify VPC infrastructure in SST** (AC: 1, 2)
  - [ ] Check if VPC already exists in `sst.config.ts`
  - [ ] If exists, document VPC ID and subnet configuration for observability services
  - [ ] If not exists, create VPC construct in `sst.config.ts` with /24 CIDR, 2 AZs, public (/27) and private (/26) subnets
  - [ ] Deploy single NAT Gateway in one AZ using SST `Vpc` construct with cost-optimized configuration
  - [ ] Apply resource tags using centralized tag configuration
  - [ ] Export VPC construct for use by ECS services in later stories

- [ ] **Task 3: Create security groups for ECS services** (AC: 3)
  - [ ] Create security group for OpenReplay ECS tasks (HTTP/HTTPS ingress from ALB, egress for S3/Aurora)
  - [ ] Create security group for Umami ECS tasks (HTTP/HTTPS ingress from ALB, egress for Aurora)
  - [ ] Create security group for ALB (HTTP/HTTPS ingress from 0.0.0.0/0, egress to ECS tasks)
  - [ ] Define security groups in SST using CDK `SecurityGroup` constructs
  - [ ] Apply resource tags using centralized tag configuration

- [ ] **Task 4: Create IAM roles and policies** (AC: 4)
  - [ ] Create ECS task execution role with permissions for ECR, CloudWatch Logs, Secrets Manager
  - [ ] Create ECS task role for OpenReplay with S3 bucket access (read/write for session storage)
  - [ ] Create ECS task role for Umami with Aurora PostgreSQL access (via RDS Proxy if available)
  - [ ] Enhance existing Lambda execution role with CloudWatch EMF permissions (`cloudwatch:PutMetricData`)
  - [ ] Create IAM role for Amazon Managed Grafana with CloudWatch read permissions
  - [ ] Use SST `iam.Role` constructs with least-privilege policies
  - [ ] Apply resource tags using centralized tag configuration

- [ ] **Task 5: Extend sst.config.ts with observability infrastructure** (AC: 7)
  - [ ] Import observability tagging utilities from `sst/observability/tags.ts`
  - [ ] Create new SST stack function `ObservabilityStack` or extend existing stack
  - [ ] Export VPC, security groups, IAM roles for use in Phase 2-4 stories
  - [ ] Validate SST configuration with `sst build` (local)
  - [ ] Deploy infrastructure with `sst deploy --stage dev`

- [ ] **Task 6: Activate cost allocation tags in AWS Billing Console** (AC: 5)
  - [ ] Navigate to AWS Billing Console → Cost Allocation Tags
  - [ ] Activate user-defined tags: `Project`, `Component`, `Function`, `Environment`, `CostCenter`, `DataType`, `Owner`
  - [ ] Document tag activation in story completion notes (tags take 24 hours to appear in Cost Explorer)

- [ ] **Task 7: Validate tag compliance** (AC: 6)
  - [ ] Use AWS CLI command to list all resources created in this story
  - [ ] Verify each resource has minimum 5 required tags (Project, Environment, ManagedBy, CostCenter, Owner)
  - [ ] Use AWS Tag Editor to bulk-verify tagging compliance for `user-metrics` project
  - [ ] Document any resources missing tags and apply corrections

- [ ] **Task 8: Integration testing** (AC: IV1, IV2, IV3)
  - [ ] Verify existing VPC resources (if any) are not modified (check VPC ID, subnet IDs)
  - [ ] Test existing Lambda function connectivity to Aurora database (run health check endpoint)
  - [ ] Verify no disruption to application deployment pipeline (deploy existing Lambda function)
  - [ ] Document integration test results in completion notes

## Dev Notes

### Project Context
This story is **Story 1.1** from **Phase 1: Infrastructure Foundation** of the User Metrics PRD brownfield enhancement. This is the first story of the project, establishing the AWS infrastructure foundation for self-hosted observability tools (OpenReplay, Umami) and Amazon Managed Grafana integration.

**Project:** User Tracking & Metrics Implementation (Brownfield Enhancement)
**Epic:** Phase 1 - Infrastructure Foundation (4 stories total)
**PRD Location:** `docs/prd/user-metrics/user-metrics-prd.md`
**Architecture:** `docs/prd/user-metrics/user-metrics-architecture.md`

### Previous Story Insights
**None** - This is the first story in the epic. No previous story context.

### Tech Stack for This Story
[Source: docs/architecture/tech-stack.md]

**Infrastructure:**
- **SST (Serverless Stack)** v3 (Ion) - Infrastructure-as-code framework using AWS CDK
- **AWS CDK** - TypeScript-based IaC (via SST)
- **VPC Configuration:** /24 CIDR, 2 AZs, public + private subnets, single NAT Gateway for cost optimization
- **IAM Roles:** ECS task execution, ECS task roles, Lambda execution, Grafana access
- **TypeScript 5.8** strict mode for all IaC code

**AWS Services:**
- VPC, Subnets, NAT Gateway, Internet Gateway
- Security Groups (ECS, ALB, Aurora)
- IAM Roles and Policies
- (Later phases: ECS/Fargate, ALB, S3, Aurora schema)

### Source Tree Structure
[Source: docs/architecture/source-tree.md]

**SST Configuration Location:**
```
apps/api/lego-api-serverless/
├── sst.config.ts          # Main SST infrastructure configuration
├── sst/                   # NEW: SST infrastructure constructs directory
│   └── observability/     # NEW: Create this directory
│       └── tags.ts        # NEW: Centralized tagging configuration
├── src/
│   └── lib/               # Existing utilities
└── package.json
```

**Key File Paths:**
- SST Config: `apps/api/lego-api-serverless/sst.config.ts`
- Tagging Utilities: `apps/api/lego-api-serverless/sst/observability/tags.ts` (CREATE NEW)
- Deployment: `sst deploy --stage dev` from `apps/api/lego-api-serverless/`

### AWS Resource Tagging Schema
[Source: docs/aws-tagging-schema.md]

**Required Tags (ALL Resources):**
```typescript
{
  Project: 'UserMetrics',           // Fixed for this project
  Environment: 'dev|staging|prod',  // From SST stage
  ManagedBy: 'SST',                 // Fixed (all resources via SST)
  CostCenter: 'Observability',      // Fixed for this project
  Owner: 'engineering@example.com', // Update with actual owner
}
```

**Functional Tags for Infrastructure Resources:**
- **VPC:** `Component: 'Networking', Function: 'Networking', NetworkTier: 'Private'`
- **Security Group:** `Component: 'Networking', Function: 'Security', Purpose: 'ECSAccess'`
- **IAM Role:** `Component: 'IAM', Function: 'AccessControl', Purpose: 'ECSTaskExecution', AccessLevel: 'ReadWrite'`
- **S3 Bucket (Phase 1.3):** `Component: 'Storage', Function: 'Storage', DataType: 'Sessions', RetentionPeriod: '30days'`

**Tagging Implementation Pattern:**
```typescript
// sst/observability/tags.ts
export const requiredTags = (stage: string, owner: string) => ({
  Project: 'UserMetrics',
  Environment: stage,
  ManagedBy: 'SST',
  CostCenter: 'Observability',
  Owner: owner,
});

export const componentTags = {
  networking: { Component: 'Networking', Function: 'Networking' },
  iam: { Component: 'IAM', Function: 'AccessControl' },
  storage: { Component: 'Storage', Function: 'Storage' },
  observability: { Component: 'Observability', Function: 'Monitoring' },
};
```

**Cost Allocation Tags Activation:**
Navigate to AWS Billing Console → Cost Allocation Tags → Activate: `Project`, `Component`, `Function`, `Environment`, `CostCenter`, `DataType`, `Owner`
**Note:** Tags take 24 hours to appear in Cost Explorer after activation.

### SST Infrastructure Patterns
[Source: docs/architecture/tech-stack.md, docs/prd/user-metrics/user-metrics-architecture.md]

**SST v3 Construct Patterns:**
```typescript
// Example VPC creation in sst.config.ts
import { Vpc } from 'sst/constructs';

export default $config({
  app(input) {
    return {
      name: 'lego-api-serverless',
      // ... existing config
    };
  },
  async run() {
    // Existing stacks...

    // NEW: Observability Infrastructure
    const vpc = new Vpc('ObservabilityVpc', {
      cidr: '10.0.0.0/24',
      availabilityZones: 2,
      publicSubnets: { cidrMask: 27 },  // /27 = 32 IPs per subnet
      privateSubnets: { cidrMask: 26 }, // /26 = 64 IPs per subnet
      natGateways: 1,  // Single NAT Gateway for cost optimization
      tags: {
        ...requiredTags($app.stage, 'engineering@example.com'),
        ...componentTags.networking,
        NetworkTier: 'Private',
      },
    });

    // Export for use in later stories
    return {
      vpc: vpc.id,
      publicSubnets: vpc.publicSubnets,
      privateSubnets: vpc.privateSubnets,
    };
  },
});
```

**Security Group Pattern:**
```typescript
import { SecurityGroup } from 'aws-cdk-lib/aws-ec2';

const ecsSecurityGroup = new SecurityGroup(stack, 'ECSSecurityGroup', {
  vpc,
  description: 'Security group for Umami/OpenReplay ECS tasks',
  allowAllOutbound: true,
  // Ingress rules added via .addIngressRule()
});

// Apply tags via CDK tagging
Tags.of(ecsSecurityGroup).add('Project', 'UserMetrics');
```

**IAM Role Pattern:**
```typescript
import { Role, ServicePrincipal, ManagedPolicy } from 'aws-cdk-lib/aws-iam';

const ecsTaskExecutionRole = new Role(stack, 'ECSTaskExecutionRole', {
  assumedBy: new ServicePrincipal('ecs-tasks.amazonaws.com'),
  managedPolicies: [
    ManagedPolicy.fromAwsManagedPolicyName('service-role/AmazonECSTaskExecutionRolePolicy'),
  ],
});

Tags.of(ecsTaskExecutionRole).add('Purpose', 'ECSTaskExecution');
```

### Integration Constraints
[Source: docs/prd/user-metrics/user-metrics-prd.md - Compatibility Requirements]

**CR5: AWS Account Compatibility** - All new infrastructure (VPC if needed, ECS, Aurora schema, S3 buckets, Amazon Managed Grafana workspace) shall coexist with existing resources using proper namespacing and tagging conventions.

**Existing Infrastructure to Preserve:**
- Aurora PostgreSQL database instance (existing, DO NOT modify)
- Existing Lambda functions and API Gateway (DO NOT modify)
- Existing S3 buckets for application assets (DO NOT modify)
- Existing CloudFront distribution (DO NOT modify)

**Namespacing Strategy:**
- All new resources prefixed with `Observability` or `UserMetrics` in logical names
- Use separate VPC for observability services if existing VPC exists for application
- Security groups scoped specifically to ECS tasks (no application Lambda access)

### Coding Standards
[Source: docs/architecture/coding-standards.md]

**TypeScript Standards:**
- All IaC code in `sst.config.ts` and `sst/observability/tags.ts` must be TypeScript strict mode
- No `any` types - use explicit types for SST constructs
- Use `const` over `let` where possible
- ESLint 9 + Prettier formatting enforced

**File Naming:**
- Utilities: `kebab-case.ts` (e.g., `tags.ts`)
- Configuration: Existing `sst.config.ts` pattern

**Import Order:**
1. External dependencies (SST, AWS CDK)
2. Internal packages (none for this story)
3. Relative imports (`./sst/observability/tags`)

**Documentation:**
- Add TSDoc comments for exported tag utility functions
- Document tag schema rationale in `tags.ts` header comment

### Environment Variables
[Source: docs/architecture/tech-stack.md]

**AWS Configuration (from root .env):**
```bash
AWS_REGION=us-east-1
AWS_PROFILE=lego-moc
```

**SST Stage:**
- Dev: `sst deploy --stage dev`
- Staging: `sst deploy --stage staging`
- Prod: `sst deploy --stage prod`

**Tag Environment Mapping:**
- `dev` → `Environment: 'dev'`
- `staging` → `Environment: 'staging'`
- `prod` → `Environment: 'prod'`

### Deployment Commands
[Source: docs/architecture/tech-stack.md]

```bash
# Navigate to serverless API directory
cd apps/api/lego-api-serverless

# Build SST configuration (validates TypeScript)
sst build

# Deploy to dev environment
sst deploy --stage dev

# View deployed resources
sst console --stage dev
```

**Deployment Validation:**
```bash
# List VPC resources
aws ec2 describe-vpcs --filters "Name=tag:Project,Values=UserMetrics"

# List security groups
aws ec2 describe-security-groups --filters "Name=tag:Project,Values=UserMetrics"

# List IAM roles
aws iam list-roles --query "Roles[?contains(RoleName, 'Observability')]"

# Verify tags
aws resourcegroupstaggingapi get-resources \
  --resource-type-filters ec2:vpc ec2:security-group iam:role \
  --tag-filters Key=Project,Values=UserMetrics
```

### Budget and Cost Constraints
[Source: docs/prd/user-metrics/user-metrics-prd.md - NFR1]

**Budget:** $100-150/month for entire observability stack (<100 users)

**Cost-Optimized Infrastructure Choices:**
- **NAT Gateway:** Single NAT Gateway ($32/month) instead of multi-AZ ($64/month)
- **VPC:** Free (within AWS free tier limits)
- **Security Groups:** Free
- **IAM Roles:** Free
- **This story should add ~$32/month** (single NAT Gateway only)

**Cost Monitoring (Story 1.4):** AWS Budgets will be configured in later story with $150/month limit.

### Testing

**Testing Strategy:**
[Source: docs/architecture/coding-standards.md - Testing section]

**No Unit Tests Required:** This story creates infrastructure configuration, not application code. Infrastructure validation is done via:
1. SST build validation (TypeScript compilation)
2. SST deployment success
3. AWS CLI validation commands (manual verification)
4. Integration verification (IV1-IV3 from Acceptance Criteria)

**Manual Validation Checklist:**
- [ ] `sst build` succeeds without TypeScript errors
- [ ] `sst deploy --stage dev` completes successfully
- [ ] VPC created with correct CIDR and subnet configuration
- [ ] Security groups created with correct rules
- [ ] IAM roles created with correct policies
- [ ] All resources have minimum 5 required tags
- [ ] Existing application Lambda functions still connect to Aurora (IV2)
- [ ] Existing application deployment pipeline unaffected (IV3)

**Integration Tests:**
Run existing application health checks to verify no disruption:
```bash
# Test existing Lambda function
curl https://[api-gateway-url]/health

# Verify Aurora connectivity (from Lambda CloudWatch logs)
# Check Lambda execution logs for database connection success
```

**E2E Tests:**
Not applicable for infrastructure-only story. No Playwright tests required.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-23 | 1.0 | Initial story creation from Phase 1 PRD | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_(To be populated by Dev Agent)_

### Debug Log References
_(To be populated by Dev Agent)_

### Completion Notes
_(To be populated by Dev Agent)_

### File List
_(To be populated by Dev Agent)_

## QA Results
_(To be populated by QA Agent)_
