# Story 4.4: Implement POST /api/users/:id/avatar - Upload Avatar

**Epic**: 4 - User Profile & Advanced Features Migration

**As a** user,
**I want** to upload a profile avatar,
**so that** I can personalize my account.

## Acceptance Criteria

1. Lambda handler for avatar upload with multipart parsing
2. Image validation: JPEG/PNG/GIF, max 2MB size
3. Sharp processing: crop to square (1:1 aspect ratio), resize to 256x256, optimize, convert to WebP
4. Upload to S3: `avatars/{userId}/avatar.webp` (overwrites previous)
5. Cognito user attribute `picture` updated with S3 URL via `AdminUpdateUserAttributesCommand`
6. Previous avatar deleted from S3 if exists
7. Lambda memory 1024 MB for Sharp processing
8. Redis cache invalidated for user profile
9. Response: `{ success: true, data: { avatarUrl } }`
10. 403 if userId mismatch, 400 for invalid image

## Implementation Status

**Status**: Not Started

## Files Modified

_To be populated during implementation_

## QA Results

_Pending implementation and review_

---

## Requirements Traceability Matrix

| AC # | Requirement                            | Test Coverage | Status   |
| ---- | -------------------------------------- | ------------- | -------- |
| 1    | Multipart parsing for avatar upload    | TBD           | ⏳ PENDING |
| 2    | Image validation (JPEG/PNG/GIF, 2MB)   | TBD           | ⏳ PENDING |
| 3    | Sharp processing (square, 256x256)     | TBD           | ⏳ PENDING |
| 4    | S3 upload (overwrites)                 | TBD           | ⏳ PENDING |
| 5    | Cognito picture attribute update       | TBD           | ⏳ PENDING |
| 6    | Previous avatar cleanup                | TBD           | ⏳ PENDING |
| 7    | Lambda memory 1024 MB                  | TBD           | ⏳ PENDING |
| 8    | Redis cache invalidation               | TBD           | ⏳ PENDING |
| 9    | Response format                        | TBD           | ⏳ PENDING |
| 10   | Error handling (403, 400)              | TBD           | ⏳ PENDING |

**Overall Coverage: TBD**

---

## Test Summary

_To be populated during implementation_

### Recommended Test Coverage

1. **Successful Upload** - 3 tests
   - Upload avatar successfully (first time)
   - Replace existing avatar (verify old one deleted)
   - Verify Cognito picture attribute updated

2. **Validation** - 5 tests
   - Invalid file type (e.g., PDF) → 400
   - File too large (>2MB) → 400
   - Valid JPEG accepted
   - Valid PNG accepted
   - Valid GIF accepted

3. **Authorization** - 2 tests
   - 403 when uploading to another user's profile
   - 401 when JWT missing

4. **Image Processing** - 2 tests
   - Non-square image cropped to square
   - Large image resized to 256x256

5. **Cache Invalidation** - 1 test
   - Verify profile cache cleared after upload

---

## Technical Notes

### Image Validation

```typescript
import { validateFile, createImageValidationConfig } from '@monorepo/file-validator'

// Validate uploaded file
const validationResult = validateFile(
  {
    fieldname: 'avatar',
    originalname: file.filename,
    encoding: file.encoding || '7bit',
    mimetype: file.mimetype,
    size: file.buffer.length,
  },
  {
    allowedTypes: ['image/jpeg', 'image/png', 'image/gif'],
    maxSize: 2 * 1024 * 1024, // 2MB
  }
)

if (!validationResult.isValid) {
  return createErrorResponse(
    400,
    'VALIDATION_ERROR',
    validationResult.errors?.join(', ') || 'Invalid file'
  )
}
```

### Sharp Image Processing

```typescript
import sharp from 'sharp'

async function processAvatar(imageBuffer: Buffer): Promise<{ buffer: Buffer; info: sharp.OutputInfo }> {
  const processed = await sharp(imageBuffer)
    // Extract and crop to square (1:1 aspect ratio)
    .resize(256, 256, {
      fit: 'cover',          // Crop to fill dimensions
      position: 'center',    // Center the crop
    })
    // Optimize quality
    .webp({
      quality: 80,
      effort: 4,             // Balance between compression and speed
    })
    .toBuffer({ resolveWithObject: true })

  return {
    buffer: processed.data,
    info: processed.info,
  }
}
```

### S3 Upload with Overwrite

```typescript
import { uploadToS3 } from '@/lib/storage/s3-client'

// Single avatar per user - overwrites existing
const avatarKey = `avatars/${userId}/avatar.webp`
const avatarUrl = await uploadToS3({
  key: avatarKey,
  body: processedAvatar.buffer,
  contentType: 'image/webp',
})
```

### Previous Avatar Cleanup

```typescript
// Check if user already has an avatar in Cognito
const currentProfile = await getCognitoProfile(userId)

if (currentProfile.picture) {
  // Extract key from URL and delete old avatar
  try {
    const url = new URL(currentProfile.picture)
    const oldKey = url.pathname.startsWith('/')
      ? url.pathname.substring(1)
      : url.pathname

    await s3.send(new DeleteObjectCommand({
      Bucket: process.env.S3_BUCKET!,
      Key: oldKey,
    }))
  } catch (error) {
    console.warn('Failed to delete old avatar (may not exist):', error)
    // Non-blocking - continue with upload
  }
}
```

### Cognito Picture Update

```typescript
import { AdminUpdateUserAttributesCommand } from '@aws-sdk/client-cognito-identity-provider'

const command = new AdminUpdateUserAttributesCommand({
  UserPoolId: process.env.COGNITO_USER_POOL_ID!,
  Username: userId,
  UserAttributes: [
    {
      Name: 'picture',
      Value: avatarUrl,
    },
  ],
})

await cognitoClient.send(command)
```

### Complete Handler Flow

```typescript
async function handleUploadAvatar(
  event: APIGatewayProxyEventV2,
  userId: string,
  profileId: string,
): Promise<APIGatewayProxyResultV2> {
  // 1. Authorization
  if (userId !== profileId) {
    return createErrorResponse(403, 'FORBIDDEN', 'Cannot upload avatar for another user')
  }

  // 2. Parse multipart form data
  const formData = await parseMultipartForm(event)
  const file = getFile(formData)

  if (!file) {
    return createErrorResponse(400, 'BAD_REQUEST', 'No file uploaded')
  }

  // 3. Validate file
  const validationResult = validateFile(file, avatarConfig)
  if (!validationResult.isValid) {
    return createErrorResponse(400, 'VALIDATION_ERROR', validationResult.errors?.join(', '))
  }

  // 4. Process image with Sharp
  const processedAvatar = await processAvatar(file.buffer)

  // 5. Get current profile (for old avatar cleanup)
  const currentProfile = await getCognitoProfile(userId)

  // 6. Upload to S3 (overwrites)
  const avatarKey = `avatars/${userId}/avatar.webp`
  const avatarUrl = await uploadToS3({
    key: avatarKey,
    body: processedAvatar.buffer,
    contentType: 'image/webp',
  })

  // 7. Delete old avatar if exists
  if (currentProfile.picture) {
    await deleteOldAvatar(currentProfile.picture)
  }

  // 8. Update Cognito picture attribute
  await updateCognitoPicture(userId, avatarUrl)

  // 9. Invalidate cache
  await redis.del(`profile:user:${userId}`)

  // 10. Return response
  return createSuccessResponse({ avatarUrl }, 200)
}
```

### Response Format

```json
{
  "success": true,
  "data": {
    "avatarUrl": "https://bucket.s3.region.amazonaws.com/avatars/userId/avatar.webp"
  },
  "timestamp": "2025-01-02T12:00:00Z"
}
```

### Lambda Configuration

```typescript
// Already configured in Story 4.1
{
  memory: '1024 MB', // For Sharp processing
  timeout: '60 seconds',
  vpc: true,
  link: [bucket, redis],
}
```

---

## Design Decisions

### Square Crop Strategy

**Decision**: Use Sharp's `fit: 'cover'` with `position: 'center'`

**Rationale**:
- Ensures consistent 1:1 aspect ratio for all avatars
- Center crop preserves most important part of image
- Alternative (`fit: 'contain'`) would add padding

**User Experience**: Users should be informed that non-square images will be center-cropped

### Single Avatar File

**Decision**: Overwrite `avatars/{userId}/avatar.webp` instead of versioning

**Rationale**:
- Simplifies storage (no orphaned files)
- Users typically only need current avatar
- Reduces S3 costs
- Cognito `picture` attribute always points to latest

**Cleanup**: Previous avatar automatically deleted before new upload

### GIF Support

**Decision**: Accept GIF but convert to static WebP

**Rationale**:
- GIFs often used for avatars
- Animated GIFs converted to first frame (Sharp default)
- WebP provides better compression than GIF

---

## Error Scenarios

| Scenario | Status Code | Error Type | Message |
|----------|-------------|------------|---------|
| No file uploaded | 400 | BAD_REQUEST | No file uploaded |
| Invalid file type | 400 | VALIDATION_ERROR | File type not allowed |
| File too large | 400 | VALIDATION_ERROR | File exceeds 2MB limit |
| Sharp processing fails | 400 | FILE_ERROR | Image processing failed |
| S3 upload fails | 500 | INTERNAL_ERROR | Failed to upload avatar |
| Cognito update fails | 500 | INTERNAL_ERROR | Failed to update profile |
| Wrong user | 403 | FORBIDDEN | Cannot upload avatar for another user |

---

## Dependencies

- **Story 4.1**: Profile Lambda handler infrastructure (prerequisite)
- **@monorepo/file-validator**: For image validation
- **Sharp**: For image processing
- **S3 Bucket**: For avatar storage
- **Cognito User Pool**: For picture attribute update
- **Redis**: For cache invalidation

---

## Performance Considerations

1. **Sharp Processing**: 256x256 avatars process quickly (<200ms typically)
2. **S3 Overwrite**: More efficient than delete-then-upload
3. **Async Cleanup**: Old avatar deletion is non-blocking
4. **Cache Invalidation**: Ensures next profile fetch shows new avatar

---

## Comparison with Gallery Image Upload

| Aspect | Gallery (Story 3.2) | Avatar (Story 4.4) |
|--------|---------------------|-------------------|
| Max Size | 10MB | 2MB |
| Formats | JPEG, PNG, WebP | JPEG, PNG, GIF |
| Processing | Resize to 2048px | Crop + resize to 256x256 |
| Aspect Ratio | Preserve original | Force 1:1 square |
| Thumbnail | Yes (400px) | No |
| Storage | Versioned (UUID) | Overwrite single file |
| Lambda Memory | 2048 MB | 1024 MB |
