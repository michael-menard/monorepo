# Story 4.5: Implement DELETE /api/users/:id/avatar - Remove Avatar

**Epic**: 4 - User Profile & Advanced Features Migration

**As a** user,
**I want** to remove my profile avatar,
**so that** I can revert to a default image.

## Acceptance Criteria

1. Lambda handler deletes avatar from S3: `avatars/{userId}/avatar.webp`
2. Cognito user attribute `picture` set to null via `AdminUpdateUserAttributesCommand`
3. Authorization: userId match enforced
4. Redis cache invalidated
5. Response: `{ success: true, message: "Avatar removed" }`
6. 403 if userId mismatch
7. Success returned even if no avatar exists

## Implementation Status

**Status**: Not Started

## Files Modified

_To be populated during implementation_

## QA Results

_Pending implementation and review_

---

## Requirements Traceability Matrix

| AC # | Requirement                            | Test Coverage | Status     |
| ---- | -------------------------------------- | ------------- | ---------- |
| 1    | Delete avatar from S3                  | TBD           | ⏳ PENDING |
| 2    | Set Cognito picture to null            | TBD           | ⏳ PENDING |
| 3    | Authorization userId match             | TBD           | ⏳ PENDING |
| 4    | Redis cache invalidation               | TBD           | ⏳ PENDING |
| 5    | Response format                        | TBD           | ⏳ PENDING |
| 6    | 403 for unauthorized                   | TBD           | ⏳ PENDING |
| 7    | Idempotent (success even if no avatar) | TBD           | ⏳ PENDING |

**Overall Coverage: TBD**

---

## Test Summary

_To be populated during implementation_

### Recommended Test Coverage

1. **Successful Removal** - 3 tests
   - Remove existing avatar successfully
   - Verify S3 file deleted
   - Verify Cognito picture set to null

2. **Idempotency** - 1 test
   - Removing non-existent avatar returns success (no error)

3. **Authorization** - 2 tests
   - 403 when deleting another user's avatar
   - 401 when JWT missing

4. **Cache Invalidation** - 1 test
   - Verify profile cache cleared after deletion

5. **Cognito Update** - 1 test
   - Verify picture attribute set to null (not empty string)

---

## Technical Notes

### S3 Deletion

```typescript
import { DeleteObjectCommand } from '@aws-sdk/client-s3'

const s3 = await getS3Client()
const avatarKey = `avatars/${userId}/avatar.webp`

try {
  await s3.send(
    new DeleteObjectCommand({
      Bucket: process.env.S3_BUCKET!,
      Key: avatarKey,
    }),
  )
} catch (error) {
  // S3 DeleteObject is idempotent - no error if key doesn't exist
  console.warn('Avatar deletion (may not exist):', error)
  // Continue with Cognito update
}
```

### Cognito Picture Attribute Update

```typescript
import { AdminUpdateUserAttributesCommand } from '@aws-sdk/client-cognito-identity-provider'

// Set picture attribute to empty string (effectively null)
const command = new AdminUpdateUserAttributesCommand({
  UserPoolId: process.env.COGNITO_USER_POOL_ID!,
  Username: userId,
  UserAttributes: [
    {
      Name: 'picture',
      Value: '', // Empty string removes the attribute value
    },
  ],
})

await cognitoClient.send(command)
```

### Complete Handler Implementation

```typescript
async function handleDeleteAvatar(
  _event: APIGatewayProxyEventV2,
  userId: string,
  profileId: string,
): Promise<APIGatewayProxyResultV2> {
  // 1. Authorization check
  if (userId !== profileId) {
    return createErrorResponse(403, 'FORBIDDEN', "Cannot delete another user's avatar")
  }

  // 2. Delete from S3 (idempotent - no error if doesn't exist)
  const s3 = await getS3Client()
  const avatarKey = `avatars/${userId}/avatar.webp`

  try {
    await s3.send(
      new DeleteObjectCommand({
        Bucket: process.env.S3_BUCKET!,
        Key: avatarKey,
      }),
    )
  } catch (error) {
    // Log but don't fail - S3 DeleteObject succeeds even if object doesn't exist
    console.warn('S3 avatar deletion:', error)
  }

  // 3. Update Cognito to remove picture attribute
  try {
    const command = new AdminUpdateUserAttributesCommand({
      UserPoolId: process.env.COGNITO_USER_POOL_ID!,
      Username: userId,
      UserAttributes: [
        {
          Name: 'picture',
          Value: '', // Empty string to remove attribute
        },
      ],
    })

    await cognitoClient.send(command)
  } catch (error) {
    console.error('Cognito picture removal error:', error)
    return createErrorResponse(500, 'INTERNAL_ERROR', 'Failed to remove avatar')
  }

  // 4. Invalidate Redis cache
  const redis = await getRedisClient()
  await redis.del(`profile:user:${userId}`)

  // 5. Return success response
  return createSuccessResponse({ message: 'Avatar removed' }, 200)
}
```

### Response Format

```json
{
  "success": true,
  "data": {
    "message": "Avatar removed"
  },
  "timestamp": "2025-01-02T12:00:00Z"
}
```

---

## Design Decisions

### Idempotent Operation

**Decision**: Return success even if avatar doesn't exist

**Rationale**:

- DELETE operations should be idempotent (REST best practice)
- User's intent is "ensure no avatar exists" - achieved regardless
- S3 DeleteObject already idempotent (no error if key doesn't exist)
- Simplifies client logic (no need to check if avatar exists first)

### Empty String vs Null

**Decision**: Set Cognito attribute to empty string (`''`)

**Rationale**:

- Cognito doesn't support true `null` values for custom attributes
- Empty string effectively removes the attribute value
- Standard Cognito practice for clearing attribute values

### S3 First, Then Cognito

**Decision**: Delete S3 object before updating Cognito

**Rationale**:

- S3 deletion is idempotent and rarely fails
- If Cognito update fails, S3 object is already removed (acceptable)
- If S3 fails and Cognito succeeds, picture URL points to non-existent file (cached data will clear eventually)

**Alternative Considered**: Cognito first, then S3

- Risk: If S3 deletion fails, Cognito still points to existing file
- Current approach is safer

---

## Error Scenarios

| Scenario           | Status Code | Error Type     | Message                             |
| ------------------ | ----------- | -------------- | ----------------------------------- |
| Successful removal | 200         | N/A            | Avatar removed                      |
| No avatar exists   | 200         | N/A            | Avatar removed (idempotent)         |
| S3 failure         | 200         | N/A            | Continue anyway (logged)            |
| Cognito failure    | 500         | INTERNAL_ERROR | Failed to remove avatar             |
| Wrong user         | 403         | FORBIDDEN      | Cannot delete another user's avatar |
| No JWT             | 401         | UNAUTHORIZED   | Authentication required             |

---

## Cache Invalidation

```typescript
// Invalidate profile cache
const cacheKey = `profile:user:${userId}`
await redis.del(cacheKey)

// Next GET /api/users/{id} will fetch fresh data from Cognito
// User's profile will show avatarUrl: null
```

---

## User Experience Flow

1. **User clicks "Remove Avatar"** in UI
2. **Frontend calls** `DELETE /api/users/{userId}/avatar`
3. **Backend**:
   - Deletes S3 file `avatars/{userId}/avatar.webp`
   - Sets Cognito `picture` attribute to empty string
   - Invalidates Redis cache
4. **Frontend receives success**
5. **Frontend updates UI** to show default avatar icon
6. **Next profile fetch** returns `avatarUrl: null`
7. **UI displays default avatar** (e.g., initials or placeholder icon)

---

## Testing Idempotency

```typescript
describe('DELETE /api/users/:id/avatar', () => {
  it('should be idempotent - removing non-existent avatar succeeds', async () => {
    // User has no avatar
    const response = await request(app)
      .delete(`/api/users/${userId}/avatar`)
      .set('Authorization', `Bearer ${validJWT}`)

    expect(response.status).toBe(200)
    expect(response.body.success).toBe(true)
    expect(response.body.data.message).toBe('Avatar removed')

    // Second deletion also succeeds
    const response2 = await request(app)
      .delete(`/api/users/${userId}/avatar`)
      .set('Authorization', `Bearer ${validJWT}`)

    expect(response2.status).toBe(200)
    expect(response2.body.success).toBe(true)
  })
})
```

---

## Dependencies

- **Story 4.1**: Profile Lambda handler infrastructure (prerequisite)
- **S3 Bucket**: For avatar storage
- **Cognito User Pool**: For picture attribute update
- **Redis**: For cache invalidation

---

## Security Considerations

1. **Authorization**: Strict userId matching prevents cross-user deletions
2. **Idempotency**: Safe to call multiple times without side effects
3. **No Data Exposure**: Success response doesn't reveal if avatar existed
4. **Audit Logging**: Log avatar deletions with userId and timestamp

---

## Related Stories

- **Story 4.2**: GET profile (returns `avatarUrl: null` after deletion)
- **Story 4.4**: Upload avatar (can re-upload after deletion)
