# <!-- Powered by BMAD™ Core -->
workflow:
  id: parallel-story-development
  name: Parallel Story Development
  description: >-
    Coordinate multiple dev-worker sub-agents to implement stories in parallel,
    maximizing development throughput while maintaining quality and integration.
  type: parallel-execution
  
  use_cases:
    - Multiple independent stories ready for implementation
    - Stories with minimal dependencies
    - Time-sensitive feature delivery
    - Large epics with parallelizable work
    
  prerequisites:
    - Stories are approved (not in Draft status)
    - Stories have clear acceptance criteria
    - Dependencies between stories are identified
    - No critical resource conflicts
    
  phases:
    - phase: initialization
      agent: dev-coordinator
      steps:
        - step: validate_stories
          action: Check all stories are approved and ready
          validates:
            - Story status is not "Draft"
            - Acceptance criteria are complete
            - Technical context is sufficient
            - No blocking dependencies
            
        - step: analyze_dependencies
          action: Build dependency graph between stories
          outputs:
            - Dependency graph
            - Execution order recommendations
            - Parallelization opportunities
            
        - step: detect_conflicts
          action: Identify potential resource conflicts
          checks:
            - File modification conflicts
            - Shared component conflicts
            - Database schema conflicts
            - API contract conflicts
            
        - step: create_execution_plan
          action: Determine optimal worker allocation
          considers:
            - Story complexity
            - Dependency constraints
            - Resource availability
            - Estimated duration
          outputs:
            - Worker assignments
            - Execution order
            - Conflict mitigation strategy
            
    - phase: worker_spawning
      agent: dev-coordinator
      steps:
        - step: spawn_workers
          action: Create dev-worker sub-agent for each story
          for_each: story in execution_plan
          executes: spawn-sub-agent task
          creates:
            - Worker state file
            - Task assignment message
            - Resource locks (if needed)
            
        - step: initialize_workers
          action: Workers load stories and begin work
          worker_actions:
            - Load task assignment
            - Read story file
            - Analyze requirements
            - Create git branch
            - Report initialization complete
            
    - phase: parallel_execution
      agent: dev-coordinator
      steps:
        - step: monitor_progress
          action: Continuously monitor all workers
          executes: coordinate-workers task
          monitors:
            - Progress reports
            - Conflict reports
            - Blocker reports
            - Quality metrics
          frequency: every_2_minutes
          
        - step: resolve_conflicts
          action: Handle conflicts as they arise
          strategies:
            file_conflicts:
              non_overlapping: auto_merge
              overlapping: escalate_to_user
            dependency_conflicts:
              can_reorder: auto_reorder
              cannot_reorder: pause_dependent_worker
            resource_conflicts:
              shared_possible: grant_shared_access
              exclusive_needed: queue_or_escalate
              
        - step: manage_dependencies
          action: Unblock workers when dependencies complete
          triggers:
            - Worker completes task
            - Dependent workers notified
            - Artifacts passed to dependent workers
            - Dependent workers resume
            
        - step: handle_failures
          action: Recover from worker failures
          strategies:
            timeout: retry_or_spawn_replacement
            error: analyze_and_fix_or_escalate
            blocker: escalate_to_user
            
    - phase: integration
      agent: dev-coordinator
      steps:
        - step: collect_outputs
          action: Gather all worker deliverables
          executes: aggregate-results task
          collects:
            - Source files created/modified
            - Tests written
            - Documentation updates
            - PR links
            
        - step: validate_integration
          action: Ensure all components work together
          validates:
            - All tests pass
            - Lint passes
            - Type check passes
            - Build succeeds
            - No integration conflicts
            
        - step: generate_summary
          action: Create comprehensive completion report
          includes:
            - All stories completed
            - Total time saved
            - Quality metrics
            - Integration status
            - Next steps
            
  success_criteria:
    - All stories implemented and tested
    - All quality gates passed
    - No unresolved conflicts
    - Integration validated
    - PRs created for all stories
    
  metrics:
    efficiency:
      sequential_estimate: sum(story_estimates)
      parallel_actual: max(story_durations) + coordination_overhead
      time_saved: sequential_estimate - parallel_actual
      speedup_factor: sequential_estimate / parallel_actual
      
    quality:
      tests_written: sum(worker_tests)
      tests_passing: sum(worker_passing_tests)
      coverage: average(worker_coverage)
      lint_status: all_passing
      
    coordination:
      conflicts_detected: count
      conflicts_auto_resolved: count
      conflicts_escalated: count
      worker_failures: count
      
  example_usage: |
    User: @dev *parallel-develop stories=[1.1,1.2,1.3]
    
    Dev Agent transforms to dev-coordinator:
    
    === Parallel Development Initiated ===
    Stories: 1.1, 1.2, 1.3
    
    [Phase 1: Initialization]
    ✓ Validated all stories are approved
    ✓ Analyzed dependencies: 1.3 depends on 1.1
    ✓ Detected no resource conflicts
    ✓ Created execution plan:
      - Worker-1: Story 1.1 (start immediately)
      - Worker-2: Story 1.2 (start immediately)
      - Worker-3: Story 1.3 (wait for 1.1)
    
    [Phase 2: Worker Spawning]
    ✓ Spawned dev-worker-1 for Story 1.1
    ✓ Spawned dev-worker-2 for Story 1.2
    ✓ Spawned dev-worker-3 for Story 1.3 (paused)
    
    [Phase 3: Parallel Execution]
    Monitoring 3 workers...
    
    [Dashboard updates every 30 seconds showing progress]
    
    [Phase 4: Integration]
    ✓ All workers complete
    ✓ Collected outputs
    ✓ Integration validated
    ✓ Summary generated
    
    === Parallel Development Complete ===
    Time: 18 minutes (vs 45 minutes sequential)
    Speedup: 2.5x faster
    Quality: All tests passing, 100% coverage

