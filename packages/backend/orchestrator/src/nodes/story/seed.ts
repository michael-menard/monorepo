/**
 * Story Seed Node
 *
 * Generates initial story structure from reality baseline and retrieved context.
 * Takes user intent/feature description and produces a structured story seed
 * grounded in the current reality of the codebase.
 *
 * FLOW-023: LangGraph Story Node - Seed
 */

import { z } from 'zod'
import { createToolNode } from '../../runner/node-factory.js'
import type { GraphState } from '../../state/index.js'
import { updateState } from '../../runner/state-helpers.js'
import type { BaselineReality, RetrievedContext, GraphStateWithContext } from '../reality/index.js'

/**
 * Schema for a story request - the user's intent or feature description.
 */
export const StoryRequestSchema = z.object({
  /** Brief title or summary of the requested feature */
  title: z.string().min(1),
  /** Detailed description of what the user wants */
  description: z.string().min(1),
  /** Primary domain/area the story relates to */
  domain: z.string().min(1),
  /** Optional tags for categorization */
  tags: z.array(z.string()).default([]),
  /** Optional priority level (1-5, 1 being highest) */
  priority: z.number().int().min(1).max(5).optional(),
  /** Optional requestor identifier */
  requestedBy: z.string().optional(),
})

export type StoryRequest = z.infer<typeof StoryRequestSchema>

/**
 * Schema for an acceptance criterion in the story seed.
 */
export const AcceptanceCriterionSchema = z.object({
  /** Unique ID for the criterion (e.g., "AC-1", "AC-2") */
  id: z.string().min(1),
  /** Description of what must be true for acceptance */
  description: z.string().min(1),
  /** Whether this criterion is derived from baseline constraints */
  fromBaseline: z.boolean().default(false),
  /** Reference to baseline item if derived from baseline */
  baselineRef: z.string().optional(),
})

export type AcceptanceCriterion = z.infer<typeof AcceptanceCriterionSchema>

/**
 * Schema for initial story structure generated by the seed node.
 */
export const StoryStructureSchema = z.object({
  /** Generated story ID (prefix-number format) */
  storyId: z.string().regex(/^[a-z]+-\d+$/i),
  /** Story title */
  title: z.string().min(1),
  /** Story description elaborated from request */
  description: z.string().min(1),
  /** Primary domain/area */
  domain: z.string().min(1),
  /** Initial acceptance criteria */
  acceptanceCriteria: z.array(AcceptanceCriterionSchema),
  /** Constraints derived from baseline reality */
  constraints: z.array(z.string()).default([]),
  /** Files likely to be affected based on context */
  affectedFiles: z.array(z.string()).default([]),
  /** Dependencies or related stories */
  dependencies: z.array(z.string()).default([]),
  /** Estimated complexity (small, medium, large) */
  estimatedComplexity: z.enum(['small', 'medium', 'large']).optional(),
  /** Tags for categorization */
  tags: z.array(z.string()).default([]),
})

export type StoryStructure = z.infer<typeof StoryStructureSchema>

/**
 * Schema for seed node configuration.
 */
export const SeedConfigSchema = z.object({
  /** Prefix for generated story IDs */
  storyIdPrefix: z.string().min(1).default('story'),
  /** Starting number for story ID generation */
  startingNumber: z.number().int().positive().default(1),
  /** Maximum number of initial acceptance criteria to generate */
  maxInitialACs: z.number().int().positive().default(5),
  /** Whether to include file impact analysis */
  includeFileImpact: z.boolean().default(true),
  /** Whether to derive constraints from baseline */
  deriveConstraints: z.boolean().default(true),
})

export type SeedConfig = z.infer<typeof SeedConfigSchema>

/**
 * Schema for seed node result.
 */
export const SeedResultSchema = z.object({
  /** The generated story structure */
  storyStructure: StoryStructureSchema.nullable(),
  /** Whether seeding was successful */
  seeded: z.boolean(),
  /** Error message if seeding failed */
  error: z.string().optional(),
  /** Warnings encountered during seeding */
  warnings: z.array(z.string()).default([]),
})

export type SeedResult = z.infer<typeof SeedResultSchema>

/**
 * Generates a story ID from prefix and number.
 *
 * @param prefix - Story ID prefix (e.g., "flow", "story")
 * @param number - Story number
 * @returns Formatted story ID (e.g., "flow-023")
 */
export function generateStoryId(prefix: string, number: number): string {
  // Pad number to at least 3 digits
  const paddedNumber = number.toString().padStart(3, '0')
  return `${prefix.toLowerCase()}-${paddedNumber}`
}

/**
 * Extracts constraints from baseline reality.
 * These are items that must not be reworked or invalidated assumptions.
 *
 * @param baseline - The baseline reality
 * @param domain - Domain to filter constraints by
 * @returns Array of constraint strings
 */
export function extractConstraintsFromBaseline(
  baseline: BaselineReality | null | undefined,
  domain: string,
): string[] {
  if (!baseline) {
    return []
  }

  const constraints: string[] = []
  const domainLower = domain.toLowerCase()

  // Add no-rework items as constraints
  baseline.noRework?.forEach(item => {
    constraints.push(`Must not modify: ${item}`)
  })

  // Add invalid assumptions as things to avoid
  baseline.invalidAssumptions?.forEach(item => {
    if (item.toLowerCase().includes(domainLower)) {
      constraints.push(`Avoid assumption: ${item}`)
    }
  })

  // Add in-progress items as potential coordination points
  baseline.whatInProgress?.forEach(item => {
    if (item.toLowerCase().includes(domainLower)) {
      constraints.push(`Coordinate with in-progress: ${item}`)
    }
  })

  return constraints
}

/**
 * Extracts likely affected files from retrieved context.
 *
 * @param context - The retrieved context
 * @param maxFiles - Maximum number of files to include
 * @returns Array of relative file paths
 */
export function extractAffectedFiles(
  context: RetrievedContext | null | undefined,
  maxFiles: number = 10,
): string[] {
  if (!context || !context.files) {
    return []
  }

  // Return relative paths of files that were loaded (most relevant)
  return context.files
    .filter(file => file.contentLoaded)
    .slice(0, maxFiles)
    .map(file => file.relativePath)
}

/**
 * Generates initial acceptance criteria from the story request.
 *
 * @param request - The story request
 * @param constraints - Constraints from baseline
 * @param maxACs - Maximum number of ACs to generate
 * @returns Array of acceptance criteria
 */
export function generateInitialACs(
  request: StoryRequest,
  constraints: string[],
  maxACs: number = 5,
): AcceptanceCriterion[] {
  const acs: AcceptanceCriterion[] = []

  // AC-1: Core functionality from request description
  acs.push({
    id: 'AC-1',
    description: `Implement ${request.title}: ${request.description}`,
    fromBaseline: false,
  })

  // AC-2: Domain validation
  acs.push({
    id: 'AC-2',
    description: `Changes are scoped to the ${request.domain} domain`,
    fromBaseline: false,
  })

  // Add ACs from constraints (up to limit)
  let acNumber = 3
  for (const constraint of constraints) {
    if (acs.length >= maxACs) break

    // Transform "Must not modify" constraints into verification ACs
    if (constraint.startsWith('Must not modify:')) {
      const item = constraint.replace('Must not modify:', '').trim()
      acs.push({
        id: `AC-${acNumber++}`,
        description: `Verify ${item} remains unchanged`,
        fromBaseline: true,
        baselineRef: item,
      })
    } else if (constraint.startsWith('Coordinate with in-progress:')) {
      const item = constraint.replace('Coordinate with in-progress:', '').trim()
      acs.push({
        id: `AC-${acNumber++}`,
        description: `Coordinate implementation with ${item}`,
        fromBaseline: true,
        baselineRef: item,
      })
    }
  }

  return acs
}

/**
 * Estimates story complexity based on context and request.
 *
 * @param context - The retrieved context
 * @param constraints - Number of constraints
 * @returns Estimated complexity
 */
export function estimateComplexity(
  context: RetrievedContext | null | undefined,
  constraintsCount: number,
): 'small' | 'medium' | 'large' {
  const fileCount = context?.files?.length || 0

  // Simple heuristic based on files and constraints
  if (fileCount <= 3 && constraintsCount <= 2) {
    return 'small'
  } else if (fileCount <= 10 && constraintsCount <= 5) {
    return 'medium'
  } else {
    return 'large'
  }
}

/**
 * Generates a story seed from baseline, context, and request.
 *
 * @param baseline - The baseline reality (may be null)
 * @param context - The retrieved context (may be null)
 * @param request - The story request
 * @param config - Configuration options
 * @returns Seed result with story structure or error
 */
export async function generateStorySeed(
  baseline: BaselineReality | null | undefined,
  context: RetrievedContext | null | undefined,
  request: StoryRequest,
  config: Partial<SeedConfig> = {},
): Promise<SeedResult> {
  const fullConfig = SeedConfigSchema.parse(config)
  const warnings: string[] = []

  try {
    // Validate request
    const validatedRequest = StoryRequestSchema.parse(request)

    // Generate story ID
    const storyId = generateStoryId(fullConfig.storyIdPrefix, fullConfig.startingNumber)

    // Extract constraints from baseline
    const constraints = fullConfig.deriveConstraints
      ? extractConstraintsFromBaseline(baseline, validatedRequest.domain)
      : []

    if (!baseline) {
      warnings.push('No baseline reality available - constraints may be incomplete')
    }

    // Extract affected files from context
    const affectedFiles = fullConfig.includeFileImpact
      ? extractAffectedFiles(context, 10)
      : []

    if (!context) {
      warnings.push('No retrieved context available - file impact analysis skipped')
    }

    // Generate initial acceptance criteria
    const acceptanceCriteria = generateInitialACs(
      validatedRequest,
      constraints,
      fullConfig.maxInitialACs,
    )

    // Estimate complexity
    const estimatedComplexity = estimateComplexity(context, constraints.length)

    // Build story structure
    const storyStructure: StoryStructure = {
      storyId,
      title: validatedRequest.title,
      description: validatedRequest.description,
      domain: validatedRequest.domain,
      acceptanceCriteria,
      constraints,
      affectedFiles,
      dependencies: [],
      estimatedComplexity,
      tags: validatedRequest.tags,
    }

    // Validate structure
    const validated = StoryStructureSchema.parse(storyStructure)

    return {
      storyStructure: validated,
      seeded: true,
      warnings,
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error during seeding'
    return {
      storyStructure: null,
      seeded: false,
      error: errorMessage,
      warnings,
    }
  }
}

/**
 * Extended graph state with story seed.
 * Used by downstream nodes that consume the story structure.
 */
export interface GraphStateWithStorySeed extends GraphStateWithContext {
  /** The story request from user */
  storyRequest?: StoryRequest
  /** The generated story structure */
  storyStructure?: StoryStructure | null
  /** Whether story was successfully seeded */
  storySeeded?: boolean
  /** Warnings from seeding process */
  seedWarnings?: string[]
}

/**
 * Story Seed node implementation.
 *
 * Generates initial story structure based on baseline reality, retrieved context,
 * and the story request. Uses the tool preset (lower retries, shorter timeout)
 * since this is primarily computation with no external calls.
 *
 * @param state - Current graph state (must have storyRequest, optionally baseline and context)
 * @returns Partial state update with story structure
 */
export const storySeedNode = createToolNode(
  'story_seed',
  async (state: GraphState): Promise<Partial<GraphStateWithStorySeed>> => {
    const stateWithContext = state as GraphStateWithStorySeed

    // Require story request
    if (!stateWithContext.storyRequest) {
      return updateState({
        storyStructure: null,
        storySeeded: false,
        seedWarnings: ['No story request provided'],
      } as Partial<GraphStateWithStorySeed>)
    }

    const result = await generateStorySeed(
      stateWithContext.baselineReality,
      stateWithContext.retrievedContext,
      stateWithContext.storyRequest,
      {
        storyIdPrefix: state.epicPrefix,
        startingNumber: parseInt(state.storyId.split('-')[1] || '1', 10),
      },
    )

    if (!result.seeded) {
      return updateState({
        storyStructure: null,
        storySeeded: false,
        seedWarnings: result.warnings,
      } as Partial<GraphStateWithStorySeed>)
    }

    return updateState({
      storyStructure: result.storyStructure,
      storySeeded: true,
      seedWarnings: result.warnings,
    } as Partial<GraphStateWithStorySeed>)
  },
)

/**
 * Creates a story seed node with custom configuration.
 *
 * @param config - Configuration options
 * @returns Configured node function
 */
export function createStorySeedNode(config: Partial<SeedConfig> = {}) {
  return createToolNode(
    'story_seed',
    async (state: GraphState): Promise<Partial<GraphStateWithStorySeed>> => {
      const stateWithContext = state as GraphStateWithStorySeed

      // Require story request
      if (!stateWithContext.storyRequest) {
        throw new Error('Story request is required for seeding')
      }

      const result = await generateStorySeed(
        stateWithContext.baselineReality,
        stateWithContext.retrievedContext,
        stateWithContext.storyRequest,
        config,
      )

      if (!result.seeded) {
        if (result.error) {
          throw new Error(result.error)
        }

        return updateState({
          storyStructure: null,
          storySeeded: false,
          seedWarnings: result.warnings,
        } as Partial<GraphStateWithStorySeed>)
      }

      return updateState({
        storyStructure: result.storyStructure,
        storySeeded: true,
        seedWarnings: result.warnings,
      } as Partial<GraphStateWithStorySeed>)
    },
  )
}

/**
 * Creates a story seed node with a predefined request.
 * Useful for testing or when the request is known ahead of time.
 *
 * @param request - The story request to use
 * @param config - Configuration options
 * @returns Configured node function
 */
export function createPrefilledStorySeedNode(
  request: StoryRequest,
  config: Partial<SeedConfig> = {},
) {
  return createToolNode(
    'story_seed',
    async (state: GraphState): Promise<Partial<GraphStateWithStorySeed>> => {
      const stateWithContext = state as GraphStateWithStorySeed

      const result = await generateStorySeed(
        stateWithContext.baselineReality,
        stateWithContext.retrievedContext,
        request,
        config,
      )

      if (!result.seeded) {
        if (result.error) {
          throw new Error(result.error)
        }

        return updateState({
          storyStructure: null,
          storySeeded: false,
          seedWarnings: result.warnings,
        } as Partial<GraphStateWithStorySeed>)
      }

      return updateState({
        storyRequest: request,
        storyStructure: result.storyStructure,
        storySeeded: true,
        seedWarnings: result.warnings,
      } as Partial<GraphStateWithStorySeed>)
    },
  )
}
