# KB Memory Architecture (3-Bucket System)

This document describes the Knowledge Base memory architecture used by AI agents in the workflow system. The KB uses a 3-bucket conceptual model to organize different types of knowledge.

## Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Knowledge Base 3-Bucket Model                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────────────────┐  ┌──────────────────────────┐                 │
│  │      BUCKET A            │  │      BUCKET B            │                 │
│  │    Durable Facts         │  │    Work State            │                 │
│  │                          │  │                          │                 │
│  │  - Lessons Learned       │  │  - working-set.md        │                 │
│  │  - ADRs / Decisions      │  │  - Session Context       │                 │
│  │  - Patterns              │  │  - Active Constraints    │                 │
│  │  - Constraints           │  │  - Current Phase         │                 │
│  │                          │  │                          │                 │
│  │  Long-lived, rarely      │  │  Story-scoped,           │                 │
│  │  changes                 │  │  updates frequently      │                 │
│  └──────────────────────────┘  └──────────────────────────┘                 │
│                                                                              │
│  ┌──────────────────────────┐                                               │
│  │      BUCKET C            │                                               │
│  │    Task Backlog          │                                               │
│  │                          │                                               │
│  │  - Follow-up Tasks       │                                               │
│  │  - Bug Reports           │                                               │
│  │  - Improvement Ideas     │                                               │
│  │                          │                                               │
│  │  Actionable items for    │                                               │
│  │  future work             │                                               │
│  └──────────────────────────┘                                               │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Bucket A: Durable Facts

**Purpose:** Long-lived institutional knowledge that persists across stories and sessions.

### Entry Types

| Type | Schema | Description |
|------|--------|-------------|
| `lesson` | `kb_add_lesson` | Learnings from implementation, blockers, patterns |
| `decision` | `kb_add_decision` | Architectural decisions (ADRs) |
| `note` | `kb_add_note` | General knowledge entries |
| `runbook` | `kb_add_runbook` | Operational procedures |

### Lesson Categories

| Category | Use Case |
|----------|----------|
| `reuse` | Reusable patterns and utilities discovered |
| `blockers` | What blocked progress and how to avoid |
| `performance` | Performance issues and optimizations |
| `testing` | Test strategies and edge cases |
| `architecture` | Structural patterns and decisions |

### Adding Lessons

```javascript
kb_add_lesson({
  title: "DI pattern reuse for image functions",
  story_id: "WISH-2045",
  category: "reuse",
  what_happened: "Needed to implement 4 new image functions",
  resolution: "Applied DI pattern from album functions - highly reusable",
  tags: ["dependency-injection", "image-processing"]
})
```

### Querying Durable Facts

```javascript
// Find relevant lessons for current work
kb_search({
  query: "image processing patterns",
  tags: ["lesson-learned"],
  limit: 5
})

// Find ADRs about a specific topic
kb_search({
  query: "authentication approach",
  entry_type: "decision",
  limit: 3
})
```

---

## Bucket B: Work State

**Purpose:** Active session context tied to specific story execution.

### working-set.md

The primary work state file, located at `/.agent/working-set.md` in the worktree root.

```markdown
# Working Set
<!-- Auto-generated by dev-setup-leader -->
<!-- Last updated: 2026-02-04T10:30:00Z by dev-execute-leader -->

## Current Context

| Field | Value |
|-------|-------|
| Story | WISH-2045 |
| Branch | feat/heic-upload |
| Phase | implementation |
| Started | 2026-02-04T09:00:00Z |
| Worktree | tree/wish-2045 |

## Active Constraints

1. Use Zod schemas for all types — _Source: CLAUDE.md_
2. No barrel files — _Source: CLAUDE.md_
3. HEIC must convert client-side — _Source: ADR-015_
4. Max 5MB file size — _Source: Story AC3_
5. Use @repo/logger, not console — _Source: CLAUDE.md_

## Recent Actions

- [x] Setup complete
- [x] Backend implementation complete
- [ ] Frontend implementation in progress
- [ ] E2E tests pending

## Next Steps

1. Complete frontend HEIC preview component
2. Write E2E tests with live backend
3. Run verification

## Open Blockers

_None_

## KB References

| Name | KB Entry ID | Summary |
|------|-------------|---------|
| HEIC browser support | kb-001234 | Client-side HEIC detection requires extension check |
```

### Syncing Work State to KB

Work state is backed up to KB for crash recovery:

```javascript
// At session end
kb_sync_working_set({
  story_id: "WISH-2045",
  content: "<working-set.md content>",
  direction: "to_kb"
})

// At session start (if working-set.md missing)
kb_sync_working_set({
  story_id: "WISH-2045",
  direction: "from_kb"
})
```

### Archiving on Completion

When a story passes QA verification:

```javascript
kb_archive_working_set({
  story_id: "WISH-2045",
  content: "<final working-set.md content>"
})
// Writes to _implementation/WORKING-SET-ARCHIVE.md
```

---

## Bucket C: Task Backlog

**Purpose:** Actionable items for future work, discovered during story execution.

### Task Types

| Type | Description | Example |
|------|-------------|---------|
| `follow_up` | Improvements identified during work | "Add retry logic to upload" |
| `bug` | Bugs discovered | "HEIC fails on Safari < 16" |
| `improvement` | Non-blocking enhancements | "Add upload progress bar" |
| `tech_debt` | Technical debt to address | "Refactor FileUploader class" |
| `documentation` | Missing documentation | "Add HEIC troubleshooting guide" |

### Adding Tasks

```javascript
kb_add_task({
  title: "Add retry logic to HEIC upload",
  task_type: "follow_up",
  description: "Upload sometimes fails on slow connections. Add 3-retry with exponential backoff.",
  source_story_id: "WISH-2045",
  source_phase: "implementation",
  source_agent: "dev-execute-leader",
  priority: "p2",
  tags: ["upload", "reliability"]
})
```

### Querying Tasks

```javascript
// List open tasks for a story
kb_list_tasks({
  source_story_id: "WISH-2045",
  status: "open"
})

// List all high-priority bugs
kb_list_tasks({
  task_type: "bug",
  priority: "p1",
  status: "open"
})
```

### Updating Tasks

```javascript
// Mark task as complete
kb_update_task({
  id: "task-uuid",
  status: "completed",
  completed_at: "2026-02-04T15:00:00Z"
})
```

### Task Audit Trail

All task changes are tracked in `task_audit_log`:

```sql
SELECT * FROM task_audit_log WHERE task_id = 'task-uuid' ORDER BY timestamp;
```

---

## Agent Integration Patterns

### Session Bootstrap (Start of Run)

Every agent should bootstrap context at session start:

```javascript
// 1. Read local working-set.md if exists
// 2. Check for blockers
// 3. Query KB for relevant context
kb_search({
  query: "{story domain} constraints patterns",
  role: "dev",
  limit: 5
})

// 4. Summarize active rules
// Output: "Following constraints: [top 3-5 from working-set.md]"
```

### Session Close (End of Run)

Every agent should persist learnings at session end:

```javascript
// 1. Update working-set.md with completed actions
// 2. Write significant learnings to KB
if (notable_learning) {
  kb_add_lesson({
    title: "...",
    story_id: "{STORY_ID}",
    category: "...",
    what_happened: "...",
    resolution: "..."
  })
}

// 3. Add follow-up tasks if discovered
if (follow_up_needed) {
  kb_add_task({
    title: "...",
    task_type: "follow_up",
    source_story_id: "{STORY_ID}",
    source_phase: "{phase}"
  })
}

// 4. Sync working-set to KB backup
kb_sync_working_set({
  story_id: "{STORY_ID}",
  content: "<working-set.md>",
  direction: "to_kb"
})
```

### Deferred Writes

If KB is unavailable, queue writes locally:

```yaml
# _implementation/DEFERRED-KB-WRITES.yaml
deferred_writes:
  - type: lesson
    payload:
      title: "..."
      story_id: "..."
      category: "..."
    queued_at: "2026-02-04T10:30:00Z"
    reason: "KB connection timeout"
```

Process deferred writes when KB becomes available.

---

## MCP Tools Reference

### Bucket A (Durable Facts)

| Tool | Purpose |
|------|---------|
| `kb_add` | Add generic knowledge entry |
| `kb_add_lesson` | Add lesson learned |
| `kb_add_decision` | Add architectural decision |
| `kb_add_note` | Add general note |
| `kb_add_runbook` | Add operational runbook |
| `kb_search` | Semantic + keyword search |
| `kb_get_related` | Find related entries |

### Bucket B (Work State)

| Tool | Purpose |
|------|---------|
| `kb_sync_working_set` | Sync working-set.md to/from KB |
| `kb_archive_working_set` | Archive completed working set |
| `kb_inherit_constraints` | Get inherited constraints for story |

### Bucket C (Task Backlog)

| Tool | Purpose |
|------|---------|
| `kb_add_task` | Add task to backlog |
| `kb_list_tasks` | List tasks with filters |
| `kb_update_task` | Update task status/details |
| `kb_close_task` | Close a task |

---

## Best Practices

### DO

- Query KB before starting work (avoid reinventing solutions)
- Write lessons for non-obvious discoveries
- Add tasks for deferred work (don't just note it)
- Sync working-set at session end
- Use specific tags for searchability
- Cite KB sources in artifacts ("Per KB entry {ID}: ...")

### DON'T

- Write trivial lessons (obvious patterns)
- Duplicate existing KB entries (search first)
- Store temporary/throwaway data in KB
- Skip session close (breaks crash recovery)
- Create tasks for in-scope work

---

## Related Documentation

- [README.md](../README.md) - Main package documentation
- [DEPLOYMENT.md](./DEPLOYMENT.md) - MCP server deployment guide
- [PERFORMANCE.md](./PERFORMANCE.md) - Performance tuning guide
- [DISASTER-RECOVERY-RUNBOOK.md](./DISASTER-RECOVERY-RUNBOOK.md) - Backup and recovery
