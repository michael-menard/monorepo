/**
 * Knowledge Base Type Schemas
 *
 * Zod schemas for runtime validation of knowledge entries and embeddings.
 * All types are inferred from Zod schemas following monorepo conventions.
 *
 * @see CLAUDE.md for Zod-first types requirement
 */

import { z } from 'zod'

/**
 * Valid roles for knowledge entries.
 *
 * - 'pm': Product manager knowledge
 * - 'dev': Developer knowledge
 * - 'qa': QA/testing knowledge
 * - 'all': Universal knowledge applicable to all roles
 */
export const KnowledgeRoleSchema = z.enum(['pm', 'dev', 'qa', 'all'])
export type KnowledgeRole = z.infer<typeof KnowledgeRoleSchema>

/**
 * Valid entry types for knowledge entries.
 *
 * Part of the KBMEM 3-bucket memory architecture:
 * - 'note': General notes and documentation (default)
 * - 'decision': Architecture Decision Records (ADRs)
 * - 'constraint': Project/epic/story constraints
 * - 'runbook': Step-by-step operational procedures
 * - 'lesson': Lessons learned from implementation
 *
 * @see KBMEM-001 for implementation details
 * @see plans/future/kb-memory-architecture/PLAN.md
 */
export const KnowledgeEntryTypeSchema = z.enum([
  'note',
  'decision',
  'constraint',
  'runbook',
  'lesson',
])
export type KnowledgeEntryType = z.infer<typeof KnowledgeEntryTypeSchema>

/**
 * Vector embedding schema.
 *
 * Validates that embedding is an array of numbers with exactly 1536 dimensions
 * (matching OpenAI text-embedding-3-small output).
 */
export const EmbeddingSchema = z
  .array(z.number())
  .length(1536, 'Embedding must have exactly 1536 dimensions (OpenAI text-embedding-3-small)')

export type Embedding = z.infer<typeof EmbeddingSchema>

/**
 * Knowledge entry schema for validation.
 *
 * Used for validating knowledge entries before database operations.
 */
export const KnowledgeEntrySchema = z.object({
  id: z.string().uuid().optional(),
  content: z.string().min(1, 'Content cannot be empty'),
  embedding: EmbeddingSchema,
  role: KnowledgeRoleSchema,
  entryType: KnowledgeEntryTypeSchema.optional().default('note'),
  storyId: z.string().optional().nullable(),
  tags: z.array(z.string()).optional().nullable(),
  verified: z.boolean().optional().default(false),
  verifiedAt: z.date().optional().nullable(),
  verifiedBy: z.string().optional().nullable(),
  createdAt: z.date().optional(),
  updatedAt: z.date().optional(),
})

export type KnowledgeEntryInput = z.infer<typeof KnowledgeEntrySchema>

/**
 * Schema for creating a new knowledge entry.
 *
 * Excludes auto-generated fields (id, timestamps).
 */
export const NewKnowledgeEntrySchema = z.object({
  content: z.string().min(1, 'Content cannot be empty'),
  embedding: EmbeddingSchema,
  role: KnowledgeRoleSchema,
  entryType: KnowledgeEntryTypeSchema.optional().default('note'),
  storyId: z.string().optional().nullable(),
  tags: z.array(z.string()).optional().nullable(),
})

export type NewKnowledgeEntryInput = z.infer<typeof NewKnowledgeEntrySchema>

/**
 * Schema for updating a knowledge entry.
 *
 * All fields are optional to support partial updates.
 */
export const UpdateKnowledgeEntrySchema = z.object({
  content: z.string().min(1, 'Content cannot be empty').optional(),
  embedding: EmbeddingSchema.optional(),
  role: KnowledgeRoleSchema.optional(),
  entryType: KnowledgeEntryTypeSchema.optional(),
  storyId: z.string().optional().nullable(),
  tags: z.array(z.string()).optional().nullable(),
  verified: z.boolean().optional(),
  verifiedAt: z.date().optional().nullable(),
  verifiedBy: z.string().optional().nullable(),
})

export type UpdateKnowledgeEntryInput = z.infer<typeof UpdateKnowledgeEntrySchema>

/**
 * Embedding cache entry schema.
 */
export const EmbeddingCacheEntrySchema = z.object({
  contentHash: z.string().min(1, 'Content hash cannot be empty'),
  embedding: EmbeddingSchema,
  createdAt: z.date().optional(),
})

export type EmbeddingCacheEntryInput = z.infer<typeof EmbeddingCacheEntrySchema>

/**
 * Schema for new embedding cache entry.
 */
export const NewEmbeddingCacheEntrySchema = z.object({
  contentHash: z.string().min(1, 'Content hash cannot be empty'),
  embedding: EmbeddingSchema,
})

export type NewEmbeddingCacheEntryInput = z.infer<typeof NewEmbeddingCacheEntrySchema>

/**
 * Schema for vector similarity search parameters.
 */
export const SimilaritySearchParamsSchema = z.object({
  /** The query embedding vector */
  queryEmbedding: EmbeddingSchema,

  /** Maximum number of results to return */
  limit: z.number().int().positive().max(100).default(10),

  /** Optional role filter */
  role: KnowledgeRoleSchema.optional(),

  /** Optional tags filter (entries must have at least one matching tag) */
  tags: z.array(z.string()).optional(),

  /** Minimum similarity threshold (0-1) */
  minSimilarity: z.number().min(0).max(1).optional(),
})

export type SimilaritySearchParams = z.infer<typeof SimilaritySearchParamsSchema>

/**
 * Schema for similarity search result.
 */
export const SimilaritySearchResultSchema = z.object({
  id: z.string().uuid(),
  content: z.string(),
  role: KnowledgeRoleSchema,
  tags: z.array(z.string()).nullable(),

  /** Cosine similarity score (0-1, higher is more similar) */
  similarity: z.number().min(0).max(1),
})

export type SimilaritySearchResult = z.infer<typeof SimilaritySearchResultSchema>

// ============================================================================
// Task Schemas (Bucket C - Task Backlog)
// ============================================================================

/**
 * Valid task types for the task backlog.
 *
 * @see KBMEM-002 for implementation details
 */
export const TaskTypeSchema = z.enum([
  'follow_up',
  'improvement',
  'bug',
  'tech_debt',
  'feature_idea',
])
export type TaskType = z.infer<typeof TaskTypeSchema>

/**
 * Valid priority levels for tasks.
 */
export const TaskPrioritySchema = z.enum(['p0', 'p1', 'p2', 'p3'])
export type TaskPriority = z.infer<typeof TaskPrioritySchema>

/**
 * Valid status values for tasks.
 */
export const TaskStatusSchema = z.enum([
  'open',
  'triaged',
  'in_progress',
  'blocked',
  'done',
  'wont_do',
  'promoted',
])
export type TaskStatus = z.infer<typeof TaskStatusSchema>

/**
 * Valid effort estimates for tasks.
 */
export const TaskEffortSchema = z.enum(['xs', 's', 'm', 'l', 'xl'])
export type TaskEffort = z.infer<typeof TaskEffortSchema>

/**
 * Task schema for validation.
 */
export const TaskSchema = z.object({
  id: z.string().uuid().optional(),
  title: z.string().min(1, 'Title cannot be empty'),
  description: z.string().optional().nullable(),
  sourceStoryId: z.string().optional().nullable(),
  sourcePhase: z.string().optional().nullable(),
  sourceAgent: z.string().optional().nullable(),
  taskType: TaskTypeSchema,
  priority: TaskPrioritySchema.optional().nullable(),
  status: TaskStatusSchema.default('open'),
  blockedBy: z.string().uuid().optional().nullable(),
  relatedKbEntries: z.array(z.string().uuid()).optional().nullable(),
  promotedToStory: z.string().optional().nullable(),
  tags: z.array(z.string()).optional().nullable(),
  estimatedEffort: TaskEffortSchema.optional().nullable(),
  createdAt: z.date().optional(),
  updatedAt: z.date().optional(),
  completedAt: z.date().optional().nullable(),
})

export type TaskInput = z.infer<typeof TaskSchema>

/**
 * Schema for creating a new task.
 */
export const NewTaskSchema = z.object({
  title: z.string().min(1, 'Title cannot be empty'),
  description: z.string().optional().nullable(),
  sourceStoryId: z.string().optional().nullable(),
  sourcePhase: z.string().optional().nullable(),
  sourceAgent: z.string().optional().nullable(),
  taskType: TaskTypeSchema,
  priority: TaskPrioritySchema.optional().nullable(),
  tags: z.array(z.string()).optional().nullable(),
  estimatedEffort: TaskEffortSchema.optional().nullable(),
})

export type NewTaskInput = z.infer<typeof NewTaskSchema>

/**
 * Schema for updating a task.
 */
export const UpdateTaskSchema = z.object({
  title: z.string().min(1).optional(),
  description: z.string().optional().nullable(),
  priority: TaskPrioritySchema.optional().nullable(),
  status: TaskStatusSchema.optional(),
  blockedBy: z.string().uuid().optional().nullable(),
  tags: z.array(z.string()).optional().nullable(),
  estimatedEffort: TaskEffortSchema.optional().nullable(),
})

export type UpdateTaskInput = z.infer<typeof UpdateTaskSchema>

// ============================================================================
// Work State Schemas (Bucket B - Session State)
// ============================================================================

/**
 * Valid workflow phases for work state.
 *
 * @see KBMEM-003 for implementation details
 */
export const WorkPhaseSchema = z.enum([
  'planning',
  'in-elaboration',
  'ready-to-work',
  'implementation',
  'ready-for-code-review',
  'review',
  'ready-for-qa',
  'in-qa',
  'verification',
  'uat',
  'complete',
])
export type WorkPhase = z.infer<typeof WorkPhaseSchema>

/**
 * Schema for a constraint in work state.
 */
export const WorkConstraintSchema = z.object({
  constraint: z.string(),
  source: z.string().optional(),
  priority: z.number().optional(),
})

export type WorkConstraint = z.infer<typeof WorkConstraintSchema>

/**
 * Schema for a recent action in work state.
 */
export const RecentActionSchema = z.object({
  action: z.string(),
  completed: z.boolean().default(false),
  timestamp: z.string().optional(),
})

export type RecentAction = z.infer<typeof RecentActionSchema>

/**
 * Schema for a blocker in work state.
 */
export const BlockerSchema = z.object({
  title: z.string(),
  description: z.string().optional(),
  waitingOn: z.string().optional(),
})

export type Blocker = z.infer<typeof BlockerSchema>

/**
 * Work state schema for validation.
 */
export const WorkStateSchema = z.object({
  id: z.string().uuid().optional(),
  storyId: z.string().min(1, 'Story ID cannot be empty'),
  branch: z.string().optional().nullable(),
  phase: WorkPhaseSchema.optional().nullable(),
  constraints: z.array(WorkConstraintSchema).optional().default([]),
  recentActions: z.array(RecentActionSchema).optional().default([]),
  nextSteps: z.array(z.string()).optional().default([]),
  blockers: z.array(BlockerSchema).optional().default([]),
  kbReferences: z.record(z.string().uuid()).optional().default({}),
  createdAt: z.date().optional(),
  updatedAt: z.date().optional(),
})

export type WorkStateInput = z.infer<typeof WorkStateSchema>

/**
 * Schema for updating work state.
 */
export const UpdateWorkStateSchema = z.object({
  branch: z.string().optional().nullable(),
  phase: WorkPhaseSchema.optional().nullable(),
  constraints: z.array(WorkConstraintSchema).optional(),
  recentActions: z.array(RecentActionSchema).optional(),
  nextSteps: z.array(z.string()).optional(),
  blockers: z.array(BlockerSchema).optional(),
  kbReferences: z.record(z.string().uuid()).optional(),
})

export type UpdateWorkStateInput = z.infer<typeof UpdateWorkStateSchema>

/**
 * Validate a knowledge entry.
 *
 * @param data - Data to validate
 * @returns Validated knowledge entry
 * @throws ZodError if validation fails
 */
export function validateKnowledgeEntry(data: unknown): KnowledgeEntryInput {
  return KnowledgeEntrySchema.parse(data)
}

/**
 * Validate embedding dimensions.
 *
 * @param embedding - Embedding array to validate
 * @returns true if valid
 * @throws ZodError if validation fails
 */
export function validateEmbedding(embedding: unknown): Embedding {
  return EmbeddingSchema.parse(embedding)
}

/**
 * Safely validate a knowledge entry.
 *
 * @param data - Data to validate
 * @returns Result object with success flag and data or error
 */
export function safeValidateKnowledgeEntry(data: unknown) {
  return KnowledgeEntrySchema.safeParse(data)
}

// ============================================================================
// Story Schemas (KBAR-001 - KB Story & Artifact Migration)
// ============================================================================

/**
 * Valid story types.
 *
 * @see KBAR-001 for implementation details
 */
export const StoryTypeSchema = z.enum(['feature', 'bug', 'spike', 'chore', 'tech_debt'])
export type StoryType = z.infer<typeof StoryTypeSchema>

/**
 * Valid story priority levels.
 */
export const StoryPrioritySchema = z.enum(['critical', 'high', 'medium', 'low'])
export type StoryPriority = z.infer<typeof StoryPrioritySchema>

/**
 * Valid story workflow states.
 *
 * Lifecycle: backlog → ready → in_progress → ready_for_review → in_review →
 *            ready_for_qa → in_qa → completed/cancelled/deferred
 */
export const StoryStateSchema = z.enum([
  'backlog',
  'ready',
  'in_progress',
  'ready_for_review',
  'in_review',
  'ready_for_qa',
  'in_qa',
  'completed',
  'cancelled',
  'deferred',
])
export type StoryState = z.infer<typeof StoryStateSchema>

/**
 * Valid story implementation phases.
 */
export const StoryPhaseSchema = z.enum([
  'setup',
  'analysis',
  'planning',
  'implementation',
  'code_review',
  'qa_verification',
  'completion',
])
export type StoryPhase = z.infer<typeof StoryPhaseSchema>

/**
 * Valid dependency relationship types.
 */
export const DependencyTypeSchema = z.enum([
  'depends_on',
  'blocked_by',
  'follow_up_from',
  'enables',
])
export type DependencyType = z.infer<typeof DependencyTypeSchema>

/**
 * Valid artifact types for story artifacts.
 */
export const ArtifactTypeSchema = z.enum([
  'checkpoint',
  'scope',
  'plan',
  'evidence',
  'verification',
  'analysis',
  'context',
  'fix_summary',
  'proof',
  'elaboration',
  'review',
  'qa_gate',
  'completion_report',
])
export type ArtifactType = z.infer<typeof ArtifactTypeSchema>

/**
 * Story schema for validation.
 */
export const StorySchema = z.object({
  id: z.string().uuid().optional(),
  storyId: z.string().min(1, 'Story ID cannot be empty'),
  feature: z.string().optional().nullable(),
  epic: z.string().optional().nullable(),
  title: z.string().min(1, 'Title cannot be empty'),
  storyDir: z.string().optional().nullable(),
  storyFile: z.string().optional().default('story.yaml'),
  storyType: StoryTypeSchema.optional().nullable(),
  points: z.number().int().positive().optional().nullable(),
  priority: StoryPrioritySchema.optional().nullable(),
  state: StoryStateSchema.optional().nullable(),
  phase: StoryPhaseSchema.optional().nullable(),
  iteration: z.number().int().min(0).optional().default(0),
  blocked: z.boolean().optional().default(false),
  blockedReason: z.string().optional().nullable(),
  blockedByStory: z.string().optional().nullable(),
  touchesBackend: z.boolean().optional().default(false),
  touchesFrontend: z.boolean().optional().default(false),
  touchesDatabase: z.boolean().optional().default(false),
  touchesInfra: z.boolean().optional().default(false),
  createdAt: z.date().optional(),
  updatedAt: z.date().optional(),
  startedAt: z.date().optional().nullable(),
  completedAt: z.date().optional().nullable(),
  fileSyncedAt: z.date().optional().nullable(),
  fileHash: z.string().optional().nullable(),
})

export type StoryInput = z.infer<typeof StorySchema>

/**
 * Schema for creating a new story.
 */
export const NewStorySchema = z.object({
  storyId: z.string().min(1, 'Story ID cannot be empty'),
  feature: z.string().optional().nullable(),
  epic: z.string().optional().nullable(),
  title: z.string().min(1, 'Title cannot be empty'),
  storyDir: z.string().optional().nullable(),
  storyFile: z.string().optional().default('story.yaml'),
  storyType: StoryTypeSchema.optional().nullable(),
  points: z.number().int().positive().optional().nullable(),
  priority: StoryPrioritySchema.optional().nullable(),
  state: StoryStateSchema.optional().nullable(),
  phase: StoryPhaseSchema.optional().nullable(),
  iteration: z.number().int().min(0).optional().default(0),
  blocked: z.boolean().optional().default(false),
  blockedReason: z.string().optional().nullable(),
  blockedByStory: z.string().optional().nullable(),
  touchesBackend: z.boolean().optional().default(false),
  touchesFrontend: z.boolean().optional().default(false),
  touchesDatabase: z.boolean().optional().default(false),
  touchesInfra: z.boolean().optional().default(false),
  fileHash: z.string().optional().nullable(),
})

export type NewStoryInput = z.infer<typeof NewStorySchema>

/**
 * Schema for updating a story.
 */
export const UpdateStorySchema = z.object({
  feature: z.string().optional().nullable(),
  epic: z.string().optional().nullable(),
  title: z.string().min(1).optional(),
  storyDir: z.string().optional().nullable(),
  storyFile: z.string().optional(),
  storyType: StoryTypeSchema.optional().nullable(),
  points: z.number().int().positive().optional().nullable(),
  priority: StoryPrioritySchema.optional().nullable(),
  state: StoryStateSchema.optional().nullable(),
  phase: StoryPhaseSchema.optional().nullable(),
  iteration: z.number().int().min(0).optional(),
  blocked: z.boolean().optional(),
  blockedReason: z.string().optional().nullable(),
  blockedByStory: z.string().optional().nullable(),
  touchesBackend: z.boolean().optional(),
  touchesFrontend: z.boolean().optional(),
  touchesDatabase: z.boolean().optional(),
  touchesInfra: z.boolean().optional(),
  startedAt: z.date().optional().nullable(),
  completedAt: z.date().optional().nullable(),
  fileSyncedAt: z.date().optional().nullable(),
  fileHash: z.string().optional().nullable(),
})

export type UpdateStoryInput = z.infer<typeof UpdateStorySchema>

/**
 * Story dependency schema for validation.
 */
export const StoryDependencySchema = z.object({
  id: z.string().uuid().optional(),
  storyId: z.string().min(1, 'Story ID cannot be empty'),
  targetStoryId: z.string().min(1, 'Target story ID cannot be empty'),
  dependencyType: DependencyTypeSchema,
  satisfied: z.boolean().optional().default(false),
  createdAt: z.date().optional(),
})

export type StoryDependencyInput = z.infer<typeof StoryDependencySchema>

/**
 * Schema for creating a new story dependency.
 */
export const NewStoryDependencySchema = z.object({
  storyId: z.string().min(1, 'Story ID cannot be empty'),
  targetStoryId: z.string().min(1, 'Target story ID cannot be empty'),
  dependencyType: DependencyTypeSchema,
  satisfied: z.boolean().optional().default(false),
})

export type NewStoryDependencyInput = z.infer<typeof NewStoryDependencySchema>

/**
 * Story artifact schema for validation.
 */
export const StoryArtifactSchema = z.object({
  id: z.string().uuid().optional(),
  storyId: z.string().min(1, 'Story ID cannot be empty'),
  artifactType: ArtifactTypeSchema,
  artifactName: z.string().optional().nullable(),
  kbEntryId: z.string().uuid().optional().nullable(),
  filePath: z.string().optional().nullable(),
  phase: StoryPhaseSchema.optional().nullable(),
  iteration: z.number().int().min(0).optional().nullable(),
  summary: z.record(z.unknown()).optional().nullable(),
  /** Full artifact content as JSONB (replaces file-based storage) */
  content: z.record(z.unknown()).optional().nullable(),
  createdAt: z.date().optional(),
  updatedAt: z.date().optional(),
})

export type StoryArtifactInput = z.infer<typeof StoryArtifactSchema>

/**
 * Schema for creating a new story artifact.
 */
export const NewStoryArtifactSchema = z.object({
  storyId: z.string().min(1, 'Story ID cannot be empty'),
  artifactType: ArtifactTypeSchema,
  artifactName: z.string().optional().nullable(),
  kbEntryId: z.string().uuid().optional().nullable(),
  filePath: z.string().optional().nullable(),
  phase: StoryPhaseSchema.optional().nullable(),
  iteration: z.number().int().min(0).optional().nullable(),
  summary: z.record(z.unknown()).optional().nullable(),
  /** Full artifact content as JSONB (replaces file-based storage) */
  content: z.record(z.unknown()).optional().nullable(),
})

export type NewStoryArtifactInput = z.infer<typeof NewStoryArtifactSchema>

/**
 * Schema for updating a story artifact.
 */
export const UpdateStoryArtifactSchema = z.object({
  artifactName: z.string().optional().nullable(),
  kbEntryId: z.string().uuid().optional().nullable(),
  filePath: z.string().optional().nullable(),
  phase: StoryPhaseSchema.optional().nullable(),
  iteration: z.number().int().min(0).optional().nullable(),
  summary: z.record(z.unknown()).optional().nullable(),
  /** Full artifact content as JSONB (replaces file-based storage) */
  content: z.record(z.unknown()).optional().nullable(),
})

export type UpdateStoryArtifactInput = z.infer<typeof UpdateStoryArtifactSchema>

// ============================================================================
// Token Usage Schemas (Story Token Tracking)
// ============================================================================

/**
 * Valid workflow phases for token logging.
 *
 * Phases are grouped by workflow stage:
 * - PM phases: pm-generate, pm-elaborate, pm-refine
 * - Dev phases: dev-setup, dev-implementation, dev-fix
 * - Review phases: code-review, qa-verification, qa-gate, architect-review
 * - Other: catch-all for custom phases
 */
export const TokenPhaseSchema = z.enum([
  'pm-generate',
  'pm-elaborate',
  'pm-refine',
  'dev-setup',
  'dev-implementation',
  'dev-fix',
  'code-review',
  'qa-verification',
  'qa-gate',
  'architect-review',
  'other',
])
export type TokenPhase = z.infer<typeof TokenPhaseSchema>

/**
 * Schema for logging token usage.
 */
export const TokenUsageSchema = z.object({
  id: z.string().uuid().optional(),
  storyId: z.string().min(1, 'Story ID cannot be empty'),
  feature: z.string().optional().nullable(),
  phase: TokenPhaseSchema,
  agent: z.string().optional().nullable(),
  iteration: z.number().int().min(0).optional().default(0),
  inputTokens: z.number().int().min(0),
  outputTokens: z.number().int().min(0),
  totalTokens: z.number().int().min(0).optional(),
  loggedAt: z.date().optional(),
  createdAt: z.date().optional(),
})

export type TokenUsageInput = z.infer<typeof TokenUsageSchema>

/**
 * Schema for creating a new token usage entry.
 */
export const NewTokenUsageSchema = z.object({
  storyId: z.string().min(1, 'Story ID cannot be empty'),
  feature: z.string().optional().nullable(),
  phase: TokenPhaseSchema,
  agent: z.string().optional().nullable(),
  iteration: z.number().int().min(0).optional().default(0),
  inputTokens: z.number().int().min(0),
  outputTokens: z.number().int().min(0),
})

export type NewTokenUsageInput = z.infer<typeof NewTokenUsageSchema>

/**
 * Valid grouping dimensions for token analytics.
 */
export const TokenGroupBySchema = z.enum(['phase', 'feature', 'story', 'agent'])
export type TokenGroupBy = z.infer<typeof TokenGroupBySchema>
