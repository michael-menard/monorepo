# Lambda Layers Architecture

This directory contains the Lambda Layer implementation for the LEGO API serverless application. Lambda Layers allow us to share dependencies across multiple Lambda functions, reducing deployment size and enabling per-function deployability.

## Overview

We use a **3-layer architecture** to optimize for different function types:

1. **minimal-layer** (~20MB) - Basic utilities for simple functions
2. **standard-layer** (~100MB) - Core infrastructure (database, cache, search)
3. **processing-layer** (~60MB) - Image and file processing

## Why Lambda Layers?

### Before (No Layers)

- Each Lambda function: ~150-200MB
- Deploy time: 30-60 seconds per function
- Total deployment: 45 functions × 60s = 45 minutes
- Core dependency update: Redeploy all 45 functions

### After (With Layers)

- Each Lambda function: ~5-10MB (code only)
- Deploy time: 5-10 seconds per function
- Total deployment: Much faster, only changed functions
- Core dependency update: Rebuild layer (2 min) + redeploy affected functions

### Additional Benefits

- **Faster cold starts**: Functions download layers in parallel
- **Better caching**: Layers cached separately from function code
- **Per-function deployment**: Change one endpoint, deploy one function
- **Layer reuse**: Common dependencies shared across all functions
- **Cost optimization**: Reduced storage and data transfer

## Directory Structure

```
layers/
├── README.md                           # This file
├── build-and-deploy-layers.sh          # Build and deploy all layers
├── get-layer-arns.ts                   # Helper to get layer ARNs
├── lambda-layer-mapping.ts             # Function → Layer mapping
├── sst-config-example.ts               # Example SST integration
├── minimal-layer/
│   ├── package.json                    # Dependencies
│   ├── README.md                       # Layer-specific docs
│   ├── layer-arn-{stage}.txt          # ARN (generated by build script)
│   ├── minimal-layer.zip              # Built artifact
│   └── nodejs/node_modules/           # Lambda layer format
├── standard-layer/
│   ├── package.json
│   ├── README.md
│   ├── layer-arn-{stage}.txt
│   ├── standard-layer.zip
│   └── nodejs/node_modules/
└── processing-layer/
    ├── package.json
    ├── README.md
    ├── layer-arn-{stage}.txt
    ├── processing-layer.zip
    └── nodejs/node_modules/
```

## Quick Start

### 1. Build and Deploy Layers

```bash
cd /Users/michaelmenard/Development/Monorepo/apps/api/layers

# Deploy to dev
./build-and-deploy-layers.sh dev us-east-1

# Deploy to production
./build-and-deploy-layers.sh production us-east-1
```

This will:

- Install dependencies for each layer
- Package them in Lambda layer format (`nodejs/node_modules/`)
- Zip the layers
- Publish to AWS Lambda
- Save ARNs to `layer-arn-{stage}.txt` files

### 2. Integrate with SST Config

See `sst-config-example.ts` for full examples. Basic usage:

```typescript
import { getLayerArns } from './layers/get-layer-arns'

export default $config({
  async run() {
    const layers = getLayerArns($app.stage)

    // Minimal layer only (health check)
    const health = new sst.aws.Function('Health', {
      handler: 'endpoints/health/handler.handler',
      layers: layers.minimal,
    })

    // Minimal + Standard (CRUD operations)
    const listAlbums = new sst.aws.Function('GalleryListAlbums', {
      handler: 'endpoints/gallery/list-albums/handler.handler',
      layers: layers.minimalStandard,
    })

    // All layers (image processing)
    const uploadImage = new sst.aws.Function('GalleryUploadImage', {
      handler: 'endpoints/gallery/upload-image/handler.handler',
      layers: layers.all,
      memory: '1024 MB',
    })
  },
})
```

### 3. Deploy Functions

```bash
cd /Users/michaelmenard/Development/Monorepo/apps/api

# Deploy all functions
pnpm sst deploy --stage dev

# SST will automatically use the layer ARNs from the layer-arn-*.txt files
```

## Layer Details

### Minimal Layer (~20MB)

**Used by:** 1 function (Health)

**Dependencies:**

- zod - Schema validation
- uuid - UUID generation
- @aws-sdk/client-s3 - Basic S3 operations

**When to use:** Simple functions that don't need database or cache access

### Standard Layer (~100MB)

**Used by:** ~38 functions (most CRUD operations)

**Dependencies:**

- drizzle-orm, pg - PostgreSQL database
- redis - Redis caching
- @opensearch-project/opensearch - Search
- AWS SDK clients (Secrets Manager, SNS, STS, etc.)
- aws-jwt-verify - Cognito authentication
- aws-xray-sdk-core - X-Ray tracing
- aws-embedded-metrics - CloudWatch metrics

**When to use:** Any function that needs database, cache, or search access

### Processing Layer (~60MB)

**Used by:** ~7 functions (file uploads, image processing)

**Dependencies:**

- sharp - High-performance image processing
- csv-parser - CSV parsing for parts lists
- xmldom - XML parsing

**When to use:** Functions that process images or files

**Important:** Sharp requires native bindings - must be built for Linux x64

## How It Works

### Lambda Layer Format

AWS Lambda requires layers to be packaged in a specific directory structure:

```
layer.zip
└── nodejs/
    └── node_modules/
        ├── package-1/
        ├── package-2/
        └── ...
```

When deployed, Lambda extracts the layer to `/opt/` and adds `/opt/nodejs/node_modules` to the Node.js require path.

### Function Code + Layers

```
Your Lambda function:
├── /var/task/                    # Your function code
│   └── handler.js
└── /opt/                         # Layer contents
    └── nodejs/node_modules/
        ├── zod/
        ├── drizzle-orm/
        └── sharp/
```

Your code can import from layers as if they were in your local `node_modules`:

```typescript
import { z } from 'zod' // From minimal layer
import { db } from '@/core/database' // From standard layer
import sharp from 'sharp' // From processing layer
```

## Dependency Management

### Adding a Dependency to a Layer

1. Update the layer's `package.json`:

   ```bash
   cd layers/standard-layer
   pnpm add new-package@version
   ```

2. Rebuild and redeploy the layer:

   ```bash
   cd ..
   ./build-and-deploy-layers.sh dev
   ```

3. Deploy affected functions:
   ```bash
   node ../scripts/get-affected-lambdas.js --layer standard
   # Deploy those functions
   ```

### Removing a Dependency

1. Remove from layer's `package.json`:

   ```bash
   cd layers/standard-layer
   pnpm remove old-package
   ```

2. Verify it's not used by any functions:

   ```bash
   cd /Users/michaelmenard/Development/Monorepo/apps/api
   grep -r "from 'old-package'" endpoints/
   ```

3. Rebuild and redeploy layer

### Moving a Dependency Between Layers

Example: Moving `sharp` from standard to processing layer

1. Add to processing-layer/package.json
2. Remove from standard-layer/package.json
3. Update function configurations to use processing layer
4. Rebuild both layers
5. Deploy affected functions

## Deployment Strategies

### Strategy 1: Automated CI/CD (Recommended)

GitHub Actions automatically:

- Detects changed files
- Rebuilds layers if `layers/` directory changed
- Deploys only affected Lambda functions
- Reports deployment status

See `.github/workflows/deploy-api-lambdas.yml`

### Strategy 2: Manual Selective Deployment

```bash
# 1. Detect affected functions
AFFECTED=$(node scripts/get-affected-lambdas.js --verbose)

# 2. Deploy layers if needed
./layers/build-and-deploy-layers.sh dev

# 3. Deploy functions
pnpm sst deploy --stage dev
# SST will only update changed resources
```

### Strategy 3: Full Deployment

```bash
# Rebuild all layers
./layers/build-and-deploy-layers.sh production us-east-1

# Deploy entire stack
cd ..
pnpm sst deploy --stage production
```

## Change Detection

The `scripts/get-affected-lambdas.js` script determines which functions need deployment:

| Change Type         | Affected Functions                 | Example                                                          |
| ------------------- | ---------------------------------- | ---------------------------------------------------------------- |
| Single endpoint     | That endpoint only                 | `endpoints/gallery/upload-image/handler.ts` → GalleryUploadImage |
| Domain schemas      | All endpoints in domain            | `endpoints/gallery/schemas.ts` → All gallery functions           |
| `_shared` directory | All endpoints in domain            | `endpoints/moc-instructions/_shared/` → All MOC functions        |
| `core/` directory   | All functions using standard layer | `core/database/client.ts` → 38 functions                         |
| Layer package.json  | All functions using that layer     | `layers/processing-layer/package.json` → 7 functions             |
| sst.config.ts       | All functions                      | `sst.config.ts` → All 44 functions                               |

## Local Development

### Important: Layers Not Used Locally

When running `sst dev`, Lambda layers are **NOT** used. Functions run locally with dependencies from the main `apps/api/package.json`.

This is by design:

- ✅ Faster iteration (no layer rebuilding)
- ✅ Local debugging works normally
- ✅ Hot module reloading

The main `package.json` should contain **all** dependencies for development. Layer `package.json` files are subsets used only for deployment.

### Testing Layer Changes

To test layer changes before deploying:

1. Update main `package.json` with the same dependency version
2. Test locally with `sst dev`
3. Update layer `package.json`
4. Deploy layer to dev stage
5. Deploy a test function
6. Verify in AWS Lambda console

## Troubleshooting

### Layer ARN not found

**Error:** `No ARN found for minimal-layer (stage: dev)`

**Solution:**

```bash
cd layers
./build-and-deploy-layers.sh dev us-east-1
```

### Function can't find module

**Error:** `Cannot find module 'some-package'`

**Causes:**

1. Package not in any layer
2. Layer not attached to function
3. Wrong layer version

**Solution:**

```bash
# Check which layers the function uses
grep "YourFunctionName" layers/lambda-layer-mapping.ts

# Verify package is in the layer
cat layers/standard-layer/package.json | grep some-package

# Rebuild layer and redeploy function
./layers/build-and-deploy-layers.sh dev
cd ..
pnpm sst deploy --stage dev
```

### Sharp installation error

**Error:** `sharp: Installation error: linux-x64`

**Cause:** Sharp has native bindings that must be compiled for Linux

**Solution:**

```bash
cd layers/processing-layer
rm -rf nodejs/node_modules
pnpm install --prod --platform=linux --arch=x64
```

Or use Docker:

```bash
docker run --rm -v "$PWD":/var/task lambci/lambda:build-nodejs20.x \
  npm install --production --platform=linux --arch=x64
```

### Layer size exceeds 250MB unzipped

**Error:** Lambda layer unzipped size limit is 250MB

**Solution:**

1. Check layer sizes:
   ```bash
   unzip -l standard-layer.zip | tail -1
   ```
2. Review dependencies:
   ```bash
   cd nodejs
   du -sh node_modules/* | sort -h
   ```
3. Remove or move heavy dependencies

### Deployment too slow

**Cause:** Deploying all functions even when only one changed

**Solution:** Use the deployment helper:

```bash
# Deploy only affected functions
AFFECTED=$(node scripts/get-affected-lambdas.js)
echo "Deploying: $AFFECTED"
pnpm sst deploy --stage dev
```

## Best Practices

### 1. Layer Versioning

Layers are immutable - each publish creates a new version. The ARN includes the version:

```
arn:aws:lambda:us-east-1:123456789012:layer:lego-api-standard-layer-dev:5
                                                                         ^ version
```

Our scripts automatically:

- Create new versions on each publish
- Update the ARN files with the latest version
- SST picks up the latest version on next deployment

### 2. Minimize Layer Changes

Changing a layer triggers redeployment of all functions using it:

- Standard layer → 38 functions
- Processing layer → 7 functions

Batch dependency updates when possible.

### 3. Keep Main package.json Complete

The main `apps/api/package.json` should contain ALL dependencies for local development. Layer package.json files are subsets.

### 4. Test in Dev First

Always test layer changes in dev stage before production:

```bash
# Dev
./layers/build-and-deploy-layers.sh dev
pnpm sst deploy --stage dev
# Test...

# Production
./layers/build-and-deploy-layers.sh production
pnpm sst deploy --stage production
```

### 5. Monitor Layer Sizes

Keep layer sizes reasonable:

- Minimal: <50MB unzipped
- Standard: <300MB unzipped
- Processing: <200MB unzipped
- **Total across all layers: <512MB** (Lambda limit)

## SST v3 and Lambda Layers

### Important Limitation

SST v3 (Ion) does **not** have built-in support for creating Lambda layers like SST v2 did. There's no `sst.aws.Layer` component.

Instead, we:

1. Build layers manually using shell scripts
2. Deploy to AWS using AWS CLI
3. Reference the ARNs in `sst.config.ts`

This approach has some advantages:

- ✅ Layers deployed independently of SST
- ✅ Can update layers without SST
- ✅ Explicit control over layer versions
- ✅ Works with any IaC tool (not just SST)

### Future: Native Layer Support

If SST adds native layer support in the future, we can migrate to:

```typescript
// Hypothetical future syntax (not available yet)
const minimalLayer = new sst.aws.Layer('MinimalLayer', {
  code: './layers/minimal-layer',
  compatibleRuntimes: ['nodejs20.x'],
})

const myFunction = new sst.aws.Function('MyFunction', {
  layers: [minimalLayer.arn],
})
```

For now, the manual approach works well and gives us full control.

## References

- [AWS Lambda Layers Documentation](https://docs.aws.amazon.com/lambda/latest/dg/chapter-layers.html)
- [SST v3 Function Documentation](https://sst.dev/docs/component/aws/function/)
- [Lambda Layer Format Requirements](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html#configuration-layers-path)
- [Sharp Installation for Lambda](https://sharp.pixelplumbing.com/install#aws-lambda)

## Support

For issues or questions:

1. Check individual layer README.md files
2. Review troubleshooting section above
3. Check GitHub Issues
4. Ask in team chat
