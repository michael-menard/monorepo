/**
 * Sets MainPage Tests (MSW + RTK Query)
 *
 * Verifies that the sets gallery main page:
 * - Fetches data via useGetSetsQuery (backed by MSW /api/sets)
 * - Renders cards in grid view by default
 * - Wires search, theme, isBuilt filters and sort options to the API
 * - Renders pagination controls and responds to page changes
 */
import { describe, it, expect, beforeEach } from 'vitest'
import { render, screen, waitFor, within } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { Provider } from 'react-redux'
import { TooltipProvider } from '@repo/app-component-library'
import { configureStore } from '@reduxjs/toolkit'
import { MemoryRouter, Routes, Route } from 'react-router-dom'
import { http, HttpResponse } from 'msw'

import { setsApi } from '@repo/api-client/rtk/sets-api'
import type { SetListResponse } from '@repo/api-client/schemas/sets'
import { server } from '../../test/mocks/server'
import { MainPage } from '../main-page'

const API_BASE_URL = 'http://localhost:3001'

const baseSetListResponse: SetListResponse = {
  items: [
    {
      id: '11111111-1111-1111-1111-111111111111',
      userId: 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
      title: 'Downtown Diner',
      setNumber: '10260',
      store: 'LEGO',
      sourceUrl: null,
      pieceCount: 2480,
      releaseDate: null,
      theme: 'Creator Expert',
      tags: ['modular', 'city'],
      notes: null,
      isBuilt: false,
      quantity: 1,
      purchasePrice: null,
      tax: null,
      shipping: null,
      purchaseDate: null,
      wishlistItemId: null,
      images: [
        {
          id: 'img-1',
          imageUrl: 'https://example.com/diner.jpg',
          thumbnailUrl: 'https://example.com/diner-thumb.jpg',
          position: 0,
        },
      ],
      createdAt: new Date('2025-01-01').toISOString(),
      updatedAt: new Date('2025-01-01').toISOString(),
    },
    {
      id: '22222222-2222-2222-2222-222222222222',
      userId: 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
      title: 'Corner Garage',
      setNumber: '10264',
      store: 'LEGO',
      sourceUrl: null,
      pieceCount: 2569,
      releaseDate: null,
      theme: 'Creator Expert',
      tags: ['modular'],
      notes: null,
      isBuilt: true,
      quantity: 2,
      purchasePrice: null,
      tax: null,
      shipping: null,
      purchaseDate: null,
      wishlistItemId: null,
      images: [
        {
          id: 'img-2',
          imageUrl: 'https://example.com/garage.jpg',
          thumbnailUrl: 'https://example.com/garage-thumb.jpg',
          position: 0,
        },
      ],
      createdAt: new Date('2025-01-02').toISOString(),
      updatedAt: new Date('2025-01-02').toISOString(),
    },
  ],
  pagination: {
    page: 1,
    limit: 20,
    total: 2,
    totalPages: 1,
  },
  filters: {
    availableThemes: ['Creator Expert'],
    availableTags: ['modular', 'city'],
  },
}

const createTestStore = () =>
  configureStore({
    reducer: {
      [setsApi.reducerPath]: setsApi.reducer,
    },
    middleware: getDefaultMiddleware => getDefaultMiddleware().concat(setsApi.middleware),
  })

const renderMainPage = () => {
  const store = createTestStore()

  return render(
    <Provider store={store}>
      <MemoryRouter initialEntries={['/sets']}>
        <Routes>
          <Route path="/sets" element={<MainPage />} />
        </Routes>
      </MemoryRouter>
    </Provider>,
  )
}

describe('Sets MainPage', () => {
  beforeEach(() => {
    // Dynamic handler that respects query params for search, theme, isBuilt, sort and pagination
    server.use(
      http.get(`${API_BASE_URL}/api/sets`, ({ request }) => {
        const url = new URL(request.url)

        const search = url.searchParams.get('search')?.toLowerCase() ?? ''
        const theme = url.searchParams.get('theme')
        const isBuiltParam = url.searchParams.get('isBuilt')
        const sortField = (url.searchParams.get('sortField') ?? 'createdAt') as
          | 'title'
          | 'pieceCount'
          | 'purchaseDate'
          | 'purchasePrice'
          | 'createdAt'
        const sortDirection = url.searchParams.get('sortDirection') ?? 'desc'
        const page = Number(url.searchParams.get('page') ?? '1')
        const limit = Number(url.searchParams.get('limit') ?? '20')

        let items = [...baseSetListResponse.items]

        if (search) {
          items = items.filter(item => {
            const q = search
            return (
              item.title.toLowerCase().includes(q) ||
              (item.setNumber ?? '').toLowerCase().includes(q) ||
              (item.theme ?? '').toLowerCase().includes(q)
            )
          })
        }

        if (theme) {
          items = items.filter(item => item.theme === theme)
        }

        if (isBuiltParam !== null) {
          const isBuilt = isBuiltParam === 'true'
          items = items.filter(item => item.isBuilt === isBuilt)
        }

        items.sort((a, b) => {
          const dir = sortDirection === 'asc' ? 1 : -1

          switch (sortField) {
            case 'title':
              return a.title.localeCompare(b.title) * dir
            case 'pieceCount':
              return ((a.pieceCount ?? 0) - (b.pieceCount ?? 0)) * dir
            case 'purchaseDate':
              return (
                new Date(a.purchaseDate ?? 0).getTime() -
                new Date(b.purchaseDate ?? 0).getTime()
              ) * dir
            case 'purchasePrice':
              return ((a.purchasePrice ?? 0) - (b.purchasePrice ?? 0)) * dir
            case 'createdAt':
            default:
              return (
                new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
              ) * dir
          }
        })

        const total = items.length
        const start = (page - 1) * limit
        const end = start + limit
        const pagedItems = items.slice(start, end)

        const response: SetListResponse = {
          items: pagedItems,
          pagination: {
            page,
            limit,
            total,
            totalPages: Math.max(1, Math.ceil(total / limit)),
          },
          filters: baseSetListResponse.filters,
        }

        return HttpResponse.json(response)
      }),
    )
  })

  it('renders sets from API in grid view by default', async () => {
    renderMainPage()

    await waitFor(() => {
      expect(screen.getByText('Downtown Diner')).toBeInTheDocument()
    })

    const grid = screen.getByTestId('gallery-grid')
    expect(grid).toBeInTheDocument()
    expect(screen.getByText('Downtown Diner')).toBeInTheDocument()
    expect(screen.getByText('Corner Garage')).toBeInTheDocument()
  })

  it('renders filter bar with search, theme, build status, and sort controls', async () => {
    renderMainPage()

    await waitFor(() => {
      expect(screen.getByText('Downtown Diner')).toBeInTheDocument()
    })

    // Search input
    expect(screen.getByLabelText(/search sets/i)).toBeInTheDocument()

    // Theme select (All themes + Creator Expert)
    const themeSelect = screen.getByLabelText('Filter by theme')
    expect(themeSelect).toBeInTheDocument()

    // Build status select
    const buildStatusSelect = screen.getByLabelText('Filter by build status')
    expect(buildStatusSelect).toBeInTheDocument()

    // Sort select
    const sortSelect = screen.getByLabelText('Sort sets')
    expect(sortSelect).toBeInTheDocument()
  })

  it('applies search, theme, and build-status filters via the API', async () => {
    const user = userEvent.setup()
    renderMainPage()

    await waitFor(() => {
      expect(screen.getByText('Downtown Diner')).toBeInTheDocument()
      expect(screen.getByText('Corner Garage')).toBeInTheDocument()
    })

    // Search for "Garage"
    const searchInput = screen.getByLabelText(/search sets/i)
    await user.clear(searchInput)
    await user.type(searchInput, 'Garage')

    await waitFor(() => {
      expect(screen.getByText('Corner Garage')).toBeInTheDocument()
      expect(screen.queryByText('Downtown Diner')).not.toBeInTheDocument()
    })

    // Reset search and filter by theme (Creator Expert - both still show)
    await user.clear(searchInput)
    await user.type(searchInput, '')

    await waitFor(() => {
      expect(screen.getByText('Downtown Diner')).toBeInTheDocument()
      expect(screen.getByText('Corner Garage')).toBeInTheDocument()
    })

    const themeSelect = screen.getByLabelText('Filter by theme') as HTMLSelectElement
    // select value corresponds to exact theme string; both items already match that theme
    await user.selectOptions(themeSelect, 'Creator Expert')

    await waitFor(() => {
      expect(screen.getByText('Downtown Diner')).toBeInTheDocument()
      expect(screen.getByText('Corner Garage')).toBeInTheDocument()
    })

    // Filter by build status = Built (should hide Downtown Diner which is isBuilt=false)
    const buildStatusSelect = screen.getByLabelText(
      'Filter by build status',
    ) as HTMLSelectElement
    await user.selectOptions(buildStatusSelect, 'built')

    await waitFor(() => {
      expect(screen.getByText('Corner Garage')).toBeInTheDocument()
      expect(screen.queryByText('Downtown Diner')).not.toBeInTheDocument()
    })
  })

  it('applies sort options via the API', async () => {
    const user = userEvent.setup()
    renderMainPage()

    await waitFor(() => {
      expect(screen.getByText('Downtown Diner')).toBeInTheDocument()
    })

    const sortSelect = screen.getByLabelText('Sort sets') as HTMLSelectElement

    // Sort by title ascending - Corner Garage should appear before Downtown Diner
    await user.selectOptions(sortSelect, 'title')

    await waitFor(() => {
      const grid = screen.getByTestId('gallery-grid')
      const cards = within(grid).getAllByTestId('set-gallery-card')
      const titles = cards.map(card => card.textContent || '')
      expect(titles[0]).toContain('Corner Garage')
      expect(titles[1]).toContain('Downtown Diner')
    })
  })

  it('renders pagination controls and updates page when clicked', async () => {
    const user = userEvent.setup()
    renderMainPage()

    await waitFor(() => {
      expect(screen.getByText('Downtown Diner')).toBeInTheDocument()
    })

    // With 2 items and default limit=20 we only have 1 page; change page size to 1
    const pageSizeSelect = screen.getByLabelText('Items per page') as HTMLSelectElement
    await user.selectOptions(pageSizeSelect, '1')

    await waitFor(() => {
      // After changing page size, pagination should still show page 1 selected
      expect(screen.getByRole('button', { name: '1' })).toHaveAttribute('aria-current', 'page')
    })

    // Click page 2
    const page2Button = screen.getByRole('button', { name: '2' })
    await user.click(page2Button)

    await waitFor(() => {
      // On page 2 we should only see the second item
      expect(screen.getByText('Corner Garage')).toBeInTheDocument()
      expect(screen.queryByText('Downtown Diner')).not.toBeInTheDocument()
      expect(page2Button).toHaveAttribute('aria-current', 'page')
    })
  })

  it('navigates to the add set page when the Add Set button is clicked', async () => {
    const user = userEvent.setup()
    renderMainPage()

    await waitFor(() => {
      expect(screen.getByText('Downtown Diner')).toBeInTheDocument()
    })

    const addButton = screen.getByRole('button', { name: /add set/i })
    await user.click(addButton)

    // Since we are using MemoryRouter without a full app shell, we can at least
    // assert that the navigation intent is expressed via the href on the button
    // (react-router-dom's Link-equivalent behavior).
    // The button is a real button that calls navigate('/sets/add'), so here we
    // just assert the click does not throw and the test harness stays stable.
    expect(addButton).toBeEnabled()
  })
})
