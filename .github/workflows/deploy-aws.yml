# This file is now replaced by individual app deployment workflows
# See:
# - .github/workflows/deploy-frontend.yml
# - .github/workflows/deploy-auth-service.yml
# - .github/workflows/deploy-lego-api.yml

# Benefits of per-app deployments:
# ✅ Independent deployments
# ✅ Faster builds (only what changed)
# ✅ Clear ownership per team
# ✅ Different release cycles
# ✅ Easier rollbacks

# This file is kept for reference but disabled

jobs:
  # Detect what needs to be deployed
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      frontend: ${{ steps.changes.outputs.frontend }}
      auth-service: ${{ steps.changes.outputs.auth-service }}
      lego-projects-api: ${{ steps.changes.outputs.lego-projects-api }}
      packages: ${{ steps.changes.outputs.packages }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            frontend:
              - 'apps/web/lego-moc-instructions-app/**'
              - 'packages/**'
            auth-service:
              - 'apps/api/auth-service/**'
              - 'packages/**'
            lego-projects-api:
              - 'apps/api/lego-projects-api/**'
              - 'packages/**'
            packages:
              - 'packages/**'

  # Build and deploy frontend to S3 + CloudFront
  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.frontend == 'true' || needs.changes.outputs.packages == 'true'
    environment: ${{ github.event.inputs.environment || 'staging' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build packages
        run: pnpm turbo build --filter="./packages/*"

      - name: Build frontend
        run: pnpm turbo build --filter="@repo/lego-moc-instructions-app"
        env:
          VITE_API_URL: ${{ vars.VITE_API_URL }}
          VITE_AUTH_API_URL: ${{ vars.VITE_AUTH_API_URL }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to S3
        run: |
          aws s3 sync apps/web/lego-moc-instructions-app/dist/ s3://${{ vars.S3_BUCKET_NAME }} --delete
          
      - name: Invalidate CloudFront
        run: |
          aws cloudfront create-invalidation --distribution-id ${{ vars.CLOUDFRONT_DISTRIBUTION_ID }} --paths "/*"

  # Build and deploy Auth Service to ECS
  deploy-auth-service:
    name: Deploy Auth Service
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.auth-service == 'true' || needs.changes.outputs.packages == 'true'
    environment: ${{ github.event.inputs.environment || 'staging' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: auth-service
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f apps/api/auth-service/Dockerfile -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Update ECS service
        run: |
          aws ecs update-service --cluster ${{ vars.ECS_CLUSTER_NAME }} --service auth-service --force-new-deployment

  # Build and deploy LEGO Projects API to ECS
  deploy-lego-projects-api:
    name: Deploy LEGO Projects API
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.lego-projects-api == 'true' || needs.changes.outputs.packages == 'true'
    environment: ${{ github.event.inputs.environment || 'staging' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: lego-projects-api
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f apps/api/lego-projects-api/Dockerfile -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Update ECS service
        run: |
          aws ecs update-service --cluster ${{ vars.ECS_CLUSTER_NAME }} --service lego-projects-api --force-new-deployment

  # Run database migrations if needed
  run-migrations:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs: [deploy-lego-projects-api]
    if: needs.deploy-lego-projects-api.result == 'success'
    environment: ${{ github.event.inputs.environment || 'staging' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run migrations
        run: |
          cd apps/api/lego-projects-api
          pnpm run db:migrate
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
